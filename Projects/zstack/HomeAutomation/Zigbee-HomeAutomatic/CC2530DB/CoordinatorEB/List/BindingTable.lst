###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                28/Aug/2016  20:47:59
# Copyright 2004-2015 IAR Systems AB.
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Components\stack\nwk\BindingTable.c
#    Command line       =  
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Components\stack\nwk\BindingTable.c" -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D HOLD_AUTO_START -D
#        BUILD_ALL_DEVICES -D HAL_UART=TRUE -D xZTOOL_P1 -D xMT_TASK -D
#        xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG
#        -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D
#        ZCL_EZMODE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF -D ZCL_SCENES -D
#        ZCL_GROUPS -D xZCL_LEVEL_CTRL -D ZCL_DIAGNOSTIC -D
#        FEATURE_SYSTEM_STATS -D DEVICE_LOGICAL_TYPE=ZG_DEVICETYPE_COORDINATOR
#        -lC "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\List"
#        -lA "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz
#    List file          =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\List\BindingTable.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\Obj\BindingTable.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.2a.44539\Components\stack\nwk\BindingTable.c
      1          /**************************************************************************************************
      2            Filename:       BindingTable.c
      3            Revised:        $Date: 2014-10-08 08:37:03 -0700 (Wed, 08 Oct 2014) $
      4            Revision:       $Revision: 40512 $
      5          
      6            Description:    Device binding table functions.
      7          
      8          
      9            Copyright 2004-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Nv.h"
     46          #include "nwk_globals.h"
     47          #include "AddrMgr.h"
     48          #include "BindingTable.h"
     49          #include "nwk_util.h"
     50          
     51          /*********************************************************************
     52           * MACROS
     53           */
     54          
     55          /*********************************************************************
     56           * CONSTANTS
     57           */
     58          #define NV_BIND_EMPTY   0xFF
     59          #define NV_BIND_REC_SIZE (gBIND_REC_SIZE)
     60          #define NV_BIND_ITEM_SIZE  (gBIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES)
     61          
     62          /*********************************************************************
     63           * TYPEDEFS
     64           */
     65          typedef struct
     66          {
     67            uint8        srcEP;
     68            uint16       dstIndex;
     69            uint8        dstEP;
     70            uint8        dstAddrMode;
     71            uint8        clusterIDs;
     72            uint16*      clusterIDList;
     73          } bindFields_t;
     74          
     75          /*********************************************************************
     76           * GLOBAL VARIABLES
     77           */
     78          
     79          /*********************************************************************
     80           * LOCAL FUNCTIONS
     81           */
     82          void BindAddrMgrCB( uint8 update, AddrMgrEntry_t *entryOld,
     83                              AddrMgrEntry_t *entryNew );
     84          BindingEntry_t *bindFindEmpty( void );
     85          uint16 bindingAddrMgsHelperFind( zAddrType_t *addr );
     86          uint8 bindingAddrMgsHelperConvert( uint16 idx, zAddrType_t *addr );
     87          void bindAddrMgrLocalLoad( void );
     88          
     89          #if !defined ( BINDINGTABLE_NV_SINGLES )
     90            #if !defined ( DONT_UPGRADE_BIND )
     91              static uint8 BindCopyBackupToNewNV( uint16 dupLen, uint16 newLen );
     92              static uint8 BindUpgradeTableInNV( void );
     93            #endif
     94          #endif // !BINDINGTABLE_NV_SINGLES
     95          
     96          
     97          /*********************************************************************
     98           * LOCAL VARIABLES
     99           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    100          static uint8 bindAddrMgrLocalLoaded = FALSE;
   \                     bindAddrMgrLocalLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    101          
    102          /*********************************************************************
    103           * Function Pointers
    104           */
    105          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    106          BindingEntry_t *(*pbindAddEntry)( byte srcEpInt,
   \                     pbindAddEntry:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    107                                            zAddrType_t *dstAddr, byte dstEpInt,
    108                                            byte numClusterIds, uint16 *clusterIds ) = (void*)NULL;

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    109          uint16 (*pbindNumOfEntries)( void ) = (void*)NULL;
   \                     pbindNumOfEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    110          void (*pbindRemoveDev)( zAddrType_t *Addr ) = (void*)NULL;
   \                     pbindRemoveDev:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          byte (*pBindInitNV)( void ) = (void*)NULL;
   \                     pBindInitNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    112          void (*pBindSetDefaultNV)( void ) = (void*)NULL;
   \                     pBindSetDefaultNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          uint16 (*pBindRestoreFromNV)( void ) = (void*)NULL;
   \                     pBindRestoreFromNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    114          void (*pBindWriteNV)( void ) = (void*)NULL;
   \                     pBindWriteNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    115          
    116          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
    117          /*********************************************************************
    118           * @fn      BindAddrMgrCB()
    119           *
    120           * @brief   Address Manager Callback function
    121           *
    122           * @param   update -
    123           * @param   entry -
    124           *
    125           * @return  pointer to
    126           */
    127          void BindAddrMgrCB( uint8 update, AddrMgrEntry_t *entryNew,
    128                              AddrMgrEntry_t *entryOld )
    129          {
    130            // Check for either deleted items or changed Extended (Duplicate) addresses
    131          }
    132          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
    133          
    134          /*********************************************************************
    135           * @fn      InitBindingTable()
    136           *
    137           * @brief
    138           *
    139           *   This function is used to initialise the binding table
    140           *
    141           * @param   none
    142           *
    143           * @return  none
    144           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void InitBindingTable( void )
   \                     InitBindingTable:
    146          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    147            osal_memset( BindingTable, 0xFF, gBIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES );
   \   000005                ; Setup parameters for call to function osal_memset
   \   000005   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000008   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000B   E4           CLR     A
   \   00000C   93           MOVC    A,@A+DPTR
   \   00000D   F5..         MOV     ?V0,A
   \   00000F   EC           MOV     A,R4
   \   000010   85..F0       MOV     B,?V0
   \   000013   A4           MUL     AB
   \   000014   FC           MOV     R4,A
   \   000015   A8F0         MOV     R0,B
   \   000017   85..F0       MOV     B,?V0
   \   00001A   ED           MOV     A,R5
   \   00001B   A4           MUL     AB
   \   00001C   28           ADD     A,R0
   \   00001D   FD           MOV     R5,A
   \   00001E   79FF         MOV     R1,#-0x1
   \   000020   7A..         MOV     R2,#BindingTable & 0xff
   \   000022   7B..         MOV     R3,#(BindingTable >> 8) & 0xff
   \   000024   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    148          
    149            pbindAddEntry = bindAddEntry;
   \   000027   90....       MOV     DPTR,#pbindAddEntry
   \   00002A   74..         MOV     A,#`??bindAddEntry::?relay` & 0xff
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   74..         MOV     A,#(`??bindAddEntry::?relay` >> 8) & 0xff
   \   000030   F0           MOVX    @DPTR,A
    150            pbindNumOfEntries = bindNumOfEntries;
   \   000031   90....       MOV     DPTR,#pbindNumOfEntries
   \   000034   74..         MOV     A,#`??bindNumOfEntries::?relay` & 0xff
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   74..         MOV     A,#(`??bindNumOfEntries::?relay` >> 8) & 0xff
   \   00003A   F0           MOVX    @DPTR,A
    151            pbindRemoveDev = bindRemoveDev;
   \   00003B   90....       MOV     DPTR,#pbindRemoveDev
   \   00003E   74..         MOV     A,#`??bindRemoveDev::?relay` & 0xff
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   74..         MOV     A,#(`??bindRemoveDev::?relay` >> 8) & 0xff
   \   000044   F0           MOVX    @DPTR,A
    152            pBindInitNV = BindInitNV;
   \   000045   90....       MOV     DPTR,#pBindInitNV
   \   000048   74..         MOV     A,#`??BindInitNV::?relay` & 0xff
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   74..         MOV     A,#(`??BindInitNV::?relay` >> 8) & 0xff
   \   00004E   F0           MOVX    @DPTR,A
    153            pBindSetDefaultNV = BindSetDefaultNV;
   \   00004F   90....       MOV     DPTR,#pBindSetDefaultNV
   \   000052   74..         MOV     A,#`??BindSetDefaultNV::?relay` & 0xff
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   74..         MOV     A,#(`??BindSetDefaultNV::?relay` >> 8) & 0xff
   \   000058   F0           MOVX    @DPTR,A
    154            pBindRestoreFromNV = BindRestoreFromNV;
   \   000059   90....       MOV     DPTR,#pBindRestoreFromNV
   \   00005C   74..         MOV     A,#`??BindRestoreFromNV::?relay` & 0xff
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   A3           INC     DPTR
   \   000060   74..         MOV     A,#(`??BindRestoreFromNV::?relay` >> 8) & 0xff
   \   000062   F0           MOVX    @DPTR,A
    155            pBindWriteNV = BindWriteNV;
   \   000063   90....       MOV     DPTR,#pBindWriteNV
   \   000066   74..         MOV     A,#`??BindWriteNV::?relay` & 0xff
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   74..         MOV     A,#(`??BindWriteNV::?relay` >> 8) & 0xff
   \   00006C   F0           MOVX    @DPTR,A
    156          
    157            bindAddrMgrLocalLoaded = FALSE;
   \   00006D   90....       MOV     DPTR,#bindAddrMgrLocalLoaded
   \   000070   E4           CLR     A
   \   000071   F0           MOVX    @DPTR,A
    158          
    159          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
    160            // Register with the address manager
    161            AddrMgrRegister( ADDRMGR_REG_BINDING, BindAddrMgrCB );
    162          #endif
    163          }
   \   000072   80..         SJMP    ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   90....       MOV     DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR     A
   \   000004   93           MOVC    A,@A+DPTR
   \   000005   FC           MOV     R4,A
   \   000006   7401         MOV     A,#0x1
   \   000008   93           MOVC    A,@A+DPTR
   \   000009   FD           MOV     R5,A
   \   00000A   22           RET
    164          
    165          /*********************************************************************
    166           * @fn      bindFindEmpty()
    167           *
    168           * @brief   This function returns a pointer to an empty binding slot
    169           *
    170           * @param   none
    171           *
    172           * @return  pointer to binding table entry, NULL if not added
    173           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    174          BindingEntry_t *bindFindEmpty( void )
   \                     bindFindEmpty:
    175          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    176            bindTableIndex_t x;
    177          
    178            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000004   7A00         MOV     R2,#0x0
   \   000006   8001         SJMP    ??bindFindEmpty_0
   \                     ??bindFindEmpty_1:
   \   000008   0A           INC     R2
   \                     ??bindFindEmpty_0:
   \   000009   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000C   E4           CLR     A
   \   00000D   93           MOVC    A,@A+DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   EA           MOV     A,R2
   \   000010   C3           CLR     C
   \   000011   98           SUBB    A,R0
   \   000012   5013         JNC     ??bindFindEmpty_2
    179            {
    180              // It's empty if the index is "Not Found"
    181              if ( BindingTable[x].srcEP == NV_BIND_EMPTY )
   \   000014   EA           MOV     A,R2
   \   000015   75F00E       MOV     B,#0xe
   \   000018   A4           MUL     AB
   \   000019   F8           MOV     R0,A
   \   00001A   A9F0         MOV     R1,B
   \   00001C   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00001F   70E7         JNZ     ??bindFindEmpty_1
    182              {
    183                return ( &BindingTable[x] );
   \   000021   AA82         MOV     R2,DPL
   \   000023   AB83         MOV     R3,DPH
   \   000025   8004         SJMP    ??bindFindEmpty_3
    184              }
    185            }
    186          
    187            return ( (BindingEntry_t *)NULL );
   \                     ??bindFindEmpty_2:
   \   000027   7A00         MOV     R2,#0x0
   \   000029   7B00         MOV     R3,#0x0
   \                     ??bindFindEmpty_3:
   \   00002B   02....       LJMP    ??Subroutine34_0 & 0xFFFF
    188          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   F4           CPL     A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   74..         MOV     A,#BindingTable & 0xff
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   74..         MOV     A,#(BindingTable >> 8) & 0xff
   \   000007   39           ADDC    A,R1
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    189          
    190          /*********************************************************************
    191           * @fn      bindNumOfEntries()
    192           *
    193           * @brief   This function returns the number of binding table entries.
    194           *          The return for this is the number of clusters in the
    195           *          table NOT the number of entries.
    196           *
    197           * @param   none
    198           *
    199           * @return  number of entries
    200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    201          uint16 bindNumOfEntries( void )
   \                     bindNumOfEntries:
    202          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    203            bindTableIndex_t x;
    204            uint16 found;
    205          
    206            for ( found = 0, x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7B00         MOV     R3,#0x0
   \   000008   7C00         MOV     R4,#0x0
   \   00000A   801B         SJMP    ??bindNumOfEntries_0
    207            {
    208              // It's empty if the index is "Not Found"
    209              if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \                     ??bindNumOfEntries_1:
   \   00000C   EC           MOV     A,R4
   \   00000D   75F00E       MOV     B,#0xe
   \   000010   A4           MUL     AB
   \   000011   F8           MOV     R0,A
   \   000012   A9F0         MOV     R1,B
   \   000014   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000017   600D         JZ      ??bindNumOfEntries_2
    210              {
    211                found += BindingTable[x].numClusterIds;
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   EA           MOV     A,R2
   \   000021   28           ADD     A,R0
   \   000022   FA           MOV     R2,A
   \   000023   E4           CLR     A
   \   000024   3B           ADDC    A,R3
   \   000025   FB           MOV     R3,A
    212              }
    213            }
   \                     ??bindNumOfEntries_2:
   \   000026   0C           INC     R4
   \                     ??bindNumOfEntries_0:
   \   000027   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00002A   E4           CLR     A
   \   00002B   93           MOVC    A,@A+DPTR
   \   00002C   F8           MOV     R0,A
   \   00002D   EC           MOV     A,R4
   \   00002E   C3           CLR     C
   \   00002F   98           SUBB    A,R0
   \   000030   40DA         JC      ??bindNumOfEntries_1
    214          
    215            return ( found );
   \   000032   02....       LJMP    ??Subroutine34_0 & 0xFFFF
    216          }
    217          
    218          /*********************************************************************
    219           * @fn      bindCapacity()
    220           *
    221           * @brief   This function returns the number of binding entries
    222           *          possible and used.
    223           *
    224           * @param   maxEntries - pointer to a place to put the max entries
    225           * @param   usedEntries - pointer to a place to put the number
    226           *               of used entries
    227           *
    228           * @return  none
    229           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          void bindCapacity( uint16 *maxEntries, uint16 *usedEntries  )
   \                     bindCapacity:
    231          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    232            bindTableIndex_t x;
    233            bindTableIndex_t used;
    234          
    235            for ( used = 0, x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000005   7E00         MOV     R6,#0x0
   \   000007   7F00         MOV     R7,#0x0
   \   000009   8007         SJMP    ??bindCapacity_0
    236            {
    237              // It's empty if the index is "Not Found"
    238              if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \                     ??bindCapacity_1:
   \   00000B   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00000E   6001         JZ      ??bindCapacity_2
    239              {
    240                used++;
   \   000010   0E           INC     R6
    241              }
    242            }
   \                     ??bindCapacity_2:
   \   000011   0F           INC     R7
   \                     ??bindCapacity_0:
   \   000012   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000015   E4           CLR     A
   \   000016   93           MOVC    A,@A+DPTR
   \   000017   F8           MOV     R0,A
   \   000018   EF           MOV     A,R7
   \   000019   C3           CLR     C
   \   00001A   98           SUBB    A,R0
   \   00001B   40EE         JC      ??bindCapacity_1
    243          
    244            *maxEntries = gNWK_MAX_BINDING_ENTRIES;
   \   00001D   E4           CLR     A
   \   00001E   93           MOVC    A,@A+DPTR
   \   00001F   8A82         MOV     DPL,R2
   \   000021   8B83         MOV     DPH,R3
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   E4           CLR     A
   \   000026   F0           MOVX    @DPTR,A
    245            *usedEntries = used;
   \   000027   8C82         MOV     DPL,R4
   \   000029   8D83         MOV     DPH,R5
   \   00002B   EE           MOV     A,R6
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E4           CLR     A
   \   00002F   F0           MOVX    @DPTR,A
    246          }
   \   000030   02....       LJMP    ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   EF           MOV     A,R7
   \   000001   75F00E       MOV     B,#0xe
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   85F0..       MOV     ?V0,B
   \   000009   A9..         MOV     R1,?V0
   \   00000B                REQUIRE ??Subroutine30_0
   \   00000B                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    247          
    248          /*********************************************************************
    249           * @fn      bindAddEntry()
    250           *
    251           * @brief   This function is used to Add an entry to the binding table
    252           *
    253           * @param       srcEpInt - source endpoint
    254           * @param       dstAddr - destination Address
    255           * @param       dstEpInt - destination endpoint
    256           * @param       numClusterIds - number of cluster Ids in the list
    257           * @param       clusterIds - pointer to the Object ID list
    258           *
    259           * @return  pointer to binding table entry, NULL if not added
    260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    261          BindingEntry_t *bindAddEntry( byte srcEpInt,
   \                     bindAddEntry:
    262                                        zAddrType_t *dstAddr, byte dstEpInt,
    263                                        byte numClusterIds, uint16 *clusterIds )
    264          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V6,R2
   \   000009   8B..         MOV     ?V7,R3
   \   00000B   8C..         MOV     ?V8,R4
   \   00000D   8D..         MOV     ?V0,R5
    265            uint8            index;
    266            bindTableIndex_t bindIdx;
    267            BindingEntry_t*  entry;
    268            bindFields_t     fields;
    269          
    270            // initialize results
    271            entry = NULL;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
    272          
    273            // make sure local addresses have been loaded
    274            bindAddrMgrLocalLoad();
   \   000013                ; Setup parameters for call to function bindAddrMgrLocalLoad
   \   000013   12....       LCALL   `??bindAddrMgrLocalLoad::?relay`; Banked call to: bindAddrMgrLocalLoad
    275          
    276            // setup fields
    277            fields.dstIndex = bindAddrIndexGet( dstAddr );
   \   000016                ; Setup parameters for call to function bindAddrIndexGet
   \   000016   AA..         MOV     R2,?V6
   \   000018   AB..         MOV     R3,?V7
   \   00001A   12....       LCALL   `??bindAddrIndexGet::?relay`; Banked call to: bindAddrIndexGet
   \   00001D   8A..         MOV     ?V4,R2
   \   00001F   8B..         MOV     ?V5,R3
    278            fields.srcEP    = srcEpInt;
    279          
    280            if ( dstAddr->addrMode == AddrGroup )
   \   000021   85..82       MOV     DPL,?V6
   \   000024   85..83       MOV     DPH,?V7
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6401         XRL     A,#0x1
   \   000032   7008         JNZ     ??bindAddEntry_0
    281            {
    282              fields.dstAddrMode = DSTGROUPMODE_GROUP;
   \   000034   75..01       MOV     ?V3,#0x1
    283              fields.dstEP       = 0;
   \   000037   75..00       MOV     ?V1,#0x0
   \   00003A   8006         SJMP    ??bindAddEntry_1
    284            }
    285            else
    286            {
    287              fields.dstAddrMode = DSTGROUPMODE_ADDR;
   \                     ??bindAddEntry_0:
   \   00003C   75..00       MOV     ?V3,#0x0
    288              fields.dstEP       = dstEpInt;
   \   00003F   85....       MOV     ?V1,?V8
    289            }
    290          
    291            if ( fields.dstIndex != INVALID_NODE_ADDR  )
   \                     ??bindAddEntry_1:
   \   000042   74FE         MOV     A,#-0x2
   \   000044   65..         XRL     A,?V4
   \   000046   7004         JNZ     ??bindAddEntry_2
   \   000048   74FF         MOV     A,#-0x1
   \   00004A   65..         XRL     A,?V5
   \                     ??bindAddEntry_2:
   \   00004C   7003         JNZ     $+5
   \   00004E   02....       LJMP    ??bindAddEntry_3 & 0xFFFF
    292            {
    293              for ( bindIdx = 0; bindIdx < gNWK_MAX_BINDING_ENTRIES; bindIdx++ )
   \   000051   7A00         MOV     R2,#0x0
   \   000053   7414         MOV     A,#0x14
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5..         MOV     ?V6,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F5..         MOV     ?V7,A
   \   00005F   8001         SJMP    ??bindAddEntry_4
   \                     ??bindAddEntry_5:
   \   000061   0A           INC     R2
   \                     ??bindAddEntry_4:
   \   000062   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000065   E4           CLR     A
   \   000066   93           MOVC    A,@A+DPTR
   \   000067   F8           MOV     R0,A
   \   000068   EA           MOV     A,R2
   \   000069   C3           CLR     C
   \   00006A   98           SUBB    A,R0
   \   00006B   5070         JNC     ??bindAddEntry_6
    294              {
    295                if ( ( fields.srcEP       == BindingTable[bindIdx].srcEP        ) &&
    296                     ( fields.dstAddrMode == BindingTable[bindIdx].dstGroupMode ) &&
    297                     ( fields.dstIndex    == BindingTable[bindIdx].dstIdx       ) &&
    298                     ( fields.dstEP       == BindingTable[bindIdx].dstEP        )    )
   \   00006D   EA           MOV     A,R2
   \   00006E   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000071   65..         XRL     A,?V2
   \   000073   70EC         JNZ     ??bindAddEntry_5
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   65..         XRL     A,?V3
   \   000079   70E6         JNZ     ??bindAddEntry_5
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   E0           MOVX    A,@DPTR
   \   000082   65..         XRL     A,?V4
   \   000084   7004         JNZ     ??bindAddEntry_7
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   65..         XRL     A,?V5
   \                     ??bindAddEntry_7:
   \   00008A   70D5         JNZ     ??bindAddEntry_5
   \   00008C   8E82         MOV     DPL,R6
   \   00008E   8F83         MOV     DPH,R7
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   E0           MOVX    A,@DPTR
   \   000095   65..         XRL     A,?V1
   \   000097   70C8         JNZ     ??bindAddEntry_5
    299                {
    300                  entry = &BindingTable[bindIdx];
    301          
    302                  // break from loop
    303                  break;
    304                }
    305              }
    306          
    307              if ( entry != NULL )
    308              {
    309                // Loop through the cluster IDs
    310                for ( index = 0; index < numClusterIds; index++ )
   \   000099   75..00       MOV     ?V3,#0x0
   \                     ??bindAddEntry_8:
   \   00009C   E5..         MOV     A,?V3
   \   00009E   C3           CLR     C
   \   00009F   95..         SUBB    A,?V0
   \   0000A1   4003         JC      $+5
   \   0000A3   02....       LJMP    ??bindAddEntry_3 & 0xFFFF
    311                {
    312                  // Found - is the cluster already defined?
    313                  if ( bindIsClusterIDinList( entry, clusterIds[index] ) == FALSE )
   \   0000A6   A8..         MOV     R0,?V3
   \   0000A8   E8           MOV     A,R0
   \   0000A9   28           ADD     A,R0
   \   0000AA   F8           MOV     R0,A
   \   0000AB   E4           CLR     A
   \   0000AC   33           RLC     A
   \   0000AD   F9           MOV     R1,A
   \   0000AE   E5..         MOV     A,?V6
   \   0000B0   28           ADD     A,R0
   \   0000B1   F5..         MOV     ?V4,A
   \   0000B3   E5..         MOV     A,?V7
   \   0000B5   39           ADDC    A,R1
   \   0000B6   F5..         MOV     ?V5,A
   \   0000B8                ; Setup parameters for call to function bindIsClusterIDinList
   \   0000B8   85..82       MOV     DPL,?V4
   \   0000BB   F583         MOV     DPH,A
   \   0000BD   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0000C0   12....       LCALL   `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   0000C3   E9           MOV     A,R1
   \   0000C4   7013         JNZ     ??bindAddEntry_9
    314                  {
    315                    // Nope, add this cluster
    316                    if ( bindAddClusterIdToList( entry, clusterIds[index] ) == FALSE )
   \   0000C6                ; Setup parameters for call to function bindAddClusterIdToList
   \   0000C6   85..82       MOV     DPL,?V4
   \   0000C9   85..83       MOV     DPH,?V5
   \   0000CC   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0000CF   12....       LCALL   `??bindAddClusterIdToList::?relay`; Banked call to: bindAddClusterIdToList
   \   0000D2   E9           MOV     A,R1
   \   0000D3   7004         JNZ     ??bindAddEntry_9
    317                    {
    318                      // Indicate error if cluster list was full
    319                      entry = NULL;
   \   0000D5   7E00         MOV     R6,#0x0
   \   0000D7   7F00         MOV     R7,#0x0
    320                    }
    321                  }
    322                }
   \                     ??bindAddEntry_9:
   \   0000D9   05..         INC     ?V3
   \   0000DB   80BF         SJMP    ??bindAddEntry_8
    323              }
    324              else
    325              {
    326                // Find an empty slot
    327                entry = bindFindEmpty();
   \                     ??bindAddEntry_6:
   \   0000DD                ; Setup parameters for call to function bindFindEmpty
   \   0000DD   12....       LCALL   `??bindFindEmpty::?relay`; Banked call to: bindFindEmpty
   \   0000E0   8A..         MOV     ?V10,R2
   \   0000E2   8B..         MOV     ?V11,R3
   \   0000E4   AE..         MOV     R6,?V10
   \   0000E6   AF..         MOV     R7,?V11
    328          
    329                // Check against the maximum number allowed
    330                if ( entry != NULL )
   \   0000E8   EE           MOV     A,R6
   \   0000E9   4F           ORL     A,R7
   \   0000EA   6062         JZ      ??bindAddEntry_3
    331                {
    332                  // Add new entry
    333                  entry->srcEP         = fields.srcEP;
   \   0000EC   8E82         MOV     DPL,R6
   \   0000EE   8F83         MOV     DPH,R7
   \   0000F0   E5..         MOV     A,?V2
   \   0000F2   F0           MOVX    @DPTR,A
    334                  entry->dstGroupMode  = fields.dstAddrMode;
   \   0000F3   A3           INC     DPTR
   \   0000F4   E5..         MOV     A,?V3
   \   0000F6   F0           MOVX    @DPTR,A
    335                  entry->dstIdx        = fields.dstIndex;
   \   0000F7   8E82         MOV     DPL,R6
   \   0000F9   8F83         MOV     DPH,R7
   \   0000FB   A3           INC     DPTR
   \   0000FC   A3           INC     DPTR
   \   0000FD   E5..         MOV     A,?V4
   \   0000FF   F0           MOVX    @DPTR,A
   \   000100   A3           INC     DPTR
   \   000101   E5..         MOV     A,?V5
   \   000103   F0           MOVX    @DPTR,A
    336                  entry->dstEP         = fields.dstEP;
   \   000104   8E82         MOV     DPL,R6
   \   000106   8F83         MOV     DPH,R7
   \   000108   A3           INC     DPTR
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   A3           INC     DPTR
   \   00010C   E5..         MOV     A,?V1
   \   00010E   F0           MOVX    @DPTR,A
    337          
    338                  if ( numClusterIds > gMAX_BINDING_CLUSTER_IDS )
   \   00010F   90....       MOV     DPTR,#gMAX_BINDING_CLUSTER_IDS
   \   000112   E4           CLR     A
   \   000113   93           MOVC    A,@A+DPTR
   \   000114   C3           CLR     C
   \   000115   95..         SUBB    A,?V0
   \   000117   5004         JNC     ??bindAddEntry_10
    339                  {
    340                    numClusterIds = gMAX_BINDING_CLUSTER_IDS;
   \   000119   E4           CLR     A
   \   00011A   93           MOVC    A,@A+DPTR
   \   00011B   F5..         MOV     ?V0,A
    341                  }
    342          
    343                  entry->numClusterIds = numClusterIds;
   \                     ??bindAddEntry_10:
   \   00011D   8E82         MOV     DPL,R6
   \   00011F   8F83         MOV     DPH,R7
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   A3           INC     DPTR
   \   000124   A3           INC     DPTR
   \   000125   A3           INC     DPTR
   \   000126   E5..         MOV     A,?V0
   \   000128   F0           MOVX    @DPTR,A
    344          
    345                  osal_memcpy( entry->clusterIdList,
    346                               clusterIds,
    347                               numClusterIds * sizeof(uint16) );
   \   000129                ; Setup parameters for call to function osal_memcpy
   \   000129   85....       MOV     ?V4,?V6
   \   00012C   85....       MOV     ?V5,?V7
   \   00012F   75..00       MOV     ?V6,#0x0
   \   000132   78..         MOV     R0,#?V4
   \   000134   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000137   AC..         MOV     R4,?V0
   \   000139   EC           MOV     A,R4
   \   00013A   2C           ADD     A,R4
   \   00013B   FC           MOV     R4,A
   \   00013C   E4           CLR     A
   \   00013D   33           RLC     A
   \   00013E   FD           MOV     R5,A
   \   00013F   EE           MOV     A,R6
   \   000140   2406         ADD     A,#0x6
   \   000142   FA           MOV     R2,A
   \   000143   E4           CLR     A
   \   000144   3F           ADDC    A,R7
   \   000145   FB           MOV     R3,A
   \   000146   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000149   7403         MOV     A,#0x3
   \   00014B   12....       LCALL   ?DEALLOC_XSTACK8
    348                }
    349              }
    350            }
    351          
    352            return entry;
   \                     ??bindAddEntry_3:
   \   00014E   EE           MOV     A,R6
   \   00014F   FA           MOV     R2,A
   \   000150   EF           MOV     A,R7
   \   000151   FB           MOV     R3,A
   \   000152   7F0C         MOV     R7,#0xc
   \   000154   02....       LJMP    ?BANKED_LEAVE_XDATA
    353          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   EE           MOV     A,R6
   \   000006   FA           MOV     R2,A
   \   000007   EF           MOV     A,R7
   \   000008   FB           MOV     R3,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   75F00E       MOV     B,#0xe
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007   74..         MOV     A,#BindingTable & 0xff
   \   000009   28           ADD     A,R0
   \   00000A   FE           MOV     R6,A
   \   00000B   74..         MOV     A,#(BindingTable >> 8) & 0xff
   \   00000D   39           ADDC    A,R1
   \   00000E   FF           MOV     R7,A
   \   00000F   8E82         MOV     DPL,R6
   \   000011   8F83         MOV     DPH,R7
   \   000013   E0           MOVX    A,@DPTR
   \   000014   22           RET
    354          
    355          /*********************************************************************
    356           * @fn      bindRemoveEntry
    357           *
    358           * @brief   Removes a binding table entry.
    359           *
    360           * @param   pBind - pointer to binding table entry to delete
    361           *
    362           * @return  TRUE if Removed, FALSE if not
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          byte bindRemoveEntry( BindingEntry_t *pBind )
   \                     bindRemoveEntry:
    365          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    366            osal_memset( pBind, 0xFF, gBIND_REC_SIZE );
   \   000004                ; Setup parameters for call to function osal_memset
   \   000004   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000007   79FF         MOV     R1,#-0x1
   \   000009   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    367            return ( TRUE );
   \   00000C   7901         MOV     R1,#0x1
   \   00000E   02....       LJMP    ??Subroutine34_0 & 0xFFFF
    368          }
    369          
    370          /*********************************************************************
    371           * @fn      bindIsClusterIDinList()
    372           *
    373           * @brief   Is the clusterID in the clusterID list?
    374           *
    375           * @param   enter - binding table entry
    376           * @param   clusterId  - Cluster ID to look for
    377           *
    378           * @return  TRUE if found, FALSE if not found
    379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          byte bindIsClusterIDinList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindIsClusterIDinList:
    381          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    382            uint8 x;
    383          
    384            if ( entry != NULL )
   \   000005   EA           MOV     A,R2
   \   000006   4B           ORL     A,R3
   \   000007   6028         JZ      ??bindIsClusterIDinList_0
    385            {
    386              for ( x = 0; x < entry->numClusterIds; x++ )
   \   000009   7E00         MOV     R6,#0x0
   \   00000B   8001         SJMP    ??bindIsClusterIDinList_1
   \                     ??bindIsClusterIDinList_2:
   \   00000D   0E           INC     R6
   \                     ??bindIsClusterIDinList_1:
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   EE           MOV     A,R6
   \   00001A   C3           CLR     C
   \   00001B   98           SUBB    A,R0
   \   00001C   5013         JNC     ??bindIsClusterIDinList_0
    387              {
    388                if ( entry->clusterIdList[x] == clusterId )
   \   00001E   EE           MOV     A,R6
   \   00001F   25E0         ADD     A,0xE0 /* A   */
   \   000021   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6C           XRL     A,R4
   \   000026   7003         JNZ     ??bindIsClusterIDinList_3
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6D           XRL     A,R5
   \                     ??bindIsClusterIDinList_3:
   \   00002B   70E0         JNZ     ??bindIsClusterIDinList_2
    389                {
    390                  return ( TRUE );
   \   00002D   7901         MOV     R1,#0x1
   \   00002F   8002         SJMP    ??bindIsClusterIDinList_4
    391                }
    392              }
    393            }
    394          
    395            return ( FALSE );
   \                     ??bindIsClusterIDinList_0:
   \   000031   7900         MOV     R1,#0x0
   \                     ??bindIsClusterIDinList_4:
   \   000033   02....       LJMP    ?Subroutine2 & 0xFFFF
    396          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   33           RLC     A
   \   000003   F9           MOV     R1,A
   \   000004   EA           MOV     A,R2
   \   000005   28           ADD     A,R0
   \   000006   F582         MOV     DPL,A
   \   000008   EB           MOV     A,R3
   \   000009   39           ADDC    A,R1
   \   00000A   F583         MOV     DPH,A
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   22           RET
    397          
    398          /*********************************************************************
    399           * @fn      bindRemoveClusterIdFromList()
    400           *
    401           * @brief   Removes a ClusterID from a list of ClusterIDs.
    402           *
    403           * @param   enter - binding table entry
    404           * @param   clusterId  - Cluster ID to look for
    405           *
    406           * @return  TRUE if there are at least 1 clusterID left, FALSE if none
    407           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          byte bindRemoveClusterIdFromList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindRemoveClusterIdFromList:
    409          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
    410            byte x;
    411            uint16 *listPtr;
    412            byte numIds;
    413          
    414            if ( entry )
   \   000009   EA           MOV     A,R2
   \   00000A   4B           ORL     A,R3
   \   00000B   6065         JZ      ??bindRemoveClusterIdFromList_0
    415            {
    416              if ( entry->numClusterIds > 0 )
   \   00000D   EA           MOV     A,R2
   \   00000E   2405         ADD     A,#0x5
   \   000010   F8           MOV     R0,A
   \   000011   E4           CLR     A
   \   000012   3B           ADDC    A,R3
   \   000013   F9           MOV     R1,A
   \   000014   88..         MOV     ?V0,R0
   \   000016   89..         MOV     ?V1,R1
   \   000018   8882         MOV     DPL,R0
   \   00001A   F583         MOV     DPH,A
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   6052         JZ      ??bindRemoveClusterIdFromList_0
    417              {
    418                listPtr = entry->clusterIdList;
   \   000020   EA           MOV     A,R2
   \   000021   2406         ADD     A,#0x6
   \   000023   FC           MOV     R4,A
   \   000024   E4           CLR     A
   \   000025   3B           ADDC    A,R3
   \   000026   FD           MOV     R5,A
    419                numIds = entry->numClusterIds;
   \   000027   88..         MOV     ?V3,R0
    420          
    421                // Copy the new list over
    422                for ( x = 0; x < numIds; x++ )
   \   000029   75..00       MOV     ?V2,#0x0
   \   00002C   800D         SJMP    ??bindRemoveClusterIdFromList_1
    423                {
    424                  if ( entry->clusterIdList[x] != clusterId )
    425                  {
    426                    *listPtr++ = entry->clusterIdList[x];
    427                  }
    428                  else
    429                  {
    430                    entry->numClusterIds--;
   \                     ??bindRemoveClusterIdFromList_2:
   \   00002E   85..82       MOV     DPL,?V0
   \   000031   85..83       MOV     DPH,?V1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   14           DEC     A
   \   000036   F0           MOVX    @DPTR,A
    431                    if ( entry->numClusterIds == 0 )
   \   000037   6039         JZ      ??bindRemoveClusterIdFromList_0
    432                    {
    433                      break;
    434                    }
    435                  }
   \                     ??bindRemoveClusterIdFromList_3:
   \   000039   05..         INC     ?V2
   \                     ??bindRemoveClusterIdFromList_1:
   \   00003B   E5..         MOV     A,?V2
   \   00003D   C3           CLR     C
   \   00003E   95..         SUBB    A,?V3
   \   000040   5023         JNC     ??bindRemoveClusterIdFromList_4
   \   000042   A8..         MOV     R0,?V2
   \   000044   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000047   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00004A   EE           MOV     A,R6
   \   00004B   68           XRL     A,R0
   \   00004C   7002         JNZ     ??bindRemoveClusterIdFromList_5
   \   00004E   EF           MOV     A,R7
   \   00004F   69           XRL     A,R1
   \                     ??bindRemoveClusterIdFromList_5:
   \   000050   60DC         JZ      ??bindRemoveClusterIdFromList_2
   \   000052   8C82         MOV     DPL,R4
   \   000054   8D83         MOV     DPH,R5
   \   000056   E8           MOV     A,R0
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   E9           MOV     A,R1
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   EC           MOV     A,R4
   \   00005C   2402         ADD     A,#0x2
   \   00005E   E4           CLR     A
   \   00005F   3D           ADDC    A,R5
   \   000060   0C           INC     R4
   \   000061   0C           INC     R4
   \   000062   FD           MOV     R5,A
   \   000063   80D4         SJMP    ??bindRemoveClusterIdFromList_3
    436                }
    437              }
    438            }
   \                     ??bindRemoveClusterIdFromList_4:
   \   000065   85..82       MOV     DPL,?V0
   \   000068   85..83       MOV     DPH,?V1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6004         JZ      ??bindRemoveClusterIdFromList_0
    439          
    440            if ( entry && (entry->numClusterIds > 0) )
    441            {
    442              return ( TRUE );
   \   00006E   7901         MOV     R1,#0x1
   \   000070   8002         SJMP    ??bindRemoveClusterIdFromList_6
    443            }
    444            else
    445            {
    446              return ( FALSE );
   \                     ??bindRemoveClusterIdFromList_0:
   \   000072   7900         MOV     R1,#0x0
    447            }
   \                     ??bindRemoveClusterIdFromList_6:
   \   000074                REQUIRE ?Subroutine3
   \   000074                ; // Fall through to label ?Subroutine3
    448          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F05         MOV     R7,#0x5
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E8           MOV     A,R0
   \   000001   28           ADD     A,R0
   \   000002   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    449          
    450          /*********************************************************************
    451           * @fn      bindAddClusterIdToList()
    452           *
    453           * @brief   Adds a ClusterID to a list of ClusterIDs.
    454           *
    455           * @param   enter - binding table entry
    456           * @param   clusterId  - Cluster ID to Add
    457           *
    458           * @return  TRUE if Added, FALSE if not
    459           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    460          byte bindAddClusterIdToList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindAddClusterIdToList:
    461          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    462            if ( entry && entry->numClusterIds < gMAX_BINDING_CLUSTER_IDS )
   \   000005   EA           MOV     A,R2
   \   000006   4B           ORL     A,R3
   \   000007   6025         JZ      ??bindAddClusterIdToList_0
   \   000009   EA           MOV     A,R2
   \   00000A   2405         ADD     A,#0x5
   \   00000C   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00000F   F8           MOV     R0,A
   \   000010   90....       MOV     DPTR,#gMAX_BINDING_CLUSTER_IDS
   \   000013   E4           CLR     A
   \   000014   93           MOVC    A,@A+DPTR
   \   000015   F9           MOV     R1,A
   \   000016   E8           MOV     A,R0
   \   000017   C3           CLR     C
   \   000018   99           SUBB    A,R1
   \   000019   5013         JNC     ??bindAddClusterIdToList_0
    463            {
    464              // Add the new one
    465              entry->clusterIdList[entry->numClusterIds] = clusterId;
   \   00001B   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00001E   EC           MOV     A,R4
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   ED           MOV     A,R5
   \   000022   F0           MOVX    @DPTR,A
    466              entry->numClusterIds++;
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   04           INC     A
   \   000029   F0           MOVX    @DPTR,A
    467              return ( TRUE );
   \   00002A   7901         MOV     R1,#0x1
   \   00002C   8002         SJMP    ??bindAddClusterIdToList_1
    468            }
    469            return ( FALSE );
   \                     ??bindAddClusterIdToList_0:
   \   00002E   7900         MOV     R1,#0x0
   \                     ??bindAddClusterIdToList_1:
   \   000030                REQUIRE ?Subroutine2
   \   000030                ; // Fall through to label ?Subroutine2
    470          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   3B           ADDC    A,R3
   \   000003   F9           MOV     R1,A
   \   000004   E8           MOV     A,R0
   \   000005   FE           MOV     R6,A
   \   000006   E9           MOV     A,R1
   \   000007   FF           MOV     R7,A
   \   000008   8E82         MOV     DPL,R6
   \   00000A   8F83         MOV     DPH,R7
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET
    471          
    472          /*********************************************************************
    473           * @fn      bindFindExisting
    474           *
    475           * @brief   Finds an existing src/epint to dst/epint bind record
    476           *
    477           * @param   srcEpInt - Source Endpoint/Interface
    478           * @param   dstAddr - Destination address
    479           * @param   dstEpInt - Destination Endpoint/Interface
    480           *
    481           * @return  pointer to existing entry or NULL
    482           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    483          BindingEntry_t *bindFindExisting( byte srcEpInt,
   \                     bindFindExisting:
    484                                            zAddrType_t *dstAddr, byte dstEpInt )
    485          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8C..         MOV     ?V1,R4
    486            uint16 dstIdx;
    487            bindTableIndex_t x;
    488          
    489            // Find the records in the assoc list
    490            if ( dstAddr->addrMode == AddrGroup )
   \   000009   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00000C   700B         JNZ     ??bindFindExisting_0
    491            {
    492              dstIdx = dstAddr->addr.shortAddr;
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FC           MOV     R4,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FD           MOV     R5,A
   \   000017   800B         SJMP    ??bindFindExisting_1
    493            }
    494            else
    495            {
    496              dstIdx = bindingAddrMgsHelperFind( dstAddr );
   \                     ??bindFindExisting_0:
   \   000019                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000019   12....       LCALL   `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   00001C   8A..         MOV     ?V2,R2
   \   00001E   8B..         MOV     ?V3,R3
   \   000020   AC..         MOV     R4,?V2
   \   000022   AD..         MOV     R5,?V3
    497            }
    498          
    499            if ( dstIdx == INVALID_NODE_ADDR )
   \                     ??bindFindExisting_1:
   \   000024   74FE         MOV     A,#-0x2
   \   000026   6C           XRL     A,R4
   \   000027   7003         JNZ     ??bindFindExisting_2
   \   000029   74FF         MOV     A,#-0x1
   \   00002B   6D           XRL     A,R5
   \                     ??bindFindExisting_2:
   \   00002C   605B         JZ      ??bindFindExisting_3
    500            {
    501              return ( (BindingEntry_t *)NULL );
    502            }
    503          
    504            // Start at the beginning
    505            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00002E   75..00       MOV     ?V2,#0x0
   \   000031   8015         SJMP    ??bindFindExisting_4
    506            {
    507              if ( (BindingTable[x].srcEP == srcEpInt) )
   \                     ??bindFindExisting_5:
   \   000033   7401         MOV     A,#0x1
   \   000035   65..         XRL     A,?V3
   \   000037   700D         JNZ     ??bindFindExisting_6
   \   000039   8882         MOV     DPL,R0
   \   00003B   8983         MOV     DPH,R1
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   6C           XRL     A,R4
   \   00003F   7003         JNZ     ??bindFindExisting_7
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   6D           XRL     A,R5
   \                     ??bindFindExisting_7:
   \   000044   6047         JZ      ??bindFindExisting_8
   \                     ??bindFindExisting_6:
   \   000046   05..         INC     ?V2
   \                     ??bindFindExisting_4:
   \   000048   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   00004B   503C         JNC     ??bindFindExisting_3
   \   00004D   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000050   E0           MOVX    A,@DPTR
   \   000051   65..         XRL     A,?V0
   \   000053   70F1         JNZ     ??bindFindExisting_6
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F5..         MOV     ?V3,A
   \   000059   EA           MOV     A,R2
   \   00005A   2402         ADD     A,#0x2
   \   00005C   F8           MOV     R0,A
   \   00005D   E4           CLR     A
   \   00005E   3B           ADDC    A,R3
   \   00005F   F9           MOV     R1,A
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   E0           MOVX    A,@DPTR
   \   000065   6401         XRL     A,#0x1
   \   000067   60CA         JZ      ??bindFindExisting_5
   \   000069   E5..         MOV     A,?V3
   \   00006B   70D9         JNZ     ??bindFindExisting_6
   \   00006D   8882         MOV     DPL,R0
   \   00006F   8983         MOV     DPH,R1
   \   000071   E0           MOVX    A,@DPTR
   \   000072   6C           XRL     A,R4
   \   000073   7003         JNZ     ??bindFindExisting_9
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   6D           XRL     A,R5
   \                     ??bindFindExisting_9:
   \   000078   70CC         JNZ     ??bindFindExisting_6
   \   00007A   8A82         MOV     DPL,R2
   \   00007C   8B83         MOV     DPH,R3
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   65..         XRL     A,?V1
   \   000085   70BF         JNZ     ??bindFindExisting_6
    508              {
    509                if ( ((dstAddr->addrMode == AddrGroup)
    510                        && (BindingTable[x].dstGroupMode == DSTGROUPMODE_GROUP)
    511                        && (dstIdx == BindingTable[x].dstIdx))
    512                   || ((dstAddr->addrMode != AddrGroup)
    513                       && (BindingTable[x].dstGroupMode == DSTGROUPMODE_ADDR)
    514                       && (dstIdx == BindingTable[x].dstIdx) && (BindingTable[x].dstEP == dstEpInt)) )
    515                {
    516                  return ( &BindingTable[x] );
   \   000087   8004         SJMP    ??bindFindExisting_8
    517                }
    518              }
    519            }
    520          
    521            return ( (BindingEntry_t *)NULL );
   \                     ??bindFindExisting_3:
   \   000089   7A00         MOV     R2,#0x0
   \   00008B   7B00         MOV     R3,#0x0
   \                     ??bindFindExisting_8:
   \   00008D   02....       LJMP    ?Subroutine3 & 0xFFFF
    522          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000003   E4           CLR     A
   \   000004   93           MOVC    A,@A+DPTR
   \   000005   F8           MOV     R0,A
   \   000006   E5..         MOV     A,?V2
   \   000008   C3           CLR     C
   \   000009   98           SUBB    A,R0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F00E       MOV     B,#0xe
   \   000005   A4           MUL     AB
   \   000006   F8           MOV     R0,A
   \   000007   A9F0         MOV     R1,B
   \   000009   74..         MOV     A,#BindingTable & 0xff
   \   00000B   28           ADD     A,R0
   \   00000C   FA           MOV     R2,A
   \   00000D   74..         MOV     A,#(BindingTable >> 8) & 0xff
   \   00000F   39           ADDC    A,R1
   \   000010   FB           MOV     R3,A
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   EA           MOV     A,R2
   \   000001   2408         ADD     A,#0x8
   \   000003   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000006   6401         XRL     A,#0x1
   \   000008   22           RET
    523          
    524          /*********************************************************************
    525           * @fn       bindRemoveDev()
    526           *
    527           * @brief
    528           *
    529           *   Remove all bind(s) entries associated to a device address (destination).
    530           *   Updates binding table.
    531           *
    532           * @param   Addr - address of device to be removed from Binding Table
    533           *
    534           * @return  none
    535           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    536          void bindRemoveDev( zAddrType_t *Addr )
   \                     bindRemoveDev:
    537          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    538            uint16 idx;
    539            bindTableIndex_t x;
    540          
    541            if ( Addr->addrMode == AddrGroup )
   \   000005   EA           MOV     A,R2
   \   000006   2408         ADD     A,#0x8
   \   000008   F5..         MOV     ?V0,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V1,A
   \   00000E   85..82       MOV     DPL,?V0
   \   000011   F583         MOV     DPH,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   6401         XRL     A,#0x1
   \   000016   700B         JNZ     ??bindRemoveDev_0
    542            {
    543              idx = Addr->addr.shortAddr;
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FE           MOV     R6,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FF           MOV     R7,A
   \   000021   800B         SJMP    ??bindRemoveDev_1
    544            }
    545            else
    546            {
    547              idx = bindingAddrMgsHelperFind( Addr );
   \                     ??bindRemoveDev_0:
   \   000023                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000023   12....       LCALL   `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
    548            }
    549          
    550            if ( idx == INVALID_NODE_ADDR )
   \                     ??bindRemoveDev_1:
   \   00002E   74FE         MOV     A,#-0x2
   \   000030   6E           XRL     A,R6
   \   000031   7003         JNZ     ??bindRemoveDev_2
   \   000033   74FF         MOV     A,#-0x1
   \   000035   6F           XRL     A,R7
   \                     ??bindRemoveDev_2:
   \   000036   6052         JZ      ??bindRemoveDev_3
    551            {
    552              return;
    553            }
    554          
    555            // Removes all the entries that match the destination Address/Index
    556            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000038   75..00       MOV     ?V2,#0x0
   \   00003B   8015         SJMP    ??bindRemoveDev_4
    557            {
    558              if ( ( (Addr->addrMode == AddrGroup) && (BindingTable[x].dstGroupMode == DSTGROUPMODE_GROUP)
    559                                                   && (BindingTable[x].dstIdx == idx) ) ||
    560                   ( (Addr->addrMode != AddrGroup) && (BindingTable[x].dstGroupMode == DSTGROUPMODE_ADDR)
    561                                                   && (BindingTable[x].dstIdx == idx) ) )
   \                     ??bindRemoveDev_5:
   \   00003D   EC           MOV     A,R4
   \   00003E   7010         JNZ     ??bindRemoveDev_6
   \   000040   8882         MOV     DPL,R0
   \   000042   8983         MOV     DPH,R1
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6E           XRL     A,R6
   \   000046   7003         JNZ     ??bindRemoveDev_7
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6F           XRL     A,R7
   \                     ??bindRemoveDev_7:
   \   00004B   7003         JNZ     ??bindRemoveDev_6
    562              {
    563                bindRemoveEntry( &BindingTable[x] );
   \                     ??bindRemoveDev_8:
   \   00004D                ; Setup parameters for call to function bindRemoveEntry
   \   00004D   12....       LCALL   `??bindRemoveEntry::?relay`; Banked call to: bindRemoveEntry
    564              }
   \                     ??bindRemoveDev_6:
   \   000050   05..         INC     ?V2
   \                     ??bindRemoveDev_4:
   \   000052   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000055   502C         JNC     ??bindRemoveDev_9
   \   000057   12....       LCALL   ?Subroutine11 & 0xFFFF
    565            }
   \                     ??CrossCallReturnLabel_9:
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   FC           MOV     R4,A
   \   00005D   EA           MOV     A,R2
   \   00005E   2402         ADD     A,#0x2
   \   000060   F8           MOV     R0,A
   \   000061   E4           CLR     A
   \   000062   3B           ADDC    A,R3
   \   000063   F9           MOV     R1,A
   \   000064   85..82       MOV     DPL,?V0
   \   000067   85..83       MOV     DPH,?V1
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   6401         XRL     A,#0x1
   \   00006D   70CE         JNZ     ??bindRemoveDev_5
   \   00006F   7401         MOV     A,#0x1
   \   000071   6C           XRL     A,R4
   \   000072   70DC         JNZ     ??bindRemoveDev_6
   \   000074   8882         MOV     DPL,R0
   \   000076   8983         MOV     DPH,R1
   \   000078   E0           MOVX    A,@DPTR
   \   000079   6E           XRL     A,R6
   \   00007A   7003         JNZ     ??bindRemoveDev_10
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   6F           XRL     A,R7
   \                     ??bindRemoveDev_10:
   \   00007F   60CC         JZ      ??bindRemoveDev_8
   \   000081   80CD         SJMP    ??bindRemoveDev_6
    566          
    567            // If this is the last Bind Entry for that idx then clear BINDING
    568            // user from Address Manager
    569            bindAddressClear( idx );
   \                     ??bindRemoveDev_9:
   \   000083                ; Setup parameters for call to function bindAddressClear
   \   000083   EE           MOV     A,R6
   \   000084   FA           MOV     R2,A
   \   000085   EF           MOV     A,R7
   \   000086   FB           MOV     R3,A
   \   000087   12....       LCALL   `??bindAddressClear::?relay`; Banked call to: bindAddressClear
    570          }
   \                     ??bindRemoveDev_3:
   \   00008A                REQUIRE ?Subroutine4
   \   00008A                ; // Fall through to label ?Subroutine4

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    571          
    572          /*********************************************************************
    573           * @fn       bindRemoveSrcDev()
    574           *
    575           * @brief
    576           *
    577           *   Remove binds(s) associated to device address (source).
    578           *   Updates binding table.
    579           *
    580           * @param   ep - endpoint to remove, 0xFF is all endpoints
    581           *
    582           * @return  none
    583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    584          void bindRemoveSrcDev( uint8 ep )
   \                     bindRemoveSrcDev:
    585          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
    586            bindTableIndex_t x;
    587          
    588            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000007   75..00       MOV     ?V0,#0x0
   \   00000A   8037         SJMP    ??bindRemoveSrcDev_0
    589            {
    590              if ( (ep == 0xFF) || (ep == BindingTable[x].srcEP) )
   \                     ??bindRemoveSrcDev_1:
   \   00000C   E5..         MOV     A,?V0
   \   00000E   75F00E       MOV     B,#0xe
   \   000011   A4           MUL     AB
   \   000012   F8           MOV     R0,A
   \   000013   A9F0         MOV     R1,B
   \   000015   74..         MOV     A,#BindingTable & 0xff
   \   000017   28           ADD     A,R0
   \   000018   FA           MOV     R2,A
   \   000019   74..         MOV     A,#(BindingTable >> 8) & 0xff
   \   00001B   39           ADDC    A,R1
   \   00001C   FB           MOV     R3,A
   \   00001D   74FF         MOV     A,#-0x1
   \   00001F   65..         XRL     A,?V1
   \   000021   6009         JZ      ??bindRemoveSrcDev_2
   \   000023   8A82         MOV     DPL,R2
   \   000025   8B83         MOV     DPH,R3
   \   000027   E0           MOVX    A,@DPTR
   \   000028   65..         XRL     A,?V1
   \   00002A   7015         JNZ     ??bindRemoveSrcDev_3
    591              {
    592                uint16 idx = BindingTable[x].dstIdx;
   \                     ??bindRemoveSrcDev_2:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FE           MOV     R6,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FF           MOV     R7,A
    593          
    594                bindRemoveEntry( &BindingTable[x] );
   \   000037                ; Setup parameters for call to function bindRemoveEntry
   \   000037   12....       LCALL   `??bindRemoveEntry::?relay`; Banked call to: bindRemoveEntry
    595          
    596                // If this is the last Bind Entry for that idx then clear BINDING
    597                // user from Address Manager
    598                bindAddressClear( idx );
   \   00003A                ; Setup parameters for call to function bindAddressClear
   \   00003A   EE           MOV     A,R6
   \   00003B   FA           MOV     R2,A
   \   00003C   EF           MOV     A,R7
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   `??bindAddressClear::?relay`; Banked call to: bindAddressClear
    599              }
    600            }
   \                     ??bindRemoveSrcDev_3:
   \   000041   05..         INC     ?V0
   \                     ??bindRemoveSrcDev_0:
   \   000043   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000046   E4           CLR     A
   \   000047   93           MOVC    A,@A+DPTR
   \   000048   F8           MOV     R0,A
   \   000049   E5..         MOV     A,?V0
   \   00004B   C3           CLR     C
   \   00004C   98           SUBB    A,R0
   \   00004D   40BD         JC      ??bindRemoveSrcDev_1
    601          }
   \   00004F   02....       LJMP    ??Subroutine29_0 & 0xFFFF
    602          
    603          /*********************************************************************
    604           * @fn          bindNumBoundTo
    605           *
    606           * @brief       Calculate the number items this device is bound to.
    607           *              When srcMode is set to TRUE, discard what value devAddr
    608           *              has, it returns number count bound to the local dev.
    609           *
    610           * @param       devAddr - device Address
    611           * @param       devEP - endpoint
    612           * @param       srcMode - TRUE - assume devHandle is a source address
    613           *                        FALSE - destination address
    614           *
    615           * @return      status
    616           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    617          byte bindNumBoundTo( zAddrType_t *devAddr, byte devEpInt, byte srcMode )
   \                     bindNumBoundTo:
    618          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8C..         MOV     ?V2,R4
    619            BindingEntry_t *pBind;
    620            uint16 idx;
    621            byte   num;
    622            bindTableIndex_t x;
    623          
    624            // Init
    625            num = 0;
   \   000009   75..00       MOV     ?V0,#0x0
    626          
    627            if ( devAddr->addrMode == AddrGroup )
   \   00000C   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00000F   7009         JNZ     ??bindNumBoundTo_0
    628            {
    629              idx = devAddr->addr.shortAddr;
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ??Subroutine39_0 & 0xFFFF
    630            }
   \                     ??CrossCallReturnLabel_56:
   \   000018   8003         SJMP    ??bindNumBoundTo_1
    631            else
    632            {
    633              idx = bindingAddrMgsHelperFind( devAddr );
   \                     ??bindNumBoundTo_0:
   \   00001A                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   00001A   12....       LCALL   `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
    634            }
    635          
    636            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \                     ??bindNumBoundTo_1:
   \   00001D   7C00         MOV     R4,#0x0
   \   00001F   8022         SJMP    ??bindNumBoundTo_2
    637            {
    638              pBind = &BindingTable[x];
    639              if ( srcMode )
    640              {
    641                if ( pBind->srcEP == devEpInt )
    642                {
    643                  num++;
    644                }
    645              }
    646              else
    647              {
    648                if ( ((devAddr->addrMode == AddrGroup)
    649                        && (pBind->dstGroupMode == DSTGROUPMODE_GROUP) && (pBind->dstIdx == idx))
    650                    || ((devAddr->addrMode != AddrGroup) && (pBind->dstGroupMode == DSTGROUPMODE_ADDR)
    651                                          && (pBind->dstIdx == idx) && (pBind->dstEP == devEpInt)) )
   \                     ??bindNumBoundTo_3:
   \   000021   ED           MOV     A,R5
   \   000022   701E         JNZ     ??bindNumBoundTo_4
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   6A           XRL     A,R2
   \   00002C   7003         JNZ     ??bindNumBoundTo_5
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6B           XRL     A,R3
   \                     ??bindNumBoundTo_5:
   \   000031   700F         JNZ     ??bindNumBoundTo_4
   \   000033   8882         MOV     DPL,R0
   \   000035   8983         MOV     DPH,R1
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   65..         XRL     A,?V1
   \   00003E   7002         JNZ     ??bindNumBoundTo_4
    652                {
    653                  num++;
   \                     ??bindNumBoundTo_6:
   \   000040   05..         INC     ?V0
    654                }
   \                     ??bindNumBoundTo_4:
   \   000042   0C           INC     R4
   \                     ??bindNumBoundTo_2:
   \   000043   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000046   E4           CLR     A
   \   000047   93           MOVC    A,@A+DPTR
   \   000048   F8           MOV     R0,A
   \   000049   EC           MOV     A,R4
   \   00004A   C3           CLR     C
   \   00004B   98           SUBB    A,R0
   \   00004C   5034         JNC     ??bindNumBoundTo_7
   \   00004E   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000051   E5..         MOV     A,?V2
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   6007         JZ      ??bindNumBoundTo_8
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   65..         XRL     A,?V1
   \   00005C   70E4         JNZ     ??bindNumBoundTo_4
   \   00005E   80E0         SJMP    ??bindNumBoundTo_6
   \                     ??bindNumBoundTo_8:
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FD           MOV     R5,A
   \   000063   8E82         MOV     DPL,R6
   \   000065   8F83         MOV     DPH,R7
   \   000067   E0           MOVX    A,@DPTR
   \   000068   6401         XRL     A,#0x1
   \   00006A   70B5         JNZ     ??bindNumBoundTo_3
   \   00006C   7401         MOV     A,#0x1
   \   00006E   6D           XRL     A,R5
   \   00006F   70D1         JNZ     ??bindNumBoundTo_4
   \   000071   8882         MOV     DPL,R0
   \   000073   8983         MOV     DPH,R1
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   6A           XRL     A,R2
   \   000079   7003         JNZ     ??bindNumBoundTo_9
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   6B           XRL     A,R3
   \                     ??bindNumBoundTo_9:
   \   00007E   60C0         JZ      ??bindNumBoundTo_6
   \   000080   80C0         SJMP    ??bindNumBoundTo_4
    655              }
    656            }
    657          
    658            return num;
   \                     ??bindNumBoundTo_7:
   \   000082   A9..         MOV     R1,?V0
   \   000084   02....       LJMP    ??Subroutine38_0 & 0xFFFF
    659          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   EC           MOV     A,R4
   \   000001                REQUIRE ??Subroutine31_0
   \   000001                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   75F00E       MOV     B,#0xe
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007   74..         MOV     A,#BindingTable & 0xff
   \   000009   28           ADD     A,R0
   \   00000A   F8           MOV     R0,A
   \   00000B   74..         MOV     A,#(BindingTable >> 8) & 0xff
   \   00000D   39           ADDC    A,R1
   \   00000E   F9           MOV     R1,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    660          
    661          /*********************************************************************
    662           * @fn          bindNumReflections
    663           *
    664           * @brief       Counts the number of reflections needed for a
    665           *              endpoint and cluster ID combo.
    666           *
    667           * @param       ep - source endpoint
    668           * @param       clusterID - matching clusterID
    669           *
    670           * @return      number of reflections needed.
    671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    672          uint16 bindNumReflections( uint8 ep, uint16 clusterID )
   \                     bindNumReflections:
    673          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V0,R2
   \   000009   8B..         MOV     ?V1,R3
    674            bindTableIndex_t x;
    675            BindingEntry_t *pBind;
    676            uint16 cnt = 0;
   \   00000B   7E00         MOV     R6,#0x0
   \   00000D   7F00         MOV     R7,#0x0
    677            uint8 bindEP;
    678          
    679            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00000F   75..00       MOV     ?V2,#0x0
   \   000012   8025         SJMP    ??bindNumReflections_0
    680            {
    681              pBind = &BindingTable[x];
   \                     ??bindNumReflections_1:
   \   000014   E5..         MOV     A,?V2
   \   000016   75F00E       MOV     B,#0xe
   \   000019   A4           MUL     AB
   \   00001A   F8           MOV     R0,A
   \   00001B   A9F0         MOV     R1,B
   \   00001D   12....       LCALL   ?Subroutine27 & 0xFFFF
    682              bindEP = pBind->srcEP;
    683          
    684              if ( (bindEP == ep) && (bindIsClusterIDinList( pBind, clusterID )) )
   \                     ??CrossCallReturnLabel_45:
   \   000020   65..         XRL     A,?V3
   \   000022   7013         JNZ     ??bindNumReflections_2
   \   000024                ; Setup parameters for call to function bindIsClusterIDinList
   \   000024   AC..         MOV     R4,?V0
   \   000026   AD..         MOV     R5,?V1
   \   000028   AA82         MOV     R2,DPL
   \   00002A   AB83         MOV     R3,DPH
   \   00002C   12....       LCALL   `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   00002F   E9           MOV     A,R1
   \   000030   6005         JZ      ??bindNumReflections_2
    685              {
    686                cnt++;
   \   000032   0E           INC     R6
   \   000033   EE           MOV     A,R6
   \   000034   7001         JNZ     ??bindNumReflections_2
   \   000036   0F           INC     R7
    687              }
    688            }
   \                     ??bindNumReflections_2:
   \   000037   05..         INC     ?V2
   \                     ??bindNumReflections_0:
   \   000039   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00003C   40D6         JC      ??bindNumReflections_1
    689          
    690            return ( cnt );
   \   00003E   EE           MOV     A,R6
   \   00003F   FA           MOV     R2,A
   \   000040   EF           MOV     A,R7
   \   000041   FB           MOV     R3,A
   \   000042   02....       LJMP    ?Subroutine4 & 0xFFFF
    691          }
    692          
    693          /*********************************************************************
    694           * @fn          bindFind
    695           *
    696           * @brief       Finds the binding entry for the source address, endpoint
    697           *              and cluster ID passed in as a parameter.
    698           *
    699           * @param       ep - source endpoint
    700           * @param       clusterID - matching clusterID
    701           * @param       skip - number of matches to skip before returning
    702           *
    703           * @return      pointer to the binding table entry, NULL if not found
    704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    705          BindingEntry_t *bindFind( uint8 ep, uint16 clusterID, uint8 skipping )
   \                     bindFind:
    706          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V0,R2
   \   000009   8B..         MOV     ?V1,R3
   \   00000B   8C..         MOV     ?V4,R4
    707            BindingEntry_t *pBind;
    708            byte skipped = 0;
   \   00000D   75..00       MOV     ?V2,#0x0
    709            bindTableIndex_t x;
    710          
    711            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000010   75..00       MOV     ?V5,#0x0
   \   000013   8004         SJMP    ??bindFind_0
    712            {
    713              pBind = &BindingTable[x];
    714          
    715              if ( ( pBind->srcEP == ep) && bindIsClusterIDinList( pBind, clusterID ))
    716              {
    717                if ( skipped < skipping )
    718                {
    719                  skipped++;
   \                     ??bindFind_1:
   \   000015   05..         INC     ?V2
    720                }
   \                     ??bindFind_2:
   \   000017   05..         INC     ?V5
   \                     ??bindFind_0:
   \   000019   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00001C   E4           CLR     A
   \   00001D   93           MOVC    A,@A+DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   E5..         MOV     A,?V5
   \   000021   C3           CLR     C
   \   000022   98           SUBB    A,R0
   \   000023   5024         JNC     ??bindFind_3
   \   000025   E5..         MOV     A,?V5
   \   000027   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   00002A   65..         XRL     A,?V3
   \   00002C   70E9         JNZ     ??bindFind_2
   \   00002E                ; Setup parameters for call to function bindIsClusterIDinList
   \   00002E   AC..         MOV     R4,?V0
   \   000030   AD..         MOV     R5,?V1
   \   000032   EE           MOV     A,R6
   \   000033   FA           MOV     R2,A
   \   000034   EF           MOV     A,R7
   \   000035   FB           MOV     R3,A
   \   000036   12....       LCALL   `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   000039   E9           MOV     A,R1
   \   00003A   60DB         JZ      ??bindFind_2
   \   00003C   E5..         MOV     A,?V2
   \   00003E   C3           CLR     C
   \   00003F   95..         SUBB    A,?V4
   \   000041   40D2         JC      ??bindFind_1
    721                else
    722                {
    723                  return ( pBind );
   \   000043   EE           MOV     A,R6
   \   000044   FA           MOV     R2,A
   \   000045   EF           MOV     A,R7
   \   000046   FB           MOV     R3,A
   \   000047   8004         SJMP    ??bindFind_4
    724                }
    725              }
    726            }
    727          
    728            return ( (BindingEntry_t *)NULL );
   \                     ??bindFind_3:
   \   000049   7A00         MOV     R2,#0x0
   \   00004B   7B00         MOV     R3,#0x0
   \                     ??bindFind_4:
   \   00004D   02....       LJMP    ??Subroutine38_0 & 0xFFFF
    729          }
    730          
    731          /*********************************************************************
    732           * @fn      bindAddressClear
    733           *
    734           * @brief   Lookup a binding entry by specific Idx, if none is found
    735           *          clears the BINDING user from Address Manager.
    736           *
    737           * @param   dstIdx - Source Address Manager Index
    738           *
    739           * @return  none
    740           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    741          void bindAddressClear( uint16 dstIdx )
   \                     bindAddressClear:
    742          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV     A,#-0xd
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    743            bindTableIndex_t i;
    744          
    745            if ( dstIdx != INVALID_NODE_ADDR )
   \   000009   74FE         MOV     A,#-0x2
   \   00000B   6A           XRL     A,R2
   \   00000C   7003         JNZ     ??bindAddressClear_0
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   6B           XRL     A,R3
   \                     ??bindAddressClear_0:
   \   000011   604A         JZ      ??bindAddressClear_1
    746            {
    747              // Looks for a specific Idx
    748              for ( i = 0; i < gNWK_MAX_BINDING_ENTRIES; i++ )
   \   000013   7C00         MOV     R4,#0x0
   \   000015   8022         SJMP    ??bindAddressClear_2
    749              {
    750                if ( ( BindingTable[i].dstGroupMode != AddrGroup ) &&
    751                     ( BindingTable[i].dstGroupMode == DSTGROUPMODE_ADDR ) &&
    752                     ( BindingTable[i].dstIdx == dstIdx ) )
   \                     ??bindAddressClear_3:
   \   000017   12....       LCALL   ?Subroutine14 & 0xFFFF
    753                {
    754                  break;  // found at least one
    755                }
    756              }
   \                     ??CrossCallReturnLabel_49:
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FD           MOV     R5,A
   \   000021   7401         MOV     A,#0x1
   \   000023   6D           XRL     A,R5
   \   000024   6012         JZ      ??bindAddressClear_4
   \   000026   ED           MOV     A,R5
   \   000027   700F         JNZ     ??bindAddressClear_4
   \   000029   8882         MOV     DPL,R0
   \   00002B   8983         MOV     DPH,R1
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6A           XRL     A,R2
   \   000031   7003         JNZ     ??bindAddressClear_5
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   6B           XRL     A,R3
   \                     ??bindAddressClear_5:
   \   000036   6025         JZ      ??bindAddressClear_1
   \                     ??bindAddressClear_4:
   \   000038   0C           INC     R4
   \                     ??bindAddressClear_2:
   \   000039   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00003C   E4           CLR     A
   \   00003D   93           MOVC    A,@A+DPTR
   \   00003E   F8           MOV     R0,A
   \   00003F   EC           MOV     A,R4
   \   000040   C3           CLR     C
   \   000041   98           SUBB    A,R0
   \   000042   40D3         JC      ??bindAddressClear_3
    757          
    758              if ( i == gNWK_MAX_BINDING_ENTRIES )
   \   000044   E4           CLR     A
   \   000045   93           MOVC    A,@A+DPTR
   \   000046   6C           XRL     A,R4
   \   000047   7014         JNZ     ??bindAddressClear_1
    759              {
    760                // No binding entry is associated with dstIdx.
    761                // Remove user binding bit from the address manager entry corresponding to dstIdx.
    762                AddrMgrEntry_t addrEntry;
    763          
    764                addrEntry.user = ADDRMGR_USER_BINDING;
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   7404         MOV     A,#0x4
   \   000051   F0           MOVX    @DPTR,A
    765                addrEntry.index = dstIdx;
   \   000052   740B         MOV     A,#0xb
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   12....       LCALL   ?Subroutine15 & 0xFFFF
    766          
    767                AddrMgrEntryRelease( &addrEntry );
    768              }
    769            }
   \                     ??CrossCallReturnLabel_16:
   \   00005A   12....       LCALL   `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
    770          }
   \                     ??bindAddressClear_1:
   \   00005D   80..         SJMP    ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   740D         MOV     A,#0xd
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine34_0
   \   000005                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000005                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000005                ; Setup parameters for call to function AddrMgrEntryGet
   \   000005                ; Setup parameters for call to function AddrMgrEntryGet
   \   000005   AA..         MOV     R2,?XSP + 0
   \   000007   AB..         MOV     R3,?XSP + 1
   \   000009   22           RET
    771          
    772          /*********************************************************************
    773           * @fn          bindUpdateAddr
    774           *
    775           * @brief       Update the network address in the binding table.
    776           *
    777           * @param       oldAddr - old network address
    778           * @param       newAddr - new network address
    779           *
    780           * @return      none
    781           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    782          void bindUpdateAddr( uint16 oldAddr, uint16 newAddr )
   \                     bindUpdateAddr:
    783          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    784            uint16 oldIdx;
    785            uint16 newIdx;
    786            zAddrType_t addr;
    787            bindTableIndex_t x;
    788            BindingEntry_t *pBind;
    789          
    790            addr.addrMode = Addr16Bit;
   \   00000E   7408         MOV     A,#0x8
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
    791            addr.addr.shortAddr = oldAddr;
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   12....       LCALL   ?Subroutine15 & 0xFFFF
    792            oldIdx = bindingAddrMgsHelperFind( &addr );
   \                     ??CrossCallReturnLabel_17:
   \   00001F   12....       LCALL   `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   000022   8A..         MOV     ?V0,R2
   \   000024   8B..         MOV     ?V1,R3
    793            addr.addr.shortAddr = newAddr;
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   EE           MOV     A,R6
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   EF           MOV     A,R7
   \   000030   F0           MOVX    @DPTR,A
    794            newIdx = bindingAddrMgsHelperFind( &addr );
   \   000031                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000031   AA..         MOV     R2,?XSP + 0
   \   000033   AB..         MOV     R3,?XSP + 1
   \   000035   12....       LCALL   `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   000038   8A..         MOV     ?V2,R2
    795          
    796            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00003A   7A00         MOV     R2,#0x0
   \   00003C   8025         SJMP    ??bindUpdateAddr_0
    797            {
    798              pBind = &BindingTable[x];
   \                     ??bindUpdateAddr_1:
   \   00003E   EA           MOV     A,R2
   \   00003F   12....       LCALL   ??Subroutine31_0 & 0xFFFF
    799          
    800              if ( pBind->dstIdx == oldIdx )
   \                     ??CrossCallReturnLabel_47:
   \   000042   E8           MOV     A,R0
   \   000043   2402         ADD     A,#0x2
   \   000045   F8           MOV     R0,A
   \   000046   5001         JNC     ??bindUpdateAddr_2
   \   000048   09           INC     R1
   \                     ??bindUpdateAddr_2:
   \   000049   8882         MOV     DPL,R0
   \   00004B   8983         MOV     DPH,R1
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   65..         XRL     A,?V0
   \   000050   7004         JNZ     ??bindUpdateAddr_3
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   65..         XRL     A,?V1
   \                     ??bindUpdateAddr_3:
   \   000056   700A         JNZ     ??bindUpdateAddr_4
    801              {
    802                pBind->dstIdx = newIdx;
   \   000058   8882         MOV     DPL,R0
   \   00005A   8983         MOV     DPH,R1
   \   00005C   E5..         MOV     A,?V2
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   A3           INC     DPTR
   \   000060   EB           MOV     A,R3
   \   000061   F0           MOVX    @DPTR,A
    803              }
    804            }
   \                     ??bindUpdateAddr_4:
   \   000062   0A           INC     R2
   \                     ??bindUpdateAddr_0:
   \   000063   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000066   E4           CLR     A
   \   000067   93           MOVC    A,@A+DPTR
   \   000068   F8           MOV     R0,A
   \   000069   EA           MOV     A,R2
   \   00006A   C3           CLR     C
   \   00006B   98           SUBB    A,R0
   \   00006C   40D0         JC      ??bindUpdateAddr_1
    805          }
   \   00006E   7409         MOV     A,#0x9
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   02....       LJMP    ?Subroutine4 & 0xFFFF
    806          
    807          /*********************************************************************
    808           * @fn      bindingAddrMgsHelperFind
    809           *
    810           * @brief   Turns an zAddrType_t to an Addr Manager index
    811           *
    812           * @param   addr - zAddrType_t
    813           *
    814           * @return  INVALID_NODE_ADDR if not found, otherwise an index
    815           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   740B         MOV     A,#0xb
   \   000002                REQUIRE ??Subroutine32_0
   \   000002                ; // Fall through to label ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   12....       LCALL   ?XSTACK_DISP0_8
   \   000003   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000006                REQUIRE ??Subroutine33_0
   \   000006                ; // Fall through to label ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    816          uint16 bindingAddrMgsHelperFind( zAddrType_t *addr )
   \                     bindingAddrMgsHelperFind:
    817          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV     A,#-0xd
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    818            AddrMgrEntry_t entry;
    819          
    820            // Resolve addresses with the address manager
    821            entry.user = ADDRMGR_USER_BINDING;
   \   000009   12....       LCALL   ?Subroutine16 & 0xFFFF
    822            if ( addr->addrMode == Addr16Bit )
   \                     ??CrossCallReturnLabel_20:
   \   00000C   6402         XRL     A,#0x2
   \   00000E   700E         JNZ     ??bindingAddrMgsHelperFind_0
    823            {
    824              entry.nwkAddr = addr->addr.shortAddr;
   \   000010   12....       LCALL   ?Subroutine19 & 0xFFFF
    825              AddrMgrEntryLookupNwk( &entry );
    826            }
   \                     ??CrossCallReturnLabel_51:
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000019   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00001C   8017         SJMP    ??bindingAddrMgsHelperFind_1
    827            else
    828            {
    829              AddrMgrExtAddrSet( entry.extAddr, addr->addr.extAddr );
   \                     ??bindingAddrMgsHelperFind_0:
   \   00001E                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001E   EA           MOV     A,R2
   \   00001F   FC           MOV     R4,A
   \   000020   EB           MOV     A,R3
   \   000021   FD           MOV     R5,A
   \   000022   7403         MOV     A,#0x3
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   AA82         MOV     R2,DPL
   \   000029   AB83         MOV     R3,DPH
   \   00002B   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    830              AddrMgrEntryLookupExt( &entry );
   \   00002E                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002E   AA..         MOV     R2,?XSP + 0
   \   000030   AB..         MOV     R3,?XSP + 1
   \   000032   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
    831            }
    832          
    833            return ( entry.index );
   \                     ??bindingAddrMgsHelperFind_1:
   \   000035   02....       LJMP    ?Subroutine1 & 0xFFFF
    834          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine35_0
   \   000004                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   7401         MOV     A,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000005                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000005   AA..         MOV     R2,?XSP + 0
   \   000007   AB..         MOV     R3,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   7404         MOV     A,#0x4
   \   000008   F0           MOVX    @DPTR,A
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   22           RET
    835          
    836          /*********************************************************************
    837           * @fn      bindingAddrMgsHelperConvert
    838           *
    839           * @brief   Convert an index into an zAddrType_t
    840           *
    841           * @param   idx -
    842           * @param   addr - zAddrType_t
    843           *
    844           * @return  TRUE if found, FALSE if not
    845           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    846          uint8 bindingAddrMgsHelperConvert( uint16 idx, zAddrType_t *addr )
   \                     bindingAddrMgsHelperConvert:
    847          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    848            AddrMgrEntry_t entry;
    849            uint8 stat;
    850          
    851            // Resolve addresses with the address manager
    852            entry.user = ADDRMGR_USER_BINDING;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7404         MOV     A,#0x4
   \   000016   F0           MOVX    @DPTR,A
    853            entry.index = idx;
   \   000017   740B         MOV     A,#0xb
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine15 & 0xFFFF
    854            stat = AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_18:
   \   00001F   12....       LCALL   `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   \   000022   E9           MOV     A,R1
   \   000023   F5..         MOV     ?V0,A
    855            if ( stat )
   \   000025   601D         JZ      ??bindingAddrMgsHelperConvert_0
    856            {
    857              addr->addrMode = Addr64Bit;
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   7403         MOV     A,#0x3
   \   000035   F0           MOVX    @DPTR,A
    858              osal_cpyExtAddr( addr->addr.extAddr, entry.extAddr );
   \   000036                ; Setup parameters for call to function sAddrExtCpy
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   AC82         MOV     R4,DPL
   \   00003B   AD83         MOV     R5,DPH
   \   00003D   EE           MOV     A,R6
   \   00003E   FA           MOV     R2,A
   \   00003F   EF           MOV     A,R7
   \   000040   FB           MOV     R3,A
   \   000041   12....       LCALL   `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
    859            }
    860          
    861            return ( stat );
   \                     ??bindingAddrMgsHelperConvert_0:
   \   000044   A9..         MOV     R1,?V0
   \   000046   740D         MOV     A,#0xd
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004B   02....       LJMP    ?Subroutine2 & 0xFFFF
    862          }
    863          
    864          /*********************************************************************
    865           * @fn      bindingAddrMgsHelperConvertShort
    866           *
    867           * @brief   Convert an index into a short address
    868           *
    869           * @param   idx -
    870           *
    871           * @return  INVALID_NODE_ADDR if not available, otherwise the short address
    872           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    873          uint16 bindingAddrMgsHelperConvertShort( uint16 idx )
   \                     bindingAddrMgsHelperConvertShort:
    874          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV     A,#-0xd
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    875            AddrMgrEntry_t entry;
    876          
    877            // Resolve addresses with the address manager
    878            entry.user = ADDRMGR_USER_BINDING;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   7404         MOV     A,#0x4
   \   000011   F0           MOVX    @DPTR,A
    879            entry.index = idx;
   \   000012   740B         MOV     A,#0xb
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine15 & 0xFFFF
    880            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_19:
   \   00001A   12....       LCALL   `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
    881          
    882            return ( entry.nwkAddr );
   \   00001D   7401         MOV     A,#0x1
   \   00001F   02....       LJMP    ??Subroutine32_0 & 0xFFFF
    883          }
    884          
    885          /*********************************************************************
    886           * @fn      bindAddrMgrLocalLoad
    887           *
    888           * @brief   Load local(self and parent) address information into
    889           *          Address Manager
    890           *
    891           * @param   none
    892           *
    893           * @return  none
    894           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine29_0
   \   000003                ; // Fall through to label ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    895          void bindAddrMgrLocalLoad( void )
   \                     bindAddrMgrLocalLoad:
    896          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    897            AddrMgrEntry_t entry;
    898            uint16         parent;
    899          
    900            // add "local"(self and parent) address informtion into the Address
    901            // Manager
    902            if ( bindAddrMgrLocalLoaded == FALSE )
   \   00000A   90....       MOV     DPTR,#bindAddrMgrLocalLoaded
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   707B         JNZ     ??bindAddrMgrLocalLoad_0
    903            {
    904              // add the device's address information
    905              entry.user    = ADDRMGR_USER_BINDING;
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   7404         MOV     A,#0x4
   \   000018   F0           MOVX    @DPTR,A
    906              entry.nwkAddr = _NIB.nwkDevAddress;
   \   000019   90....       MOV     DPTR,#_NIB + 20
   \   00001C   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E8           MOV     A,R0
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   E9           MOV     A,R1
   \   000026   F0           MOVX    @DPTR,A
    907              AddrMgrExtAddrSet( entry.extAddr, NLME_GetExtAddr() );
   \   000027                ; Setup parameters for call to function NLME_GetExtAddr
   \   000027   12....       LCALL   `??NLME_GetExtAddr::?relay`; Banked call to: NLME_GetExtAddr
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   \   00002E   AC..         MOV     R4,?V0
   \   000030   AD..         MOV     R5,?V1
   \   000032                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000032   7403         MOV     A,#0x3
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   AA82         MOV     R2,DPL
   \   000039   AB83         MOV     R3,DPH
   \   00003B   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    908              AddrMgrEntryUpdate( &entry );
   \   00003E                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00003E   AA..         MOV     R2,?XSP + 0
   \   000040   AB..         MOV     R3,?XSP + 1
   \   000042   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
    909          
    910              // make sure parent address is valid
    911              parent = NLME_GetCoordShortAddr();
   \   000045                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000045   12....       LCALL   `??NLME_GetCoordShortAddr::?relay`; Banked call to: NLME_GetCoordShortAddr
   \   000048   8A..         MOV     ?V0,R2
   \   00004A   8B..         MOV     ?V1,R3
   \   00004C   A8..         MOV     R0,?V0
   \   00004E   A9..         MOV     R1,?V1
    912              if ( ( parent != entry.nwkAddr     ) &&
    913                   ( parent != INVALID_NODE_ADDR )    )
   \   000050   7401         MOV     A,#0x1
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   E0           MOVX    A,@DPTR
   \   000056   68           XRL     A,R0
   \   000057   7003         JNZ     ??bindAddrMgrLocalLoad_1
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   69           XRL     A,R1
   \                     ??bindAddrMgrLocalLoad_1:
   \   00005C   6027         JZ      ??bindAddrMgrLocalLoad_2
   \   00005E   74FE         MOV     A,#-0x2
   \   000060   68           XRL     A,R0
   \   000061   7003         JNZ     ??bindAddrMgrLocalLoad_3
   \   000063   74FF         MOV     A,#-0x1
   \   000065   69           XRL     A,R1
   \                     ??bindAddrMgrLocalLoad_3:
   \   000066   601D         JZ      ??bindAddrMgrLocalLoad_2
    914              {
    915                // add the parent's address information
    916                entry.nwkAddr = parent;
   \   000068   7401         MOV     A,#0x1
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E8           MOV     A,R0
   \   00006E   F0           MOVX    @DPTR,A
   \   00006F   A3           INC     DPTR
   \   000070   E9           MOV     A,R1
   \   000071   F0           MOVX    @DPTR,A
    917                NLME_GetCoordExtAddr( entry.extAddr );
   \   000072                ; Setup parameters for call to function NLME_GetCoordExtAddr
   \   000072   7403         MOV     A,#0x3
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   AA82         MOV     R2,DPL
   \   000079   AB83         MOV     R3,DPH
   \   00007B   12....       LCALL   `??NLME_GetCoordExtAddr::?relay`; Banked call to: NLME_GetCoordExtAddr
    918                AddrMgrEntryUpdate( &entry );
   \   00007E                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00007E   AA..         MOV     R2,?XSP + 0
   \   000080   AB..         MOV     R3,?XSP + 1
   \   000082   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
    919              }
    920          
    921              bindAddrMgrLocalLoaded = TRUE;
   \                     ??bindAddrMgrLocalLoad_2:
   \   000085   90....       MOV     DPTR,#bindAddrMgrLocalLoaded
   \   000088   7401         MOV     A,#0x1
   \   00008A   F0           MOVX    @DPTR,A
    922            }
    923          }
   \                     ??bindAddrMgrLocalLoad_0:
   \   00008B   740D         MOV     A,#0xd
   \   00008D   02....       LJMP    ?Subroutine0 & 0xFFFF
    924          
    925          /*********************************************************************
    926           * @fn      bindAddrIndexGet
    927           *
    928           * @brief   Get bind address index.
    929           *
    930           * @param   addr - <zAddrType_t>
    931           *
    932           * @return  (uint16) address index
    933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    934          uint16 bindAddrIndexGet( zAddrType_t* addr )
   \                     bindAddrIndexGet:
    935          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV     A,#-0xd
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    936            AddrMgrEntry_t entry;
    937            uint8          update;
    938          
    939            update = FALSE;
    940          
    941            // sync binding addresses with the address manager
    942            entry.user = ADDRMGR_USER_BINDING;
   \   000009   12....       LCALL   ?Subroutine16 & 0xFFFF
    943          
    944            if ( addr->addrMode == Addr16Bit )
   \                     ??CrossCallReturnLabel_21:
   \   00000C   F8           MOV     R0,A
   \   00000D   7402         MOV     A,#0x2
   \   00000F   68           XRL     A,R0
   \   000010   7011         JNZ     ??bindAddrIndexGet_0
    945            {
    946              entry.nwkAddr = addr->addr.shortAddr;
   \   000012   12....       LCALL   ?Subroutine19 & 0xFFFF
    947          
    948              if ( AddrMgrEntryLookupNwk( &entry ) == FALSE )
    949              {
    950                update = TRUE;
    951              }
    952            }
   \                     ??CrossCallReturnLabel_52:
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00001B   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00001E   E9           MOV     A,R1
   \   00001F   704C         JNZ     ??bindAddrIndexGet_1
   \   000021   801F         SJMP    ??bindAddrIndexGet_2
    953            else if ( addr->addrMode == Addr64Bit )
   \                     ??bindAddrIndexGet_0:
   \   000023   7403         MOV     A,#0x3
   \   000025   68           XRL     A,R0
   \   000026   7023         JNZ     ??bindAddrIndexGet_3
    954            {
    955              AddrMgrExtAddrSet( entry.extAddr, addr->addr.extAddr );
   \   000028                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000028   EA           MOV     A,R2
   \   000029   FC           MOV     R4,A
   \   00002A   EB           MOV     A,R3
   \   00002B   FD           MOV     R5,A
   \   00002C   7403         MOV     A,#0x3
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   AA82         MOV     R2,DPL
   \   000033   AB83         MOV     R3,DPH
   \   000035   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    956          
    957              if ( AddrMgrEntryLookupExt( &entry ) == FALSE )
   \   000038                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000038   AA..         MOV     R2,?XSP + 0
   \   00003A   AB..         MOV     R3,?XSP + 1
   \   00003C   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00003F   E9           MOV     A,R1
   \   000040   702B         JNZ     ??bindAddrIndexGet_1
    958              {
    959                update = TRUE;
    960              }
    961            }
    962            else if ( addr->addrMode == AddrGroup )
    963            {
    964              entry.index = addr->addr.shortAddr;
    965            }
    966            else
    967            {
    968              entry.index = INVALID_NODE_ADDR;
    969            }
    970          
    971            if ( update )
    972            {
    973              AddrMgrEntryUpdate( &entry );
   \                     ??bindAddrIndexGet_2:
   \   000042                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000042   AA..         MOV     R2,?XSP + 0
   \   000044   AB..         MOV     R3,?XSP + 1
   \   000046   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000049   8022         SJMP    ??bindAddrIndexGet_1
    974            }
   \                     ??bindAddrIndexGet_3:
   \   00004B   7401         MOV     A,#0x1
   \   00004D   68           XRL     A,R0
   \   00004E   7012         JNZ     ??bindAddrIndexGet_4
   \   000050   8A82         MOV     DPL,R2
   \   000052   8B83         MOV     DPH,R3
   \   000054   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000057   740B         MOV     A,#0xb
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   E8           MOV     A,R0
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E9           MOV     A,R1
   \   000060   800A         SJMP    ??bindAddrIndexGet_5
   \                     ??bindAddrIndexGet_4:
   \   000062   740B         MOV     A,#0xb
   \   000064   12....       LCALL   ?XSTACK_DISP0_8
   \   000067   74FE         MOV     A,#-0x2
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   04           INC     A
   \                     ??bindAddrIndexGet_5:
   \   00006C   F0           MOVX    @DPTR,A
    975          
    976            return entry.index;
   \                     ??bindAddrIndexGet_1:
   \   00006D   02....       LJMP    ?Subroutine1 & 0xFFFF
    977          }
    978          
    979          /*********************************************************************
    980           * @fn      GetBindingTableEntry
    981           *
    982           * @brief   Get a pointer to the Nth valid binding table entry.
    983           *
    984           * @param   Nth valid entry being requested.
    985           *
    986           * @return  The Nth valid binding table entry.
    987           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    988          BindingEntry_t *GetBindingTableEntry( uint16 Nth )
   \                     GetBindingTableEntry:
    989          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
    990            BindingEntry_t *rtrn = NULL;
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   7B00         MOV     R3,#0x0
    991          
    992          #if defined ( REFLECTOR )
    993            bindTableIndex_t idx, cnt = 0;
   \   00000D   7E00         MOV     R6,#0x0
    994          
    995            for ( idx = 0; idx < gNWK_MAX_BINDING_ENTRIES; idx++ )
   \   00000F   7F00         MOV     R7,#0x0
   \   000011   8001         SJMP    ??GetBindingTableEntry_0
   \                     ??GetBindingTableEntry_1:
   \   000013   0F           INC     R7
   \                     ??GetBindingTableEntry_0:
   \   000014   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000017   E4           CLR     A
   \   000018   93           MOVC    A,@A+DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   EF           MOV     A,R7
   \   00001B   C3           CLR     C
   \   00001C   98           SUBB    A,R0
   \   00001D   5016         JNC     ??GetBindingTableEntry_2
    996            {
    997              if ( BindingTable[idx].srcEP != NV_BIND_EMPTY )
   \   00001F   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000022   60EF         JZ      ??GetBindingTableEntry_1
    998              {
    999                if ( cnt++ == Nth )
   \   000024   8E..         MOV     ?V0,R6
   \   000026   7401         MOV     A,#0x1
   \   000028   2E           ADD     A,R6
   \   000029   FE           MOV     R6,A
   \   00002A   A8..         MOV     R0,?V0
   \   00002C   EC           MOV     A,R4
   \   00002D   68           XRL     A,R0
   \   00002E   4D           ORL     A,R5
   \   00002F   70E2         JNZ     ??GetBindingTableEntry_1
   1000                {
   1001                  rtrn = BindingTable+idx;
   \   000031   AA82         MOV     R2,DPL
   \   000033   AB83         MOV     R3,DPH
   1002                  break;
   1003                }
   1004              }
   1005            }
   1006          #else
   1007            (void)Nth;
   1008          #endif
   1009          
   1010            return rtrn;
   \                     ??GetBindingTableEntry_2:
   \   000035   02....       LJMP    ?Subroutine2 & 0xFFFF
   1011          }
   1012          
   1013          #if !defined ( BINDINGTABLE_NV_SINGLES )
   1014          /*********************************************************************
   1015           * @fn          BindInitNV
   1016           *
   1017           * @brief       Initialize the Binding NV Item
   1018           *
   1019           * @param       none
   1020           *
   1021           * @return      ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1022           *              exist in NV, NV_OPER_FAILED if failure.
   1023           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1024          byte BindInitNV( void )
   \                     BindInitNV:
   1025          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1026            byte ret;
   1027          
   1028            // Initialize the device list
   1029            ret = osal_nv_item_init( ZCD_NV_BINDING_TABLE,
   1030                            (uint16)( sizeof( nvBindingHdr_t ) + NV_BIND_ITEM_SIZE ), NULL );
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005   E4           CLR     A
   \   000006   F5..         MOV     ?V0,A
   \   000008   F5..         MOV     ?V1,A
   \   00000A   78..         MOV     R0,#?V0
   \   00000C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000F   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000012   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000015   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001D   E9           MOV     A,R1
   \   00001E   FE           MOV     R6,A
   1031          
   1032            if ( ret != ZSUCCESS )
   \   00001F   6003         JZ      ??BindInitNV_0
   1033            {
   1034              BindSetDefaultNV();
   \   000021                ; Setup parameters for call to function BindSetDefaultNV
   \   000021   12....       LCALL   `??BindSetDefaultNV::?relay`; Banked call to: BindSetDefaultNV
   1035            }
   1036          
   1037            return ( ret );
   \                     ??BindInitNV_0:
   \   000024   EE           MOV     A,R6
   \   000025   F9           MOV     R1,A
   \   000026   02....       LJMP    ??Subroutine29_0 & 0xFFFF
   1038          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   FC           MOV     R4,A
   \   000001   E4           CLR     A
   \   000002   39           ADDC    A,R1
   \   000003   FD           MOV     R5,A
   \   000004   7A41         MOV     R2,#0x41
   \   000006   7B00         MOV     R3,#0x0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   90....       MOV     DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR     A
   \   000004   93           MOVC    A,@A+DPTR
   \   000005   F8           MOV     R0,A
   \   000006   7401         MOV     A,#0x1
   \   000008   93           MOVC    A,@A+DPTR
   \   000009   F9           MOV     R1,A
   \   00000A   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000D   E4           CLR     A
   \   00000E   93           MOVC    A,@A+DPTR
   \   00000F   F5..         MOV     ?V0,A
   \   000011   E8           MOV     A,R0
   \   000012   85..F0       MOV     B,?V0
   \   000015   A4           MUL     AB
   \   000016   F8           MOV     R0,A
   \   000017   AAF0         MOV     R2,B
   \   000019   85..F0       MOV     B,?V0
   \   00001C   E9           MOV     A,R1
   \   00001D   A4           MUL     AB
   \   00001E   2A           ADD     A,R2
   \   00001F   F9           MOV     R1,A
   \   000020   E8           MOV     A,R0
   \   000021   2402         ADD     A,#0x2
   \   000023   22           RET
   1039          
   1040          /*********************************************************************
   1041           * @fn          BindSetDefaultNV
   1042           *
   1043           * @brief       Write the defaults to NV
   1044           *
   1045           * @param       none
   1046           *
   1047           * @return      none
   1048           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1049          void BindSetDefaultNV( void )
   \                     BindSetDefaultNV:
   1050          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1051            nvBindingHdr_t hdr;
   1052          
   1053            // Initialize the header
   1054            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   1055          
   1056            // Save off the header
   1057            osal_nv_write( ZCD_NV_BINDING_TABLE, 0, sizeof( nvBindingHdr_t ), &hdr );
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   A8..         MOV     R0,?XSP + 0
   \   000016   A9..         MOV     R1,?XSP + 1
   \   000018   88..         MOV     ?V0,R0
   \   00001A   89..         MOV     ?V1,R1
   \   00001C   78..         MOV     R0,#?V0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   75..02       MOV     ?V0,#0x2
   \   000024   75..00       MOV     ?V1,#0x0
   \   000027   78..         MOV     R0,#?V0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   7C00         MOV     R4,#0x0
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   7A41         MOV     R2,#0x41
   \   000032   7B00         MOV     R3,#0x0
   \   000034   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000037   7404         MOV     A,#0x4
   \   000039   12....       LCALL   ?DEALLOC_XSTACK8
   1058          }
   \   00003C   7402         MOV     A,#0x2
   \   00003E   02....       LJMP    ?Subroutine0 & 0xFFFF
   1059          
   1060          #if !defined ( DONT_UPGRADE_BIND )
   1061          /*********************************************************************
   1062           * @fn          BindCopyBackupToNewNV
   1063           *
   1064           * @brief       Creates the New NV item, copies the backup data into
   1065           *              the New NV ID, and Deletes the duplicate NV item.
   1066           *
   1067           * @param       dupLen - NV item length of the old Binding table.
   1068           * @param       newLen - NV item length of the new Binding table to be created.
   1069           *
   1070           * @return      ZSuccess - All the actions were successful.
   1071           *              ZFailure - Any of the actions failed.
   1072           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1073          static uint8 BindCopyBackupToNewNV( uint16 dupLen, uint16 newLen )
   \                     BindCopyBackupToNewNV:
   1074          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   1075            uint8 status = ZSuccess;
   \   000012   75..00       MOV     ?V2,#0x0
   1076            uint16 bindLen;
   1077          
   1078            bindLen = osal_nv_item_len( ZCD_NV_BINDING_TABLE );
   \   000015                ; Setup parameters for call to function osal_nv_item_len
   \   000015   7A41         MOV     R2,#0x41
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   00001C   8A..         MOV     ?V4,R2
   \   00001E   8B..         MOV     ?V5,R3
   \   000020   AC..         MOV     R4,?V4
   \   000022   AD..         MOV     R5,?V5
   1079          
   1080          
   1081            if ( ( bindLen > 0 ) && ( bindLen != newLen ) )
   \   000024   EC           MOV     A,R4
   \   000025   4D           ORL     A,R5
   \   000026   6011         JZ      ??BindCopyBackupToNewNV_0
   \   000028   E5..         MOV     A,?V0
   \   00002A   6C           XRL     A,R4
   \   00002B   7003         JNZ     ??BindCopyBackupToNewNV_1
   \   00002D   E5..         MOV     A,?V1
   \   00002F   6D           XRL     A,R5
   \                     ??BindCopyBackupToNewNV_1:
   \   000030   6007         JZ      ??BindCopyBackupToNewNV_0
   1082            {
   1083              // The existing item does not match the New length
   1084              osal_nv_delete( ZCD_NV_BINDING_TABLE, bindLen );
   \   000032                ; Setup parameters for call to function osal_nv_delete
   \   000032   7A41         MOV     R2,#0x41
   \   000034   7B00         MOV     R3,#0x0
   \   000036   12....       LCALL   `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   1085            }
   1086          
   1087            // Create Binding Table NV item with the NEW legth
   1088            if ( osal_nv_item_init( ZCD_NV_BINDING_TABLE, newLen, NULL ) != NV_OPER_FAILED )
   \                     ??BindCopyBackupToNewNV_0:
   \   000039                ; Setup parameters for call to function osal_nv_item_init
   \   000039   E4           CLR     A
   \   00003A   F5..         MOV     ?V4,A
   \   00003C   F5..         MOV     ?V5,A
   \   00003E   78..         MOV     R0,#?V4
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   AC..         MOV     R4,?V0
   \   000045   AD..         MOV     R5,?V1
   \   000047   7A41         MOV     R2,#0x41
   \   000049   7B00         MOV     R3,#0x0
   \   00004B   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00004E   7402         MOV     A,#0x2
   \   000050   12....       LCALL   ?DEALLOC_XSTACK8
   \   000053   E9           MOV     A,R1
   \   000054   640A         XRL     A,#0xa
   \   000056   7003         JNZ     $+5
   \   000058   02....       LJMP    ??BindCopyBackupToNewNV_2 & 0xFFFF
   1089            {
   1090              nvBindingHdr_t hdrBackup;
   1091          
   1092              // Copy ONLY the valid records from the duplicate NV table into the new table
   1093              // at the end of this process the table content will be compacted
   1094              if ( osal_nv_read( ZCD_NV_DUPLICATE_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdrBackup ) == ZSuccess )
   \   00005B                ; Setup parameters for call to function osal_nv_read
   \   00005B   7402         MOV     A,#0x2
   \   00005D   12....       LCALL   ?XSTACK_DISP100_8
   \   000060   88..         MOV     ?V0,R0
   \   000062   89..         MOV     ?V1,R1
   \   000064   78..         MOV     R0,#?V0
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000069   75..02       MOV     ?V0,#0x2
   \   00006C   75..00       MOV     ?V1,#0x0
   \   00006F   78..         MOV     R0,#?V0
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000074   7C00         MOV     R4,#0x0
   \   000076   7D00         MOV     R5,#0x0
   \   000078   7A00         MOV     R2,#0x0
   \   00007A   7B03         MOV     R3,#0x3
   \   00007C   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00007F   7404         MOV     A,#0x4
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \   000084   E9           MOV     A,R1
   \   000085   6003         JZ      $+5
   \   000087   02....       LJMP    ??BindCopyBackupToNewNV_2 & 0xFFFF
   1095              {
   1096                bindTableIndex_t i;
   1097                uint16 validBackupRecs = 0;
   \   00008A   85..82       MOV     DPL,?XSP + 0
   \   00008D   85..83       MOV     DPH,?XSP + 1
   \   000090   E4           CLR     A
   \   000091   F0           MOVX    @DPTR,A
   \   000092   A3           INC     DPTR
   \   000093   F0           MOVX    @DPTR,A
   1098                BindingEntry_t backupRec;
   1099          
   1100                // Read in the device list. This loop will stop when:
   1101                // The total number of valid records has been reached either because:
   1102                //          The new table is full of valid records OR
   1103                //          The old table has less valid records than the size of the table
   1104                for ( i = 0; ( validBackupRecs < gNWK_MAX_BINDING_ENTRIES ) && ( validBackupRecs < hdrBackup.numRecs ); i++ )
   \   000094   75..00       MOV     ?V0,#0x0
   \   000097   8069         SJMP    ??BindCopyBackupToNewNV_3
   1105                {
   1106                  if ( osal_nv_read( ZCD_NV_DUPLICATE_BINDING_TABLE,
   1107                                    (uint16)(sizeof(nvBindingHdr_t) + (i * NV_BIND_REC_SIZE)),
   1108                                    NV_BIND_REC_SIZE, &backupRec ) == ZSuccess )
   \                     ??BindCopyBackupToNewNV_4:
   \   000099                ; Setup parameters for call to function osal_nv_read
   \   000099   7404         MOV     A,#0x4
   \   00009B   12....       LCALL   ?XSTACK_DISP100_8
   \   00009E   88..         MOV     ?V4,R0
   \   0000A0   89..         MOV     ?V5,R1
   \   0000A2   78..         MOV     R0,#?V4
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A7   90....       MOV     DPTR,#gBIND_REC_SIZE
   \   0000AA   12....       LCALL   ?PUSH_XSTACK8_C_TWO
   \   0000AD   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000B0   7A00         MOV     R2,#0x0
   \   0000B2   7B03         MOV     R3,#0x3
   \   0000B4   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000B7   7404         MOV     A,#0x4
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BC   E9           MOV     A,R1
   \   0000BD   6003         JZ      $+5
   \   0000BF   02....       LJMP    ??BindCopyBackupToNewNV_2 & 0xFFFF
   1109                  {
   1110                    if ( backupRec.srcEP != NV_BIND_EMPTY )
   \   0000C2   7404         MOV     A,#0x4
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   F4           CPL     A
   \   0000C9   6035         JZ      ??CrossCallReturnLabel_31
   1111                    {
   1112                      // Save the valid record into the NEW NV table.
   1113                      if ( osal_nv_write( ZCD_NV_BINDING_TABLE,
   1114                                          (uint16)((sizeof(nvBindingHdr_t)) + (validBackupRecs * NV_BIND_REC_SIZE)),
   1115                                          NV_BIND_REC_SIZE, &backupRec ) != ZSuccess )
   \   0000CB                ; Setup parameters for call to function osal_nv_write
   \   0000CB   7404         MOV     A,#0x4
   \   0000CD   12....       LCALL   ?XSTACK_DISP100_8
   \   0000D0   88..         MOV     ?V4,R0
   \   0000D2   89..         MOV     ?V5,R1
   \   0000D4   78..         MOV     R0,#?V4
   \   0000D6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D9   90....       MOV     DPTR,#gBIND_REC_SIZE
   \   0000DC   12....       LCALL   ?PUSH_XSTACK8_C_TWO
   \   0000DF   7404         MOV     A,#0x4
   \   0000E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E4   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0000E7   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0000EA   FA           MOV     R2,A
   \   0000EB   85..F0       MOV     B,?V4
   \   0000EE   E9           MOV     A,R1
   \   0000EF   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000F2   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000F5   7404         MOV     A,#0x4
   \   0000F7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FA   E9           MOV     A,R1
   \   0000FB   707C         JNZ     ??BindCopyBackupToNewNV_2
   1116                      {
   1117                         status = ZFailure;
   1118                         break; // Terminate the loop as soon as a problem with NV is detected
   1119                      }
   1120          
   1121                      validBackupRecs++;
   \   0000FD   12....       LCALL   ?Subroutine23 & 0xFFFF
   1122                    }
   1123                  }
   1124                  else
   1125                  {
   1126                     status = ZFailure;
   1127                     break; // Terminate the loop as soon as a problem with NV is detected
   1128                  }
   1129                }
   \                     ??CrossCallReturnLabel_31:
   \   000100   05..         INC     ?V0
   \                     ??BindCopyBackupToNewNV_3:
   \   000102   85..82       MOV     DPL,?XSP + 0
   \   000105   85..83       MOV     DPH,?XSP + 1
   \   000108   C082         PUSH    DPL
   \   00010A   C083         PUSH    DPH
   \   00010C   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00010F   E4           CLR     A
   \   000110   93           MOVC    A,@A+DPTR
   \   000111   F8           MOV     R0,A
   \   000112   D083         POP     DPH
   \   000114   D082         POP     DPL
   \   000116   C3           CLR     C
   \   000117   E0           MOVX    A,@DPTR
   \   000118   98           SUBB    A,R0
   \   000119   A3           INC     DPTR
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   9400         SUBB    A,#0x0
   \   00011D   5021         JNC     ??BindCopyBackupToNewNV_5
   \   00011F   85..82       MOV     DPL,?XSP + 0
   \   000122   85..83       MOV     DPH,?XSP + 1
   \   000125   C082         PUSH    DPL
   \   000127   C083         PUSH    DPH
   \   000129   7402         MOV     A,#0x2
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000131   D083         POP     DPH
   \   000133   D082         POP     DPL
   \   000135   C3           CLR     C
   \   000136   E0           MOVX    A,@DPTR
   \   000137   98           SUBB    A,R0
   \   000138   A3           INC     DPTR
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   99           SUBB    A,R1
   \   00013B   5003         JNC     $+5
   \   00013D   02....       LJMP    ??BindCopyBackupToNewNV_4 & 0xFFFF
   1130          
   1131                // Only save the header and delete the duplicate element if the previous
   1132                // process was successful
   1133                if ( status == ZSuccess )
   1134                {
   1135                  // Save off the header
   1136                  if ( osal_nv_write( ZCD_NV_BINDING_TABLE, 0,
   1137                                      sizeof(nvBindingHdr_t), &validBackupRecs ) == ZSuccess )
   \                     ??BindCopyBackupToNewNV_5:
   \   000140                ; Setup parameters for call to function osal_nv_write
   \   000140   A8..         MOV     R0,?XSP + 0
   \   000142   A9..         MOV     R1,?XSP + 1
   \   000144   88..         MOV     ?V0,R0
   \   000146   89..         MOV     ?V1,R1
   \   000148   78..         MOV     R0,#?V0
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014D   75..02       MOV     ?V0,#0x2
   \   000150   75..00       MOV     ?V1,#0x0
   \   000153   78..         MOV     R0,#?V0
   \   000155   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000158   7C00         MOV     R4,#0x0
   \   00015A   7D00         MOV     R5,#0x0
   \   00015C   7A41         MOV     R2,#0x41
   \   00015E   7B00         MOV     R3,#0x0
   \   000160   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000163   7404         MOV     A,#0x4
   \   000165   12....       LCALL   ?DEALLOC_XSTACK8
   \   000168   E9           MOV     A,R1
   \   000169   700E         JNZ     ??BindCopyBackupToNewNV_2
   1138                  {
   1139                    // Delete the duplicate NV Item, once the data has been stored in the NEW table
   1140                    if ( osal_nv_delete( ZCD_NV_DUPLICATE_BINDING_TABLE, dupLen ) != ZSuccess )
   \   00016B                ; Setup parameters for call to function osal_nv_delete
   \   00016B   EE           MOV     A,R6
   \   00016C   FC           MOV     R4,A
   \   00016D   EF           MOV     A,R7
   \   00016E   FD           MOV     R5,A
   \   00016F   7A00         MOV     R2,#0x0
   \   000171   7B03         MOV     R3,#0x3
   \   000173   12....       LCALL   `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   \   000176   E9           MOV     A,R1
   \   000177   6003         JZ      ??BindCopyBackupToNewNV_6
   1141                    {
   1142                      status = ZFailure;
   1143                    }
   1144                  }
   1145                  else
   1146                  {
   1147                    status = ZFailure;
   1148                  }
   1149                }
   1150              }
   1151              else
   1152              {
   1153                status = ZFailure;
   1154              }
   1155            }
   1156            else
   1157            {
   1158              status = ZFailure;
   \                     ??BindCopyBackupToNewNV_2:
   \   000179   75..01       MOV     ?V2,#0x1
   1159            }
   1160          
   1161            return ( status );
   \                     ??BindCopyBackupToNewNV_6:
   \   00017C   A9..         MOV     R1,?V2
   \   00017E   7412         MOV     A,#0x12
   \   000180   80..         SJMP    ??Subroutine37_0
   1162          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   A4           MUL     AB
   \   000001   2A           ADD     A,R2
   \   000002   F9           MOV     R1,A
   \   000003   E8           MOV     A,R0
   \   000004   2402         ADD     A,#0x2
   \   000006                REQUIRE ??Subroutine36_0
   \   000006                ; // Fall through to label ??Subroutine36_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine38_0
   \   000003                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   A8..         MOV     R0,?V0
   \   000002   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000005   F9           MOV     R1,A
   \   000006   E8           MOV     A,R0
   \   000007   2402         ADD     A,#0x2
   \   000009   FC           MOV     R4,A
   \   00000A   E4           CLR     A
   \   00000B   39           ADDC    A,R1
   \   00000C   FD           MOV     R5,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   90....       MOV     DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR     A
   \   000004   93           MOVC    A,@A+DPTR
   \   000005   F5..         MOV     ?V4,A
   \   000007   7401         MOV     A,#0x1
   \   000009   93           MOVC    A,@A+DPTR
   \   00000A   F5..         MOV     ?V5,A
   \   00000C   E8           MOV     A,R0
   \   00000D   85..F0       MOV     B,?V4
   \   000010   A4           MUL     AB
   \   000011   C8           XCH     A,R0
   \   000012   AAF0         MOV     R2,B
   \   000014   85..F0       MOV     B,?V5
   \   000017   A4           MUL     AB
   \   000018   2A           ADD     A,R2
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   2401         ADD     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   3400         ADDC    A,#0x0
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   22           RET
   1163          #endif // !DONT_UPGRADE_BIND
   1164          
   1165          #if !defined ( DONT_UPGRADE_BIND )
   1166          /*********************************************************************
   1167           * @fn          BindUpgradeTableInNV
   1168           *
   1169           * @brief       Verifies if the existing table in NV has different size
   1170           *              than the table defined by parameters in the current code.
   1171           *              If different, creates a backup table, deletes the existing
   1172           *              table and creates the new table with the new size. After
   1173           *              this process is done ZCD_NV_BINDING_TABLE NV item contains
   1174           *              only valid records retrieved from the original table, up to
   1175           *              the maximum number of records defined by gNWK_MAX_BINDING_ENTRIES
   1176           *
   1177           * @param       none
   1178           *
   1179           * @return      ZSuccess - the Update process was sucessful.
   1180           *              ZFailure - otherwise.
   1181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine37_0
   \   000002                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1182          static uint8 BindUpgradeTableInNV( void )
   \                     BindUpgradeTableInNV:
   1183          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1184            uint8 status = ZSuccess;
   \   00000A   75..00       MOV     ?V2,#0x0
   1185            nvBindingHdr_t hdr;
   1186            uint16 dupLen;
   1187            uint16 bindLen;
   1188            uint16 newLen;
   1189            bool duplicateReady = FALSE;
   1190          
   1191            // Size of the Binding table based on current paramenters in the code
   1192            newLen = sizeof(nvBindingHdr_t) + NV_BIND_ITEM_SIZE;
   \   00000D   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000010   F5..         MOV     ?V0,A
   \   000012   E4           CLR     A
   \   000013   39           ADDC    A,R1
   \   000014   F5..         MOV     ?V1,A
   1193          
   1194            // Size of the Binding table NV item, this is the whole size of the item,
   1195            // it could inculde invalid records also
   1196            bindLen = osal_nv_item_len( ZCD_NV_BINDING_TABLE );
   \   000016                ; Setup parameters for call to function osal_nv_item_len
   \   000016   7A41         MOV     R2,#0x41
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   00001D   8A..         MOV     ?V4,R2
   \   00001F   8B..         MOV     ?V5,R3
   \   000021   AE..         MOV     R6,?V4
   \   000023   AF..         MOV     R7,?V5
   1197          
   1198            // Get the number of valid records from the Binding table
   1199            osal_nv_read( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr );
   \   000025                ; Setup parameters for call to function osal_nv_read
   \   000025   A8..         MOV     R0,?XSP + 0
   \   000027   A9..         MOV     R1,?XSP + 1
   \   000029   88..         MOV     ?V4,R0
   \   00002B   89..         MOV     ?V5,R1
   \   00002D   78..         MOV     R0,#?V4
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75..02       MOV     ?V4,#0x2
   \   000035   75..00       MOV     ?V5,#0x0
   \   000038   78..         MOV     R0,#?V4
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7C00         MOV     R4,#0x0
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   7A41         MOV     R2,#0x41
   \   000043   7B00         MOV     R3,#0x0
   \   000045   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000048   7404         MOV     A,#0x4
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   1200          
   1201            // Identify if there is a duplicate NV item, if it is there, that means an
   1202            // Upgrade process did not finish properly last time
   1203            // The length function will return 0 if the Backup NV ID does not exist.
   1204            dupLen = osal_nv_item_len( ZCD_NV_DUPLICATE_BINDING_TABLE );
   \   00004D                ; Setup parameters for call to function osal_nv_item_len
   \   00004D   7A00         MOV     R2,#0x0
   \   00004F   7B03         MOV     R3,#0x3
   \   000051   12....       LCALL   `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000054   8A..         MOV     ?V4,R2
   \   000056   8B..         MOV     ?V5,R3
   \   000058   A8..         MOV     R0,?V4
   \   00005A   A9..         MOV     R1,?V5
   1205          
   1206            // A duplicate of the original Binding item will be done if:
   1207            // 1) A duplicate NV item DOES NOT exist AND the size of the original Binding
   1208            //    item in NV is different (larger/smaller) than the the length calculated
   1209            //    from the parameters in the code. If they are the same there is no need
   1210            //    to do the Upgrade process.
   1211            // 2) A duplicate NV item exists (probably because the previous upgrade
   1212            //    process was interrupted) and [the original Binding NV items exists AND
   1213            //    has valid recods (it is important to make sure that valid records exist
   1214            //    in the binding table because it is possible that the item was created
   1215            //    but the data was not copied in the previous upgrade process).
   1216            if ( ( ( dupLen == 0 ) && ( bindLen != newLen ) ) ||
   1217                 ( ( dupLen > 0 ) && ( bindLen > 0 ) && ( hdr.numRecs > 0 ) ) )
   \   00005C   E8           MOV     A,R0
   \   00005D   49           ORL     A,R1
   \   00005E   700C         JNZ     ??BindUpgradeTableInNV_0
   \   000060   E5..         MOV     A,?V0
   \   000062   6E           XRL     A,R6
   \   000063   7003         JNZ     ??BindUpgradeTableInNV_1
   \   000065   E5..         MOV     A,?V1
   \   000067   6F           XRL     A,R7
   \                     ??BindUpgradeTableInNV_1:
   \   000068   700D         JNZ     ??BindUpgradeTableInNV_2
   \   00006A   8041         SJMP    ??BindUpgradeTableInNV_3
   \                     ??BindUpgradeTableInNV_0:
   \   00006C   EE           MOV     A,R6
   \   00006D   4F           ORL     A,R7
   \   00006E   602B         JZ      ??BindUpgradeTableInNV_4
   \   000070   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000073   EA           MOV     A,R2
   \   000074   4B           ORL     A,R3
   \   000075   6024         JZ      ??BindUpgradeTableInNV_4
   1218            {
   1219              // Create a copy from original NV item into a duplicate NV item
   1220              if ( ( status = nwkCreateDuplicateNV( ZCD_NV_BINDING_TABLE,
   1221                                                    ZCD_NV_DUPLICATE_BINDING_TABLE ) ) == ZSuccess )
   \                     ??BindUpgradeTableInNV_2:
   \   000077                ; Setup parameters for call to function nwkCreateDuplicateNV
   \   000077   7C00         MOV     R4,#0x0
   \   000079   7D03         MOV     R5,#0x3
   \   00007B   7A41         MOV     R2,#0x41
   \   00007D   7B00         MOV     R3,#0x0
   \   00007F   12....       LCALL   `??nwkCreateDuplicateNV::?relay`; Banked call to: nwkCreateDuplicateNV
   \   000082   E9           MOV     A,R1
   \   000083   F8           MOV     R0,A
   \   000084   88..         MOV     ?V2,R0
   \   000086   7025         JNZ     ??BindUpgradeTableInNV_3
   1222              {
   1223                // Delete the original NV item once the duplicate is ready
   1224                if ( osal_nv_delete( ZCD_NV_BINDING_TABLE, bindLen ) != ZSuccess )
   \   000088                ; Setup parameters for call to function osal_nv_delete
   \   000088   EE           MOV     A,R6
   \   000089   FC           MOV     R4,A
   \   00008A   EF           MOV     A,R7
   \   00008B   FD           MOV     R5,A
   \   00008C   7A41         MOV     R2,#0x41
   \   00008E   7B00         MOV     R3,#0x0
   \   000090   12....       LCALL   `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   \   000093   E9           MOV     A,R1
   \   000094   6009         JZ      ??BindUpgradeTableInNV_5
   1225                {
   1226                  status = ZFailure;
   \   000096   75..01       MOV     ?V2,#0x1
   \   000099   8012         SJMP    ??BindUpgradeTableInNV_3
   1227                }
   1228                else
   1229                {
   1230                  duplicateReady = TRUE;
   1231                }
   1232              }
   1233            }
   1234            else if ( ( ( dupLen > 0 ) && ( bindLen == 0 ) ) ||
   1235                      ( ( dupLen > 0 ) && ( bindLen > 0 ) && ( hdr.numRecs == 0 ) ) )
   1236            {
   1237              // If for some reason a duplicate NV item was left in the system from a
   1238              // previous upgrade process and:
   1239              // 1) The original Binding NV item DOES NOT exist OR
   1240              // 2) The original Binding NV item exist, but has no valid records.
   1241              // it is necessary to rely in the data in the Duplicate item to create
   1242              // the Binding table
   1243              bindLen = dupLen;
   \                     ??BindUpgradeTableInNV_4:
   \   00009B   E8           MOV     A,R0
   \   00009C   FE           MOV     R6,A
   \   00009D   E9           MOV     A,R1
   \   00009E   FF           MOV     R7,A
   1244          
   1245              duplicateReady = TRUE;
   1246            }
   1247          
   1248            if ( duplicateReady == TRUE )
   1249            {
   1250              // Creates the New Binding table, Copy data from backup and Delete backup NV ID
   1251              status = BindCopyBackupToNewNV( bindLen, newLen );
   \                     ??BindUpgradeTableInNV_5:
   \   00009F                ; Setup parameters for call to function BindCopyBackupToNewNV
   \   00009F   AC..         MOV     R4,?V0
   \   0000A1   AD..         MOV     R5,?V1
   \   0000A3   EE           MOV     A,R6
   \   0000A4   FA           MOV     R2,A
   \   0000A5   EF           MOV     A,R7
   \   0000A6   FB           MOV     R3,A
   \   0000A7   12....       LCALL   `??BindCopyBackupToNewNV::?relay`; Banked call to: BindCopyBackupToNewNV
   \   0000AA   E9           MOV     A,R1
   \   0000AB   F5..         MOV     ?V2,A
   1252            }
   1253            return ( status );
   \                     ??BindUpgradeTableInNV_3:
   \   0000AD   A9..         MOV     R1,?V2
   \   0000AF   02....       LJMP    ?Subroutine5 & 0xFFFF
   1254          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine39_0
   \   000006                ; // Fall through to label ??Subroutine39_0
   1255          #endif // !DONT_UPGRADE_BIND
   1256          
   1257          /*********************************************************************
   1258           * @fn          BindRestoreFromNV
   1259           *
   1260           * @brief       Restore the binding table from NV
   1261           *
   1262           * @param       none
   1263           *
   1264           * @return      Number of entries restored
   1265           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1266          uint16 BindRestoreFromNV( void )
   \                     BindRestoreFromNV:
   1267          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1268            nvBindingHdr_t hdr;
   1269          
   1270            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   1271          
   1272          #if !defined ( DONT_UPGRADE_BIND )
   1273            if ( BindUpgradeTableInNV() == ZSuccess )
   \   000014                ; Setup parameters for call to function BindUpgradeTableInNV
   \   000014   12....       LCALL   `??BindUpgradeTableInNV::?relay`; Banked call to: BindUpgradeTableInNV
   \   000017   E9           MOV     A,R1
   \   000018   6003         JZ      $+5
   \   00001A   02....       LJMP    ??BindRestoreFromNV_0 & 0xFFFF
   1274          #endif
   1275            {
   1276              if ( osal_nv_read( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr ) == ZSuccess )
   \   00001D                ; Setup parameters for call to function osal_nv_read
   \   00001D   A8..         MOV     R0,?XSP + 0
   \   00001F   A9..         MOV     R1,?XSP + 1
   \   000021   88..         MOV     ?V0,R0
   \   000023   89..         MOV     ?V1,R1
   \   000025   78..         MOV     R0,#?V0
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   75..02       MOV     ?V0,#0x2
   \   00002D   75..00       MOV     ?V1,#0x0
   \   000030   78..         MOV     R0,#?V0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   7C00         MOV     R4,#0x0
   \   000037   7D00         MOV     R5,#0x0
   \   000039   7A41         MOV     R2,#0x41
   \   00003B   7B00         MOV     R3,#0x0
   \   00003D   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000040   7404         MOV     A,#0x4
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   E9           MOV     A,R1
   \   000046   7066         JNZ     ??BindRestoreFromNV_0
   1277              {
   1278                bindTableIndex_t x;
   1279                uint16 validRecsCount = 0;
   \   000048   7E00         MOV     R6,#0x0
   \   00004A   7F00         MOV     R7,#0x0
   1280          
   1281                // Read in the device list
   1282                for ( x = 0; ( x < gNWK_MAX_BINDING_ENTRIES ) && ( validRecsCount < hdr.numRecs ); x++ )
   \   00004C   75..00       MOV     ?V0,#0x0
   \   00004F   8041         SJMP    ??BindRestoreFromNV_1
   1283                {
   1284                  if ( osal_nv_read( ZCD_NV_BINDING_TABLE,
   1285                                     (uint16)(sizeof(nvBindingHdr_t) + (x * NV_BIND_REC_SIZE)),
   1286                                     NV_BIND_REC_SIZE, &BindingTable[x] ) == ZSUCCESS )
   \                     ??BindRestoreFromNV_2:
   \   000051   E5..         MOV     A,?V0
   \   000053   75F00E       MOV     B,#0xe
   \   000056   A4           MUL     AB
   \   000057   F8           MOV     R0,A
   \   000058   A9F0         MOV     R1,B
   \   00005A   74..         MOV     A,#BindingTable & 0xff
   \   00005C   28           ADD     A,R0
   \   00005D   F5..         MOV     ?V2,A
   \   00005F   74..         MOV     A,#(BindingTable >> 8) & 0xff
   \   000061   39           ADDC    A,R1
   \   000062   F5..         MOV     ?V3,A
   \   000064                ; Setup parameters for call to function osal_nv_read
   \   000064   78..         MOV     R0,#?V2
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000069   90....       MOV     DPTR,#gBIND_REC_SIZE
   \   00006C   12....       LCALL   ?PUSH_XSTACK8_C_TWO
   \   00006F   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000072   7A41         MOV     R2,#0x41
   \   000074   7B00         MOV     R3,#0x0
   \   000076   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000079   7404         MOV     A,#0x4
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007E   E9           MOV     A,R1
   \   00007F   700F         JNZ     ??BindRestoreFromNV_3
   1287                  {
   1288                    if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \   000081   85..82       MOV     DPL,?V2
   \   000084   85..83       MOV     DPH,?V3
   \   000087   E0           MOVX    A,@DPTR
   \   000088   F4           CPL     A
   \   000089   6005         JZ      ??BindRestoreFromNV_3
   1289                    {
   1290                      validRecsCount++;
   \   00008B   0E           INC     R6
   \   00008C   EE           MOV     A,R6
   \   00008D   7001         JNZ     ??BindRestoreFromNV_3
   \   00008F   0F           INC     R7
   1291                    }
   1292                  }
   1293                }
   \                     ??BindRestoreFromNV_3:
   \   000090   05..         INC     ?V0
   \                     ??BindRestoreFromNV_1:
   \   000092   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000095   E4           CLR     A
   \   000096   93           MOVC    A,@A+DPTR
   \   000097   F8           MOV     R0,A
   \   000098   E5..         MOV     A,?V0
   \   00009A   C3           CLR     C
   \   00009B   98           SUBB    A,R0
   \   00009C   5010         JNC     ??BindRestoreFromNV_0
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   12....       LCALL   ?Subroutine20 & 0xFFFF
   1294              }
   1295            }
   \                     ??CrossCallReturnLabel_28:
   \   0000A7   C3           CLR     C
   \   0000A8   EE           MOV     A,R6
   \   0000A9   98           SUBB    A,R0
   \   0000AA   EF           MOV     A,R7
   \   0000AB   99           SUBB    A,R1
   \   0000AC   40A3         JC      ??BindRestoreFromNV_2
   1296            return ( hdr.numRecs );
   \                     ??BindRestoreFromNV_0:
   \   0000AE   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0000B1   02....       LJMP    ?Subroutine5 & 0xFFFF
   1297          }
   1298          
   1299          /*********************************************************************
   1300           * @fn          BindWriteNV
   1301           *
   1302           * @brief       Save the Binding Table in NV
   1303           *
   1304           * @param       none
   1305           *
   1306           * @return      none
   1307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1308          void BindWriteNV( void )
   \                     BindWriteNV:
   1309          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1310            BindingEntry_t *pBind;
   1311            BindingEntry_t bind;
   1312            nvBindingHdr_t hdr;
   1313            bindTableIndex_t x;
   1314          
   1315            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   1316          
   1317            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000014   7E00         MOV     R6,#0x0
   \   000016   8075         SJMP    ??BindWriteNV_0
   1318            {
   1319              pBind = &BindingTable[x];
   \                     ??BindWriteNV_1:
   \   000018   EE           MOV     A,R6
   \   000019   75F00E       MOV     B,#0xe
   \   00001C   A4           MUL     AB
   \   00001D   F8           MOV     R0,A
   \   00001E   A9F0         MOV     R1,B
   \   000020   74..         MOV     A,#BindingTable & 0xff
   \   000022   28           ADD     A,R0
   \   000023   F5..         MOV     ?V0,A
   \   000025   74..         MOV     A,#(BindingTable >> 8) & 0xff
   \   000027   39           ADDC    A,R1
   \   000028   F5..         MOV     ?V1,A
   1320          
   1321              osal_memcpy( &bind, pBind, gBIND_REC_SIZE );
   \   00002A                ; Setup parameters for call to function osal_memcpy
   \   00002A   85....       MOV     ?V4,?V0
   \   00002D   F5..         MOV     ?V5,A
   \   00002F   75..00       MOV     ?V6,#0x0
   \   000032   78..         MOV     R0,#?V4
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000037   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00003A   7405         MOV     A,#0x5
   \   00003C   12....       LCALL   ?XSTACK_DISP101_8
   \   00003F   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000042   7403         MOV     A,#0x3
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
   1322          
   1323              // Save the record to NV
   1324              osal_nv_write( ZCD_NV_BINDING_TABLE,
   1325                             (uint16)((sizeof(nvBindingHdr_t)) + (x * NV_BIND_REC_SIZE)),
   1326                             NV_BIND_REC_SIZE, &bind );
   \   000047                ; Setup parameters for call to function osal_nv_write
   \   000047   7402         MOV     A,#0x2
   \   000049   12....       LCALL   ?XSTACK_DISP100_8
   \   00004C   88..         MOV     ?V2,R0
   \   00004E   89..         MOV     ?V3,R1
   \   000050   78..         MOV     R0,#?V2
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   90....       MOV     DPTR,#gBIND_REC_SIZE
   \   000058   12....       LCALL   ?PUSH_XSTACK8_C_TWO
   \   00005B   EE           MOV     A,R6
   \   00005C   F8           MOV     R0,A
   \   00005D   90....       MOV     DPTR,#gBIND_REC_SIZE
   \   000060   E4           CLR     A
   \   000061   93           MOVC    A,@A+DPTR
   \   000062   F5..         MOV     ?V2,A
   \   000064   7401         MOV     A,#0x1
   \   000066   93           MOVC    A,@A+DPTR
   \   000067   F5..         MOV     ?V3,A
   \   000069   E8           MOV     A,R0
   \   00006A   85..F0       MOV     B,?V2
   \   00006D   A4           MUL     AB
   \   00006E   C8           XCH     A,R0
   \   00006F   AAF0         MOV     R2,B
   \   000071   85..F0       MOV     B,?V3
   \   000074   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000077   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   1327          
   1328              if ( pBind->srcEP != NV_BIND_EMPTY )
   \   00007F   85..82       MOV     DPL,?V0
   \   000082   85..83       MOV     DPH,?V1
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F4           CPL     A
   \   000087   6003         JZ      ??CrossCallReturnLabel_32
   1329              {
   1330                hdr.numRecs++;
   \   000089   12....       LCALL   ?Subroutine23 & 0xFFFF
   1331              }
   1332            }
   \                     ??CrossCallReturnLabel_32:
   \   00008C   0E           INC     R6
   \                     ??BindWriteNV_0:
   \   00008D   90....       MOV     DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000090   E4           CLR     A
   \   000091   93           MOVC    A,@A+DPTR
   \   000092   F8           MOV     R0,A
   \   000093   EE           MOV     A,R6
   \   000094   C3           CLR     C
   \   000095   98           SUBB    A,R0
   \   000096   4080         JC      ??BindWriteNV_1
   1333          
   1334            // Save off the header
   1335            osal_nv_write( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr );
   \   000098                ; Setup parameters for call to function osal_nv_write
   \   000098   A8..         MOV     R0,?XSP + 0
   \   00009A   A9..         MOV     R1,?XSP + 1
   \   00009C   88..         MOV     ?V0,R0
   \   00009E   89..         MOV     ?V1,R1
   \   0000A0   78..         MOV     R0,#?V0
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A5   75..02       MOV     ?V0,#0x2
   \   0000A8   75..00       MOV     ?V1,#0x0
   \   0000AB   78..         MOV     R0,#?V0
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B0   7C00         MOV     R4,#0x0
   \   0000B2   7D00         MOV     R5,#0x0
   \   0000B4   7A41         MOV     R2,#0x41
   \   0000B6   7B00         MOV     R3,#0x0
   \   0000B8   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000BB   7404         MOV     A,#0x4
   \   0000BD   12....       LCALL   ?DEALLOC_XSTACK8
   1336          }
   \   0000C0   7410         MOV     A,#0x10
   \   0000C2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C5   7F07         MOV     R7,#0x7
   \   0000C7   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??InitBindingTable::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    InitBindingTable

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindFindEmpty::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindFindEmpty

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindNumOfEntries::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindNumOfEntries

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindCapacity::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindCapacity

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindRemoveEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindRemoveEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindIsClusterIDinList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindIsClusterIDinList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindRemoveClusterIdFromList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindRemoveClusterIdFromList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddClusterIdToList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddClusterIdToList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindFindExisting::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindFindExisting

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindRemoveDev::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindRemoveDev

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindRemoveSrcDev::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindRemoveSrcDev

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindNumBoundTo::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindNumBoundTo

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindNumReflections::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindNumReflections

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindFind::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindFind

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddressClear::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddressClear

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindUpdateAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindUpdateAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindingAddrMgsHelperFind::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindingAddrMgsHelperFind

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindingAddrMgsHelperConvert::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindingAddrMgsHelperConvert

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindingAddrMgsHelperConvertShort::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindingAddrMgsHelperConvertShort

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddrMgrLocalLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddrMgrLocalLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddrIndexGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddrIndexGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??GetBindingTableEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GetBindingTableEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindInitNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindSetDefaultNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindCopyBackupToNewNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindCopyBackupToNewNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindUpgradeTableInNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindUpgradeTableInNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindRestoreFromNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindWriteNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindWriteNV
   1337          
   1338          #else // !BINDINGTABLE_NV_SINGLES
   1339          /*********************************************************************
   1340           * @fn          BindInitNV
   1341           *
   1342           * @brief       Initialize the Binding NV Item
   1343           *
   1344           * @param       none
   1345           *
   1346           * @return      ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1347           *              exist in NV, NV_OPER_FAILED if failure.
   1348           */
   1349          byte BindInitNV( void )
   1350          {
   1351            bindTableIndex_t x;
   1352          
   1353            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1354            {
   1355              // Initialize each binding record
   1356              osal_nv_item_init_ex( ZCD_NV_EX_BINDING_TABLE, x, NV_BIND_REC_SIZE, NULL );
   1357            }
   1358            return ( ZSUCCESS );
   1359          }
   1360          
   1361          /*********************************************************************
   1362           * @fn          BindSetDefaultNV
   1363           *
   1364           * @brief       Write the defaults to NV
   1365           *
   1366           * @param       none
   1367           *
   1368           * @return      none
   1369           */
   1370          void BindSetDefaultNV( void )
   1371          {
   1372            BindingEntry_t bind;
   1373            bindTableIndex_t x;
   1374          
   1375            // Initialize a binding record
   1376            osal_memset( &bind, 0xFF, sizeof ( BindingEntry_t ) );
   1377          
   1378            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1379            {
   1380              // Over write each binding record with an "empty" record
   1381              osal_nv_write_ex( ZCD_NV_EX_BINDING_TABLE, x, 0, NV_BIND_REC_SIZE, &bind );
   1382            }
   1383          }
   1384          
   1385          /*********************************************************************
   1386           * @fn          BindRestoreFromNV
   1387           *
   1388           * @brief       Restore the binding table from NV
   1389           *
   1390           * @param       none
   1391           *
   1392           * @return      Number of entries restored (non-emtpy)
   1393           */
   1394          uint16 BindRestoreFromNV( void )
   1395          {
   1396            bindTableIndex_t x;
   1397            uint16 validRecsCount = 0;
   1398          
   1399            // Read in the device list
   1400            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1401            {
   1402              if ( osal_nv_read_ex( ZCD_NV_EX_BINDING_TABLE, x, 0,
   1403                               (uint16)NV_BIND_REC_SIZE, &BindingTable[x] ) == ZSUCCESS )
   1404              {
   1405                // Check for non-empty record
   1406                if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   1407                {
   1408                  // Count non-empty records
   1409                  validRecsCount++;
   1410                }
   1411              }
   1412            }
   1413            return ( validRecsCount );
   1414          }
   1415          
   1416          /*********************************************************************
   1417           * @fn          BindWriteNV
   1418           *
   1419           * @brief       Copy the Binding Table in NV
   1420           *
   1421           * @param       none
   1422           *
   1423           * @return      none
   1424           */
   1425          void BindWriteNV( void )
   1426          {
   1427            bindTableIndex_t x;
   1428          
   1429            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1430            {
   1431              // Save the record to NV
   1432              osal_nv_write_ex( ZCD_NV_EX_BINDING_TABLE, x, 0,
   1433                               (uint16)NV_BIND_REC_SIZE, &BindingTable[x] );
   1434            }
   1435          }
   1436          #endif // BINDINGTABLE_NV_SINGLES
   1437          
   1438          /*********************************************************************
   1439          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     52   BindCopyBackupToNewNV
        0     32   -> osal_nv_delete
        0     34   -> osal_nv_item_init
        0     32   -> osal_nv_item_len
        0     36   -> osal_nv_read
        0     36   -> osal_nv_write
      0     12   BindInitNV
        0     10   -> BindSetDefaultNV
        0     12   -> osal_nv_item_init
      0     20   BindRestoreFromNV
        0     16   -> BindUpgradeTableInNV
        0     20   -> osal_nv_read
      0     26   BindSetDefaultNV
        0     16   -> osal_nv_write
      0     36   BindUpgradeTableInNV
        0     16   -> BindCopyBackupToNewNV
        0     16   -> nwkCreateDuplicateNV
        0     16   -> osal_nv_delete
        0     16   -> osal_nv_item_len
        0     20   -> osal_nv_read
      0     35   BindWriteNV
        0     34   -> osal_memcpy
        0     35   -> osal_nv_write
      0      9   GetBindingTableEntry
      0     10   InitBindingTable
        0     10   -> osal_memset
      0     29   bindAddClusterIdToList
      1     25   bindAddEntry
        0     20   -> bindAddClusterIdToList
        0     20   -> bindAddrIndexGet
        0     20   -> bindAddrMgrLocalLoad
        0     20   -> bindFindEmpty
        0     20   -> bindIsClusterIDinList
        0     23   -> osal_memcpy
      2     33   bindAddrIndexGet
        2     13   -> AddrMgrEntryLookupExt
        2     13   -> AddrMgrEntryLookupNwk
        2     13   -> AddrMgrEntryUpdate
        2     13   -> AddrMgrExtAddrSet
      0     43   bindAddrMgrLocalLoad
        0     23   -> AddrMgrEntryUpdate
        0     23   -> AddrMgrExtAddrSet
        0     23   -> NLME_GetCoordExtAddr
        0     23   -> NLME_GetCoordShortAddr
        0     23   -> NLME_GetExtAddr
      2     25   bindAddressClear
        2     13   -> AddrMgrEntryRelease
      0      9   bindCapacity
      0     14   bindFind
        0     14   -> bindIsClusterIDinList
      2     20   bindFindEmpty
      0     13   bindFindExisting
        0     13   -> bindingAddrMgsHelperFind
      0     29   bindIsClusterIDinList
      0     14   bindNumBoundTo
        0     14   -> bindingAddrMgsHelperFind
      2      0   bindNumOfEntries
      0     12   bindNumReflections
        0     12   -> bindIsClusterIDinList
      0     13   bindRemoveClusterIdFromList
      0     12   bindRemoveDev
        0     12   -> bindAddressClear
        0     12   -> bindRemoveEntry
        0     12   -> bindingAddrMgsHelperFind
      2     12   bindRemoveEntry
        2      0   -> osal_memset
      0     10   bindRemoveSrcDev
        0     10   -> bindAddressClear
        0     10   -> bindRemoveEntry
      0     21   bindUpdateAddr
        0     21   -> bindingAddrMgsHelperFind
      0     22   bindingAddrMgsHelperConvert
        0     22   -> AddrMgrEntryGet
        0     22   -> sAddrExtCpy
      2     13   bindingAddrMgsHelperConvertShort
        2     13   -> AddrMgrEntryGet
      2     34   bindingAddrMgsHelperFind
        2     13   -> AddrMgrEntryLookupExt
        2     13   -> AddrMgrEntryLookupNwk
        2     13   -> AddrMgrExtAddrSet


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ??Subroutine29_0
       5  ??Subroutine30_0
      16  ??Subroutine31_0
       6  ??Subroutine32_0
       5  ??Subroutine33_0
       7  ??Subroutine34_0
       8  ??Subroutine35_0
       9  ??Subroutine36_0
       3  ??Subroutine37_0
       5  ??Subroutine38_0
       6  ??Subroutine39_0
       3  ?Subroutine0
       2  ?Subroutine1
      21  ?Subroutine10
      22  ?Subroutine11
      11  ?Subroutine12
      11  ?Subroutine13
       1  ?Subroutine14
      10  ?Subroutine15
      23  ?Subroutine16
      10  ?Subroutine17
       6  ?Subroutine18
       4  ?Subroutine19
       5  ?Subroutine2
       6  ?Subroutine20
      10  ?Subroutine21
       6  ?Subroutine22
      16  ?Subroutine23
       9  ?Subroutine24
      26  ?Subroutine25
      19  ?Subroutine26
      12  ?Subroutine27
      14  ?Subroutine28
       5  ?Subroutine3
       5  ?Subroutine4
       2  ?Subroutine5
      36  ?Subroutine6
      14  ?Subroutine7
      11  ?Subroutine8
       6  ?Subroutine9
     386  BindCopyBackupToNewNV
       6  BindCopyBackupToNewNV::?relay
      41  BindInitNV
       6  BindInitNV::?relay
     180  BindRestoreFromNV
       6  BindRestoreFromNV::?relay
      65  BindSetDefaultNV
       6  BindSetDefaultNV::?relay
     178  BindUpgradeTableInNV
       6  BindUpgradeTableInNV::?relay
     202  BindWriteNV
       6  BindWriteNV::?relay
      56  GetBindingTableEntry
       6  GetBindingTableEntry::?relay
     116  InitBindingTable
       6  InitBindingTable::?relay
      48  bindAddClusterIdToList
       6  bindAddClusterIdToList::?relay
     343  bindAddEntry
       6  bindAddEntry::?relay
     112  bindAddrIndexGet
       6  bindAddrIndexGet::?relay
     144  bindAddrMgrLocalLoad
       6  bindAddrMgrLocalLoad::?relay
       1  bindAddrMgrLocalLoaded
      95  bindAddressClear
       6  bindAddressClear::?relay
      51  bindCapacity
       6  bindCapacity::?relay
      80  bindFind
       6  bindFind::?relay
      46  bindFindEmpty
       6  bindFindEmpty::?relay
     144  bindFindExisting
       6  bindFindExisting::?relay
      54  bindIsClusterIDinList
       6  bindIsClusterIDinList::?relay
     135  bindNumBoundTo
       6  bindNumBoundTo::?relay
      53  bindNumOfEntries
       6  bindNumOfEntries::?relay
      69  bindNumReflections
       6  bindNumReflections::?relay
     116  bindRemoveClusterIdFromList
       6  bindRemoveClusterIdFromList::?relay
     138  bindRemoveDev
       6  bindRemoveDev::?relay
      17  bindRemoveEntry
       6  bindRemoveEntry::?relay
      82  bindRemoveSrcDev
       6  bindRemoveSrcDev::?relay
     118  bindUpdateAddr
       6  bindUpdateAddr::?relay
      78  bindingAddrMgsHelperConvert
       6  bindingAddrMgsHelperConvert::?relay
      34  bindingAddrMgsHelperConvertShort
       6  bindingAddrMgsHelperConvertShort::?relay
      56  bindingAddrMgsHelperFind
       6  bindingAddrMgsHelperFind::?relay
       2  pBindInitNV
       2  pBindRestoreFromNV
       2  pBindSetDefaultNV
       2  pBindWriteNV
       2  pbindAddEntry
       2  pbindNumOfEntries
       2  pbindRemoveDev

 
 3 638 bytes in segment BANKED_CODE
   174 bytes in segment BANK_RELAYS
    15 bytes in segment XDATA_Z
 
 3 812 bytes of CODE  memory
    15 bytes of XDATA memory

Errors: none
Warnings: none
