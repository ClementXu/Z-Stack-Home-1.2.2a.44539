###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                28/Aug/2016  20:48:31
# Copyright 2004-2015 IAR Systems AB.
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Components\stack\zcl\zcl.c
#    Command line       =  
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Components\stack\zcl\zcl.c" -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D HOLD_AUTO_START -D
#        BUILD_ALL_DEVICES -D HAL_UART=TRUE -D xZTOOL_P1 -D xMT_TASK -D
#        xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG
#        -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D
#        ZCL_EZMODE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF -D ZCL_SCENES -D
#        ZCL_GROUPS -D xZCL_LEVEL_CTRL -D ZCL_DIAGNOSTIC -D
#        FEATURE_SYSTEM_STATS -D DEVICE_LOGICAL_TYPE=ZG_DEVICETYPE_COORDINATOR
#        -lC "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\List"
#        -lA "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz
#    List file          =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\List\zcl.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\Zigbee-HomeAutomatic\CC2530DB\CoordinatorEB\Obj\zcl.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.2a.44539\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2015-09-09 11:51:49 -0700 (Wed, 09 Sep 2015) $
      4            Revision:       $Revision: 44489 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          
     53          /*********************************************************************
     54           * MACROS
     55           */
     56          /*** Frame Control ***/
     57          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     58          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     59          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     60          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     61          
     62          /*** Attribute Access Control ***/
     63          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     64          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     65          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     66          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     67          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     68          
     69          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     70          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     71          
     72          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     73                                                  (zclHdr).fc.manuSpecific == 0          && \
     74                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     75          
     76          // Commands that have corresponding responses
     77          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     78                                                  (cmd) == ZCL_CMD_WRITE                  || \
     79                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     80                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     81                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     82                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     83                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     84                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87          #define  ZCL_VALID_MIN_HEADER_LEN  3
     88          
     89          /*********************************************************************
     90           * CONSTANTS
     91           */
     92          
     93          /*********************************************************************
     94           * TYPEDEFS
     95           */
     96          typedef struct zclLibPlugin
     97          {
     98            struct zclLibPlugin *next;
     99            uint16              startClusterID;    // starting cluster ID
    100            uint16              endClusterID;      // ending cluster ID
    101            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    102          } zclLibPlugin_t;
    103          
    104          // Command record list
    105          typedef struct zclCmdRecsList
    106          {
    107            struct zclCmdRecsList *pNext;
    108            uint8                 endpoint;
    109            uint8                 numCommands;
    110            CONST zclCommandRec_t *pCmdRecs;
    111          } zclCmdRecsList_t;
    112          
    113          // Attribute record list item
    114          typedef struct zclAttrRecsList
    115          {
    116            struct zclAttrRecsList *next;
    117            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    118            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    119            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    120            uint8                  numAttributes; // Number of the following records
    121            CONST zclAttrRec_t     *attrs;        // attribute records
    122          } zclAttrRecsList;
    123          
    124          // Cluster option list item
    125          typedef struct zclClusterOptionList
    126          {
    127            struct zclClusterOptionList *next;
    128            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    129            uint8                       numOptions; // Number of the following records
    130            zclOptionRec_t              *options;   // option records
    131          } zclClusterOptionList;
    132          
    133          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    134          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    135          
    136          typedef struct
    137          {
    138            zclParseInProfileCmd_t   pfnParseInProfile;
    139            zclProcessInProfileCmd_t pfnProcessInProfile;
    140          } zclCmdItems_t;
    141          
    142          
    143          // List record for external handler for unhandled ZCL Foundation commands/rsps
    144          typedef struct zclExternalFoundationHandlerList
    145          {
    146              struct zclExternalFoundationHandlerList *next;
    147              uint8 zcl_ExternalTaskID;
    148              uint8 zcl_ExternalEndPoint;
    149          } zclExternalFoundationHandlerList;
    150          
    151          
    152          /*********************************************************************
    153           * GLOBAL VARIABLES
    154           */
    155          
    156          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    158          #endif
    159          
    160          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    161          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    162          
    163          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    164          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    165          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    166          uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    167          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    168          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    169          
    170          /*********************************************************************
    171           * EXTERNAL VARIABLES
    172           */
    173          
    174          /*********************************************************************
    175           * EXTERNAL FUNCTIONS
    176           */
    177          
    178          /*********************************************************************
    179           * LOCAL VARIABLES
    180           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    181          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    182          
    183          #if defined ( ZCL_DISCOVER )
    184            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    185          #endif
    186          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    187          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    189          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    190          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    191          
    192          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    193          static zclExternalFoundationHandlerList *externalEndPointHandlerList = (zclExternalFoundationHandlerList *)NULL;
   \                     externalEndPointHandlerList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    194          #endif
    195          
    196          /*********************************************************************
    197           * LOCAL FUNCTIONS
    198           */
    199          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    200          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    201          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    202          
    203          #if !defined ( ZCL_STANDALONE )
    204          static uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId );
    205          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg );
    206          #endif // !defined ( ZCL_STANDALONE )
    207          
    208          #if defined ( ZCL_DISCOVER )
    209            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    210          #endif
    211          
    212          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    213          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    214          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    215          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    216          
    217          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    218          
    219          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    220          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    221          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    222          #endif // ZCL_READ || ZCL_WRITE
    223          
    224          #ifdef ZCL_READ
    225          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    226          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    227          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    228                                                   uint8 *pAttrData, uint16 *pDataLen );
    229          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    230          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    231          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    232          #endif // ZCL_READ
    233          
    234          #ifdef ZCL_WRITE
    235          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    236                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    237          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    238                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    239          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    240          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    241          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    242          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    243          #endif // ZCL_WRITE
    244          
    245          #ifdef ZCL_REPORT
    246          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    247          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    248          #endif // ZCL_REPORT
    249          
    250          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    251          
    252          #ifdef ZCL_DISCOVER
    253          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    254          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    255          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    256          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    257          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    258          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    259          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    260          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    261          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    262          #endif // ZCL_DISCOVER
    263          
    264          /*********************************************************************
    265           * Parse Profile Command Function Table
    266           */
    267          

   \                                 In  segment CODE_C, align 1
    268          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW `??zclParseInReadCmd::?relay`
   \   000002   ....         DW `??zclProcessInReadCmd::?relay`
   \   000004   ....         DW `??zclParseInReadRspCmd::?relay`
   \   000006   ....         DW `??zcl_HandleExternal::?relay`
   \   000008   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000A   ....         DW `??zclProcessInWriteCmd::?relay`
   \   00000C   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000E   ....         DW `??zclProcessInWriteUndividedCmd::?relay`
   \   000010   ....         DW `??zclParseInWriteRspCmd::?relay`
   \   000012   ....         DW `??zcl_HandleExternal::?relay`
   \   000014   ....         DW `??zclParseInWriteCmd::?relay`
   \   000016   ....         DW `??zclProcessInWriteCmd::?relay`
   \   000018   ....         DW `??zclParseInConfigReportCmd::?relay`
   \   00001A   ....         DW `??zcl_HandleExternal::?relay`
   \   00001C   ....         DW `??zclParseInConfigReportRspCmd::?relay`
   \   00001E   ....         DW `??zcl_HandleExternal::?relay`
   \   000020   ....         DW `??zclParseInReadReportCfgCmd::?relay`
   \   000022   ....         DW `??zcl_HandleExternal::?relay`
   \   000024   ....         DW `??zclParseInReadReportCfgRspCmd::?relay`
   \   000026   ....         DW `??zcl_HandleExternal::?relay`
   \   000028   ....         DW `??zclParseInReportCmd::?relay`
   \   00002A   ....         DW `??zcl_HandleExternal::?relay`
   \   00002C   ....         DW `??zclParseInDefaultRspCmd::?relay`
   \   00002E   ....         DW `??zcl_HandleExternal::?relay`
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    269          {
    270          #ifdef ZCL_READ
    271            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    272            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    273          #else
    274            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    275            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    276          #endif // ZCL_READ
    277          
    278          #ifdef ZCL_WRITE
    279            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    280            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    281            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    282            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    283          #else
    284            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    285            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    287            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    288          #endif // ZCL_WRITE
    289          
    290          #ifdef ZCL_REPORT
    291            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    292            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    293            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    294            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    295            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    296          #else
    297            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    298            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    299            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    300            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    301            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    302          #endif // ZCL_REPORT
    303          
    304            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    305          
    306          #ifdef ZCL_DISCOVER
    307            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    308            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    309            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    310            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    311            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    312            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    313            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    314            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    315            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    316            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    317            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    318          #else
    319            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    320            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    321            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    322            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    323            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    324            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    325            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    326            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    327            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    328            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    329            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    330          #endif // ZCL_DISCOVER
    331          };
    332          
    333          /*********************************************************************
    334           * PUBLIC FUNCTIONS
    335           *********************************************************************/
    336          
    337          #if !defined ( ZCL_STANDALONE )
    338          /*********************************************************************
    339           * @fn          zcl_Init
    340           *
    341           * @brief       Initialization function for the zcl layer.
    342           *
    343           * @param       task_id - ZCL task id
    344           *
    345           * @return      none
    346           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    347          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    348          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    349            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    350          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    351          #endif
    352          
    353          #if !defined ( ZCL_STANDALONE )
    354          /*********************************************************************
    355           * @fn          zcl_event_loop
    356           *
    357           * @brief       Event Loop Processor for zcl.
    358           *
    359           * @param       task_id - task id
    360           * @param       events - event bitmap
    361           *
    362           * @return      unprocessed events
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    365          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
    366            uint8 *msgPtr;
    367          
    368            (void)task_id;  // Intentionally unreferenced parameter
    369          
    370            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   604D         JZ      ??zcl_event_loop_0
    371            {
    372              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    373              while ( msgPtr != NULL )
    374              {
    375                uint8 dealloc = TRUE;
    376          
    377                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    378                {
    379                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   `??zcl_ProcessMessageMSG::?relay`; Banked call to: zcl_ProcessMessageMSG
    380                }
    381                else
    382                {
    383                  uint8 taskID;
    384                  taskID = zcl_getExternalFoundationHandler( (afIncomingMSGPacket_t *)msgPtr );
    385          
    386                  if ( taskID != TASK_NO_TASK )
    387                  {
    388                    // send it to another task to process.
    389                    osal_msg_send( taskID, msgPtr );
    390                    dealloc = FALSE;
    391                  }
    392                }
    393          
    394                // Release the memory
    395                if ( dealloc )
    396                {
    397                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    398                }
    399          
    400                // Next
    401                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   6020         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   00003B   EE           MOV     A,R6
   \   00003C   FA           MOV     R2,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000042   E9           MOV     A,R1
   \   000043   F9           MOV     R1,A
   \   000044   74FF         MOV     A,#-0x1
   \   000046   69           XRL     A,R1
   \   000047   60CE         JZ      ??zcl_event_loop_3
   \   000049                ; Setup parameters for call to function osal_msg_send
   \   000049   EE           MOV     A,R6
   \   00004A   FA           MOV     R2,A
   \   00004B   EF           MOV     A,R7
   \   00004C   FB           MOV     R3,A
   \   00004D   12....       LCALL   `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   000050   80CC         SJMP    ??zcl_event_loop_1
    402              }
    403          
    404              // return unprocessed events
    405              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   000052   AA..         MOV     R2,?V0
   \   000054   E5..         MOV     A,?V1
   \   000056   6480         XRL     A,#0x80
   \   000058   FB           MOV     R3,A
   \   000059   8004         SJMP    ??zcl_event_loop_5
    406            }
    407          
    408            // Discard unknown events
    409            return 0;
   \                     ??zcl_event_loop_0:
   \   00005B   7A00         MOV     R2,#0x0
   \   00005D   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005F   02....       LJMP    ?Subroutine1 & 0xFFFF
    410          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    411          #endif
    412          
    413          #if !defined ( ZCL_STANDALONE )
    414          /*********************************************************************
    415           * @fn      zcl_registerForMsg
    416           *
    417           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    418           *          messages that aren't processed to one task (if a task is
    419           *          registered).
    420           *
    421           * @param   taskId - task Id of the Application where commands will be sent to
    422           *
    423           * @return  TRUE if task registeration successful, FALSE otherwise
    424           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    425          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    426          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    427            return zcl_addExternalFoundationHandler( taskId, AF_BROADCAST_ENDPOINT );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   7AFF         MOV     R2,#-0x1
   \   000007   02....       LJMP    ?Subroutine2 & 0xFFFF
    428          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   `??zcl_addExternalFoundationHandler::?relay`; Banked call to: zcl_addExternalFoundationHandler
   \   000003                REQUIRE ??Subroutine193_0
   \   000003                ; // Fall through to label ??Subroutine193_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine193_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    429          
    430          /*********************************************************************
    431           * @fn      zcl_registerForMsgExt
    432           *
    433           * @brief   This function enables a Task to register to recieve all
    434           *          incoming Foundation Command/Response messages, for a particular
    435           *          End Point, that aren't processed by ZCL.
    436           *
    437           *          NOTE: Any Task registered for a unique end point will take
    438           *          priority over any Task registered with the AF_BROADCAST_ENDPOINT
    439           *          value.  ie. If task A registers for End Point 1, task B registers
    440           *          for AF_BROADCAST_ENDPOINT,  commands addressed to End Point 1 will be
    441           *          sent to Task A and NOT Task B.
    442           *
    443           * @param   taskId - task Id of the Application where commands will be sent to
    444           * @param   endPointId - end point Id of interest
    445           *
    446           * @return  TRUE if task registeration successful, FALSE otherwise
    447           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    448          uint8 zcl_registerForMsgExt( uint8 taskId, uint8 endPointId  )
   \                     zcl_registerForMsgExt:
    449          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    450            return ( zcl_addExternalFoundationHandler( taskId, endPointId  ) );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   02....       LJMP    ?Subroutine2 & 0xFFFF
    451          }
    452          
    453          /*********************************************************************
    454           * @fn      zcl_addExternalFoundationHandler
    455           *
    456           * @brief   This function adds a record to the internal list of external
    457           *          handlers of unhandled incoming Foundation Command/Response messages.
    458           *
    459           * @param   taskId - task Id of the Application where commands will be sent to
    460           * @param   endPointId - end point Id of interest
    461           *
    462           * @return  TRUE if task registeration successful, FALSE otherwise
    463           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    464          uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId  )
   \                     zcl_addExternalFoundationHandler:
    465          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
    466            zclExternalFoundationHandlerList *pNewItem;
    467            zclExternalFoundationHandlerList *pLoop;
    468            zclExternalFoundationHandlerList *pLoopPrev;
    469          
    470            // Fill in the new endpoint registrant list
    471            pNewItem = zcl_mem_alloc( sizeof( zclExternalFoundationHandlerList ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A04         MOV     R2,#0x4
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   8A..         MOV     ?V0,R2
   \   000012   8B..         MOV     ?V1,R3
   \   000014   A8..         MOV     R0,?V0
   \   000016   A9..         MOV     R1,?V1
    472            if ( pNewItem == NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   6031         JZ      ??zcl_addExternalFoundationHandler_0
    473            {
    474              return ( false );
    475            }
    476          
    477            pNewItem->zcl_ExternalEndPoint = endPointId;
   \   00001C   EF           MOV     A,R7
   \   00001D   8882         MOV     DPL,R0
   \   00001F   8983         MOV     DPH,R1
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
    478            pNewItem->zcl_ExternalTaskID = taskId;
   \   000025   EE           MOV     A,R6
   \   000026   8882         MOV     DPL,R0
   \   000028   8983         MOV     DPH,R1
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   12....       LCALL   ?Subroutine36 & 0xFFFF
    479            pNewItem->next = NULL;
    480          
    481            // Add to the list
    482            if ( externalEndPointHandlerList == NULL )
   \                     ??CrossCallReturnLabel_38:
   \   00002F   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000032   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000035   7009         JNZ     ??zcl_addExternalFoundationHandler_1
    483            {
    484              externalEndPointHandlerList = pNewItem;
   \   000037   90....       MOV     DPTR,#externalEndPointHandlerList
   \   00003A   E8           MOV     A,R0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   E9           MOV     A,R1
   \   00003E   803F         SJMP    ??zcl_addExternalFoundationHandler_2
    485            }
    486            else
    487            {
    488              // make sure no one else tried to register for this endpoint
    489              pLoop = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_1:
   \   000040   E0           MOVX    A,@DPTR
   \   000041   FB           MOV     R3,A
    490              pLoopPrev = externalEndPointHandlerList;
    491          
    492              while ( pLoop != NULL )
    493              {
    494                if ( ( pLoop->zcl_ExternalEndPoint ) == endPointId )
   \                     ??zcl_addExternalFoundationHandler_3:
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6F           XRL     A,R7
   \   00004B   7004         JNZ     ??zcl_addExternalFoundationHandler_4
    495                {
    496                  return ( false );
   \                     ??zcl_addExternalFoundationHandler_0:
   \   00004D   7900         MOV     R1,#0x0
   \   00004F   8031         SJMP    ??zcl_addExternalFoundationHandler_5
    497                }
    498                pLoopPrev = pLoop;
   \                     ??zcl_addExternalFoundationHandler_4:
   \   000051   EA           MOV     A,R2
   \   000052   FC           MOV     R4,A
   \   000053   EB           MOV     A,R3
   \   000054   FD           MOV     R5,A
    499                pLoop = pLoop->next;
   \   000055   8A82         MOV     DPL,R2
   \   000057   8B83         MOV     DPH,R3
   \   000059   12....       LCALL   ??Subroutine176_0 & 0xFFFF
    500              }
   \                     ??CrossCallReturnLabel_299:
   \   00005C   70E4         JNZ     ??zcl_addExternalFoundationHandler_3
    501          
    502              if ( endPointId == AF_BROADCAST_ENDPOINT )
   \   00005E   74FF         MOV     A,#-0x1
   \   000060   6F           XRL     A,R7
   \   000061   700C         JNZ     ??zcl_addExternalFoundationHandler_6
    503              {
    504                // put new registration at the end of the list
    505                pLoopPrev->next = pNewItem;
   \   000063   8C82         MOV     DPL,R4
   \   000065   8D83         MOV     DPH,R5
   \   000067   12....       LCALL   ?Subroutine43 & 0xFFFF
    506                pNewItem->next = NULL;
    507              }
   \                     ??CrossCallReturnLabel_54:
   \   00006A   E4           CLR     A
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   8010         SJMP    ??zcl_addExternalFoundationHandler_2
    508              else
    509              {
    510                // put new registration at the front of the list
    511                zclExternalFoundationHandlerList *temp = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_6:
   \   00006F   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000072   12....       LCALL   ??Subroutine198_0 & 0xFFFF
    512                externalEndPointHandlerList = pNewItem;
   \                     ??CrossCallReturnLabel_380:
   \   000075   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000078   12....       LCALL   ?Subroutine43 & 0xFFFF
    513                pNewItem->next = temp;
    514              }
    515            }
   \                     ??CrossCallReturnLabel_55:
   \   00007B   EA           MOV     A,R2
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   A3           INC     DPTR
   \   00007E   EB           MOV     A,R3
   \                     ??zcl_addExternalFoundationHandler_2:
   \   00007F   F0           MOVX    @DPTR,A
    516          
    517            return ( true );
   \   000080   7901         MOV     R1,#0x1
   \                     ??zcl_addExternalFoundationHandler_5:
   \   000082   02....       LJMP    ?Subroutine3 & 0xFFFF
    518          
    519          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   F0           MOVX    @DPTR,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_402:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine198_0:
   \   000000   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_403:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine199_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    520          
    521          /*********************************************************************
    522           * @fn      zcl_getExternalFoundationHandler
    523           *
    524           * @brief   This function retrieves the Task ID of the task registered
    525           *          to received unhandled incoming Foundation Command/Response messages
    526           *          for a particular End Point ID.
    527           *
    528           * @param   pInMsg - recevied ZCL command
    529           *
    530           * @return  TASK ID of registered task.  If no task is reigistered, it returns
    531           *          TASK_NO_TASK.
    532           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    533          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg )
   \                     zcl_getExternalFoundationHandler:
    534          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    535            zclExternalFoundationHandlerList *pLoop;
    536            uint8 addressedEndPointId = pInMsg->endPoint;
   \   000004   EA           MOV     A,R2
   \   000005   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000008   3B           ADDC    A,R3
   \   000009   F583         MOV     DPH,A
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   FA           MOV     R2,A
    537          
    538            // make sure no one else tried to register for this endpoint
    539            pLoop = externalEndPointHandlerList;
   \   00000D   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000010   8004         SJMP    ??zcl_getExternalFoundationHandler_0
    540          
    541            while ( pLoop != NULL )
    542            {
    543              if ( ( ( pLoop->zcl_ExternalEndPoint ) == addressedEndPointId ) ||
    544                   ( ( pLoop->zcl_ExternalEndPoint ) == AF_BROADCAST_ENDPOINT ) )
    545              {
    546                return ( pLoop->zcl_ExternalTaskID );
    547              }
    548              pLoop = pLoop->next;
   \                     ??zcl_getExternalFoundationHandler_1:
   \   000012   8882         MOV     DPL,R0
   \   000014   8983         MOV     DPH,R1
   \                     ??zcl_getExternalFoundationHandler_0:
   \   000016   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_365:
   \   000019   601C         JZ      ??zcl_getExternalFoundationHandler_2
   \   00001B   8882         MOV     DPL,R0
   \   00001D   8983         MOV     DPH,R1
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FB           MOV     R3,A
   \   000024   EA           MOV     A,R2
   \   000025   6B           XRL     A,R3
   \   000026   6005         JZ      ??zcl_getExternalFoundationHandler_3
   \   000028   74FF         MOV     A,#-0x1
   \   00002A   6B           XRL     A,R3
   \   00002B   70E5         JNZ     ??zcl_getExternalFoundationHandler_1
   \                     ??zcl_getExternalFoundationHandler_3:
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   8002         SJMP    ??zcl_getExternalFoundationHandler_4
    549            }
    550          
    551            return ( TASK_NO_TASK );
   \                     ??zcl_getExternalFoundationHandler_2:
   \   000037   79FF         MOV     R1,#-0x1
   \                     ??zcl_getExternalFoundationHandler_4:
   \   000039   02....       LJMP    ?Subroutine0 & 0xFFFF
    552          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine195_0:
   \   000000   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   000003   49           ORL     A,R1
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine171:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine164:
   \   000000   2414         ADD     A,#0x14
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine154:
   \   000000   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_512:
   \   000003   F9           MOV     R1,A
   \   000004   E8           MOV     A,R0
   \   000005   22           RET
    553          #endif
    554          
    555          #if !defined ( ZCL_STANDALONE )
    556          /*********************************************************************
    557           * @fn      zcl_HandleExternal
    558           *
    559           * @brief
    560           *
    561           * @param   pInMsg - incoming message to process
    562           *
    563           * @return  TRUE
    564           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    565          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    566          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    567            zclIncomingMsg_t *pCmd;
    568            uint8 taskID;
    569          
    570            taskID = zcl_getExternalFoundationHandler( pInMsg->msg );
   \   000009                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   000010   12....       LCALL   `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000013   E9           MOV     A,R1
   \   000014   F5..         MOV     ?V0,A
    571          
    572            if ( taskID == TASK_NO_TASK )
   \   000016   74FF         MOV     A,#-0x1
   \   000018   65..         XRL     A,?V0
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    573            {
    574              return ( TRUE );
    575            }
    576          
    577            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   00001F                ; Setup parameters for call to function osal_msg_allocate
   \   00001F   7A19         MOV     R2,#0x19
   \   000021   7B00         MOV     R3,#0x0
   \   000023   12....       LCALL   `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
    578            if ( pCmd != NULL )
   \   000026   EA           MOV     A,R2
   \   000027   4B           ORL     A,R3
   \   000028   7003         JNZ     $+5
   \   00002A   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    579            {
    580              // fill in the message
    581              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   00002D   8A82         MOV     DPL,R2
   \   00002F   8B83         MOV     DPH,R3
   \   000031   7434         MOV     A,#0x34
   \   000033   12....       LCALL   ?Subroutine39 & 0xFFFF
    582              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_46:
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   EA           MOV     A,R2
   \   000039   2402         ADD     A,#0x2
   \   00003B   FC           MOV     R4,A
   \   00003C   E4           CLR     A
   \   00003D   3B           ADDC    A,R3
   \   00003E   FD           MOV     R5,A
   \   00003F   7406         MOV     A,#0x6
   \   000041   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    583              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   00004B   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_520:
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   EC           MOV     A,R4
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   ED           MOV     A,R5
   \   00005E   12....       LCALL   ?Subroutine31 & 0xFFFF
    584              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_26:
   \   000061   A3           INC     DPTR
   \   000062   EA           MOV     A,R2
   \   000063   240A         ADD     A,#0xa
   \   000065   FC           MOV     R4,A
   \   000066   E4           CLR     A
   \   000067   3B           ADDC    A,R3
   \   000068   FD           MOV     R5,A
   \   000069   740C         MOV     A,#0xc
   \   00006B   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    585              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   00006E   8E82         MOV     DPL,R6
   \   000070   8F83         MOV     DPH,R7
   \   000072   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_508:
   \   000075   C8           XCH     A,R0
   \   000076   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   000079   38           ADDC    A,R0
   \   00007A   F583         MOV     DPH,A
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   C0E0         PUSH    A
   \   00007F   EA           MOV     A,R2
   \   000080   2416         ADD     A,#0x16
   \   000082   F582         MOV     DPL,A
   \   000084   E4           CLR     A
   \   000085   3B           ADDC    A,R3
   \   000086   F583         MOV     DPH,A
   \   000088   D0E0         POP     A
   \   00008A   F0           MOVX    @DPTR,A
    586              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00008B   EE           MOV     A,R6
   \   00008C   240C         ADD     A,#0xc
   \   00008E   F8           MOV     R0,A
   \   00008F   E4           CLR     A
   \   000090   3F           ADDC    A,R7
   \   000091   F9           MOV     R1,A
   \   000092   8882         MOV     DPL,R0
   \   000094   8983         MOV     DPH,R1
   \   000096   12....       LCALL   ??Subroutine220_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_514:
   \   000099   EA           MOV     A,R2
   \   00009A   2417         ADD     A,#0x17
   \   00009C   F582         MOV     DPL,A
   \   00009E   E4           CLR     A
   \   00009F   3B           ADDC    A,R3
   \   0000A0   F583         MOV     DPH,A
   \   0000A2   EC           MOV     A,R4
   \   0000A3   F0           MOVX    @DPTR,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   ED           MOV     A,R5
   \   0000A6   12....       LCALL   ?Subroutine36 & 0xFFFF
    587          
    588              // Application will free the attrCmd buffer
    589              pInMsg->attrCmd = NULL;
    590          
    591              /* send message through task message */
    592              osal_msg_send( taskID, (uint8 *)pCmd );
   \                     ??CrossCallReturnLabel_39:
   \   0000A9                ; Setup parameters for call to function osal_msg_send
   \   0000A9   A9..         MOV     R1,?V0
   \   0000AB   12....       LCALL   `??osal_msg_send::?relay`; Banked call to: osal_msg_send
    593            }
    594          
    595            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000AE   7901         MOV     R1,#0x1
   \   0000B0   02....       LJMP    ?Subroutine1 & 0xFFFF
    596          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine168:
   \   000000   12....       LCALL   ?Subroutine173 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   12....       LCALL   ?Subroutine168 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine173:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_346:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine153:
   \   000000   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_511:
   \   000003   F9           MOV     R1,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_460:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine167:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine219_0
   \   000002                ; // Fall through to label ??Subroutine219_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine219_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine220_0
   \   000002                ; // Fall through to label ??Subroutine220_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine220_0:
   \   000000   12....       LCALL   ??Subroutine224_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_537:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine224_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET
    597          #endif
    598          
    599          
    600          /*********************************************************************
    601           * @fn          zcl_getRawAFMsg
    602           *
    603           * @brief       Call to get original unprocessed AF message
    604           *              (not parsed by ZCL).
    605           *
    606           *   NOTE:  This function can only be called during a ZCL callback function
    607           *          and the calling function must NOT change any data in the message.
    608           *
    609           * @param       none
    610           *
    611           * @return      pointer to original AF message, NULL if not processing
    612           *              AF message.
    613           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    614          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    615          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    616            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_382:
   \   00000A   80..         SJMP    ?Subroutine0
    617          }
    618          
    619          /*********************************************************************
    620           * @fn          zcl_getParsedTransSeqNum
    621           *
    622           * @brief       Call to the get the transaction sequence number from
    623           *              the incoming message.
    624           *
    625           *   NOTE:  This function can only be called during a ZCL callback function
    626           *          and the calling function must NOT change any data in the message.
    627           *
    628           * @param       none
    629           *
    630           * @return      transaction sequence number.
    631           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    632          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    633          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    634            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009                REQUIRE ?Subroutine0
   \   000009                ; // Fall through to label ?Subroutine0
    635          }
    636          
    637          /*********************************************************************
    638           * @fn          zcl_registerPlugin
    639           *
    640           * @brief       Add a Cluster Library handler
    641           *
    642           * @param       startClusterID - starting cluster ID
    643           * @param       endClusterID - ending cluster ID
    644           * @param       pfnHdlr - function pointer to incoming message handler
    645           *
    646           * @return      ZSuccess if OK
    647           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    648          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    649                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    650          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    651            zclLibPlugin_t *pNewItem;
    652            zclLibPlugin_t *pLoop;
    653          
    654            // Fill in the new profile list
    655            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV     R2,#0x8
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    656            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerPlugin_0
    657            {
    658              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8040         SJMP    ??CrossCallReturnLabel_40
    659            }
    660          
    661            // Fill in the plugin record.
    662            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine32 & 0xFFFF
    663            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_28:
   \   00002E   A3           INC     DPTR
   \   00002F   E5..         MOV     A,?V0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   12....       LCALL   ?Subroutine25 & 0xFFFF
    664            pNewItem->endClusterID = endClusterID;
    665            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_18:
   \   000036   740C         MOV     A,#0xc
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   12....       LCALL   ?Subroutine46 & 0xFFFF
    666          
    667            // Find spot in list
    668            if (  plugins == NULL )
   \                     ??CrossCallReturnLabel_542:
   \   000045   90....       MOV     DPTR,#plugins
   \   000048   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   00004B   90....       MOV     DPTR,#plugins
   \   00004E   6011         JZ      ??zcl_registerPlugin_1
    669            {
    670              plugins = pNewItem;
    671            }
    672            else
    673            {
    674              // Look for end of list
    675              pLoop = plugins;
   \   000050   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000053   8003         SJMP    ??zcl_registerPlugin_2
    676              while ( pLoop->next != NULL )
    677              {
    678                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   000055   EA           MOV     A,R2
   \   000056   FC           MOV     R4,A
   \   000057   EB           MOV     A,R3
    679              }
   \                     ??zcl_registerPlugin_2:
   \   000058   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   00005B   70F8         JNZ     ??zcl_registerPlugin_3
    680          
    681              // Put new item at end of list
    682              pLoop->next = pNewItem;
   \   00005D   8C82         MOV     DPL,R4
   \   00005F   8D83         MOV     DPH,R5
    683            }
   \                     ??zcl_registerPlugin_1:
   \   000061   12....       LCALL   ?Subroutine37 & 0xFFFF
    684          
    685            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_40:
   \   000064   02....       LJMP    ?Subroutine1 & 0xFFFF
    686          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   E5..         MOV     A,?V1
   \   000002   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000005   A3           INC     DPTR
   \   000006   EE           MOV     A,R6
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EF           MOV     A,R7
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   12....       LCALL   ?Subroutine168 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine176_0
   \   000005                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine158:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine151:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine225_0
   \   000002                ; // Fall through to label ??Subroutine225_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine225_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    687          
    688          #ifdef ZCL_DISCOVER
    689          /*********************************************************************
    690           * @fn          zcl_registerCmdList
    691           *
    692           * @brief       Register a Command List with ZCL Foundation
    693           *
    694           * @param       endpoint - endpoint the attribute list belongs to
    695           * @param       newCmdList - array of command records
    696           *
    697           * @return      ZSuccess if OK
    698           */
    699          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    700          {
    701            zclCmdRecsList_t *pNewItem;
    702            zclCmdRecsList_t *pLoop;
    703          
    704            // Fill in the new profile list
    705            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    706            if ( pNewItem == NULL )
    707            {
    708              return (ZMemError);
    709            }
    710          
    711            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    712            pNewItem->endpoint = endpoint;
    713            pNewItem->numCommands = cmdListSize;
    714            pNewItem->pCmdRecs = newCmdList;
    715          
    716            // Find spot in list
    717            if ( gpCmdList == NULL )
    718            {
    719              gpCmdList = pNewItem;
    720            }
    721            else
    722            {
    723              // Look for end of list
    724              pLoop = gpCmdList;
    725              while ( pLoop->pNext != NULL )
    726              {
    727                pLoop = pLoop->pNext;
    728              }
    729          
    730              // Put new item at end of list
    731              pLoop->pNext = pNewItem;
    732            }
    733          
    734            return ( ZSuccess );
    735          }
    736          #endif  // ZCL_DISCOVER
    737          
    738          /*********************************************************************
    739           * @fn          zcl_registerAttrList
    740           *
    741           * @brief       Register an Attribute List with ZCL Foundation
    742           *
    743           * @param       endpoint - endpoint the attribute list belongs to
    744           * @param       numAttr - number of attributes in list
    745           * @param       newAttrList - array of Attribute records.
    746           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    747           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    748           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    749           *
    750           * @return      ZSuccess if OK
    751           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    752          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    753          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    754            zclAttrRecsList *pNewItem;
    755            zclAttrRecsList *pLoop;
    756          
    757            // Fill in the new profile list
    758            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV     R2,#0xa
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    759            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerAttrList_0
    760            {
    761              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8033         SJMP    ??CrossCallReturnLabel_41
    762            }
    763          
    764            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000024   12....       LCALL   ?Subroutine16 & 0xFFFF
    765            pNewItem->endpoint = endpoint;
    766            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_4:
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   12....       LCALL   ?Subroutine28 & 0xFFFF
    767            pNewItem->numAttributes = numAttr;
   \                     ??CrossCallReturnLabel_20:
   \   00002D   E5..         MOV     A,?V1
   \   00002F   12....       LCALL   ?Subroutine28 & 0xFFFF
    768            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_21:
   \   000032   A3           INC     DPTR
   \   000033   EE           MOV     A,R6
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   EF           MOV     A,R7
   \   000037   F0           MOVX    @DPTR,A
    769          
    770            // Find spot in list
    771            if ( attrList == NULL )
   \   000038   90....       MOV     DPTR,#attrList
   \   00003B   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   00003E   90....       MOV     DPTR,#attrList
   \   000041   6011         JZ      ??zcl_registerAttrList_1
    772            {
    773              attrList = pNewItem;
    774            }
    775            else
    776            {
    777              // Look for end of list
    778              pLoop = attrList;
   \   000043   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000046   8003         SJMP    ??zcl_registerAttrList_2
    779              while ( pLoop->next != NULL )
    780              {
    781                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   000048   EA           MOV     A,R2
   \   000049   FC           MOV     R4,A
   \   00004A   EB           MOV     A,R3
    782              }
   \                     ??zcl_registerAttrList_2:
   \   00004B   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   00004E   70F8         JNZ     ??zcl_registerAttrList_3
    783          
    784              // Put new item at end of list
    785              pLoop->next = pNewItem;
   \   000050   8C82         MOV     DPL,R4
   \   000052   8D83         MOV     DPH,R5
    786            }
   \                     ??zcl_registerAttrList_1:
   \   000054   12....       LCALL   ?Subroutine37 & 0xFFFF
    787          
    788            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_41:
   \   000057   02....       LJMP    ?Subroutine1 & 0xFFFF
    789          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E5..         MOV     A,?V0
   \   00000E   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000011   22           RET
    790          
    791          /*********************************************************************
    792           * @fn          zcl_registerClusterOptionList
    793           *
    794           * @brief       Register a Cluster Option List with ZCL Foundation
    795           *
    796           * @param       endpoint - endpoint the option list belongs to
    797           * @param       numOption - number of options in list
    798           * @param       optionList - array of cluster option records.
    799           *
    800           *              NOTE: This API should be called to enable 'Application
    801           *                    Link Key' security and/or 'APS ACK' for a specific
    802           *                    Cluster. The 'Application Link Key' is discarded
    803           *                    if security isn't enabled on the device.
    804           *                    The default behavior is 'Network Key' when security
    805           *                    is enabled and no 'APS ACK' for the ZCL messages.
    806           *
    807           * @return      ZSuccess if OK
    808           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    809          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    810          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    811            zclClusterOptionList *pNewItem;
    812            zclClusterOptionList *pLoop;
    813          
    814            // Fill in the new profile list
    815            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    816            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    817            {
    818              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8025         SJMP    ??CrossCallReturnLabel_42
    819            }
    820          
    821            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine16 & 0xFFFF
    822            pNewItem->endpoint = endpoint;
    823            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_5:
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
    824            pNewItem->options = optionList;
    825          
    826            // Find spot in list
    827            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_19:
   \   00002A   90....       MOV     DPTR,#clusterOptionList
   \   00002D   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000030   90....       MOV     DPTR,#clusterOptionList
   \   000033   6011         JZ      ??zcl_registerClusterOptionList_1
    828            {
    829              clusterOptionList = pNewItem;
    830            }
    831            else
    832            {
    833              // Look for end of list
    834              pLoop = clusterOptionList;
   \   000035   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000038   8003         SJMP    ??zcl_registerClusterOptionList_2
    835              while ( pLoop->next != NULL )
    836              {
    837                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   00003A   EA           MOV     A,R2
   \   00003B   FC           MOV     R4,A
   \   00003C   EB           MOV     A,R3
    838              }
   \                     ??zcl_registerClusterOptionList_2:
   \   00003D   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   000040   70F8         JNZ     ??zcl_registerClusterOptionList_3
    839          
    840              // Put new item at end of list
    841              pLoop->next = pNewItem;
   \   000042   8C82         MOV     DPL,R4
   \   000044   8D83         MOV     DPH,R5
    842            }
   \                     ??zcl_registerClusterOptionList_1:
   \   000046   12....       LCALL   ?Subroutine37 & 0xFFFF
    843          
    844            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_42:
   \   000049   02....       LJMP    ?Subroutine1 & 0xFFFF
    845          }
    846          
    847          /*********************************************************************
    848           * @fn          zcl_registerValidateAttrData
    849           *
    850           * @brief       Add a validation function for attribute data
    851           *
    852           * @param       pfnValidateAttrData - function pointer to validate routine
    853           *
    854           * @return      ZSuccess if OK
    855           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    856          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    857          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    858            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL   ??Subroutine225_0 & 0xFFFF
    859          
    860            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_538:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   02....       LJMP    ?Subroutine0 & 0xFFFF
    861          }
    862          
    863          /*********************************************************************
    864           * @fn          zcl_registerReadWriteCB
    865           *
    866           * @brief       Register the application's callback function to read/write
    867           *              attribute data, and authorize read/write operation.
    868           *
    869           *              Note: The pfnReadWriteCB callback function is only required
    870           *                    when the attribute data format is unknown to ZCL. The
    871           *                    callback function gets called when the pointer 'dataPtr'
    872           *                    to the attribute value is NULL in the attribute database
    873           *                    registered with the ZCL.
    874           *
    875           *              Note: The pfnAuthorizeCB callback function is only required
    876           *                    when the Read/Write operation on an attribute requires
    877           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    878           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    879           *
    880           * @param       endpoint - application's endpoint
    881           * @param       pfnReadWriteCB - function pointer to read/write routine
    882           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    883           *
    884           * @return      ZSuccess if successful. ZFailure, otherwise.
    885           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    886          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    887                                             zclAuthorizeCB_t pfnAuthorizeCB )
    888          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
    889            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   \   000014   A8..         MOV     R0,?V4
   \   000016   A9..         MOV     R1,?V5
    890          
    891            if ( pRec != NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   6019         JZ      ??zcl_registerReadWriteCB_0
    892            {
    893              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   12....       LCALL   ?Subroutine31 & 0xFFFF
    894              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_27:
   \   00002A   E5..         MOV     A,?V0
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V1
   \   000030   F0           MOVX    @DPTR,A
    895          
    896              return ( ZSuccess );
   \   000031   7900         MOV     R1,#0x0
   \   000033   8002         SJMP    ??zcl_registerReadWriteCB_1
    897            }
    898          
    899            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000035   7901         MOV     R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000037   02....       LJMP    ?Subroutine4 & 0xFFFF
    900          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    901          
    902          /*********************************************************************
    903           * @fn      zcl_DeviceOperational
    904           *
    905           * @brief   Used to see whether or not the device can send or respond
    906           *          to application level commands.
    907           *
    908           * @param   srcEP - source endpoint
    909           * @param   clusterID - cluster ID
    910           * @param   frameType - command type
    911           * @param   cmd - command ID
    912           *
    913           * @return  TRUE if device is operational, FALSE otherwise
    914           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    915          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    916                                              uint8 frameType, uint8 cmd, uint16 profileID )
    917          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FF           MOV     R7,A
    918            zclAttrRec_t attrRec;
    919            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7401         MOV     A,#0x1
   \   000016   F0           MOVX    @DPTR,A
    920          
    921            (void)profileID;  // Intentionally unreferenced parameter
    922          
    923            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    924            // cannot send or respond to application level commands, other than commands
    925            // to read or write attributes. Note that the Identify cluster cannot be
    926            // disabled, and remains functional regardless of this setting.
    927            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000017   EF           MOV     A,R7
   \   000018   7006         JNZ     ??zcl_DeviceOperational_0
   \   00001A   ED           MOV     A,R5
   \   00001B   C3           CLR     C
   \   00001C   9406         SUBB    A,#0x6
   \   00001E   4050         JC      ??zcl_DeviceOperational_1
    928            {
    929              return ( TRUE );
    930            }
    931          
    932            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   4B           ORL     A,R3
   \   000024   604A         JZ      ??zcl_DeviceOperational_1
    933            {
    934              return ( TRUE );
    935            }
    936          
    937            // Is device enabled?
    938            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    939                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000026                ; Setup parameters for call to function zclFindAttrRec
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP100_8
   \   00002B   88..         MOV     ?V2,R0
   \   00002D   89..         MOV     ?V3,R1
   \   00002F   78..         MOV     R0,#?V2
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   7C12         MOV     R4,#0x12
   \   000036   7D00         MOV     R5,#0x0
   \   000038   7A00         MOV     R2,#0x0
   \   00003A   7B00         MOV     R3,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   601C         JZ      ??zcl_DeviceOperational_2
    940            {
    941          #ifdef ZCL_READ
    942              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000049                ; Setup parameters for call to function zclReadAttrData
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   F5..         MOV     ?V3,A
   \   00004E   78..         MOV     R0,#?V2
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   7403         MOV     A,#0x3
   \   000055   12....       LCALL   ?XSTACK_DISP102_8
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?XSTACK_DISP101_8
   \   00005D   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   000060   7402         MOV     A,#0x2
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    943          #endif
    944            }
    945          
    946            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_2:
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6401         XRL     A,#0x1
   \   00006E   7004         JNZ     ??zcl_DeviceOperational_3
   \                     ??zcl_DeviceOperational_1:
   \   000070   7901         MOV     R1,#0x1
   \   000072   8002         SJMP    ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_3:
   \   000074   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_4:
   \   000076   7409         MOV     A,#0x9
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B                REQUIRE ?Subroutine1
   \   00007B                ; // Fall through to label ?Subroutine1
    947          }
    948          
    949          /*********************************************************************
    950           * @fn      zcl_SendCommand
    951           *
    952           * @brief   Used to send Profile and Cluster Specific Command messages.
    953           *
    954           *          NOTE: The calling application is responsible for incrementing
    955           *                the Sequence Number.
    956           *
    957           * @param   srcEp - source endpoint
    958           * @param   destAddr - destination address
    959           * @param   clusterID - cluster ID
    960           * @param   cmd - command ID
    961           * @param   specific - whether the command is Cluster Specific
    962           * @param   direction - client/server direction of the command
    963           * @param   disableDefaultRsp - disable Default Response command
    964           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    965           * @param   seqNumber - identification number for the transaction
    966           * @param   cmdFormatLen - length of the command to be sent
    967           * @param   cmdFormat - command to be sent
    968           *
    969           * @return  ZSuccess if OK
    970           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    971          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    972                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    973                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    974                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    975          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V10,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
    976            endPointDesc_t *epDesc;
    977            zclFrameHdr_t hdr;
    978            uint8 *msgBuf;
    979            uint16 msgLen;
    980            uint8 *pBuf;
    981            uint8 options;
    982            ZStatus_t status;
    983          
    984            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
    985            if ( epDesc == NULL )
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zcl_SendCommand_0
    986            {
    987              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    988            }
    989          
    990          #if defined ( INTER_PAN )
    991            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    992            {
    993              options = AF_TX_OPTIONS_NONE;
    994            }
    995            else
    996          #endif
    997            {
    998              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption
   \   000025   AA..         MOV     R2,?V0
   \   000027   AB..         MOV     R3,?V1
   \   000029   A9..         MOV     R1,?V10
   \   00002B   12....       LCALL   `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V7,A
    999          
   1000              // The cluster might not have been defined to use security but if this message
   1001              // is in response to another message that was using APS security this message
   1002              // will be sent with APS security
   1003              if ( !( options & AF_EN_SECURITY ) )
   \   000031   A2E6         MOV     C,0xE0 /* A   */.6
   \   000033   401C         JC      ??zcl_SendCommand_2
   1004              {
   1005                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV     DPTR,#rawAFMsg
   \   000038   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   1006          
   1007                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_366:
   \   00003B   6014         JZ      ??zcl_SendCommand_2
   \   00003D   E8           MOV     A,R0
   \   00003E   2419         ADD     A,#0x19
   \   000040   F582         MOV     DPL,A
   \   000042   E4           CLR     A
   \   000043   39           ADDC    A,R1
   \   000044   F583         MOV     DPH,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   6401         XRL     A,#0x1
   \   000049   7006         JNZ     ??zcl_SendCommand_2
   1008                {
   1009                  options |= AF_EN_SECURITY;
   \   00004B   E5..         MOV     A,?V7
   \   00004D   D2E6         SETB    0xE0 /* A   */.6
   \   00004F   F5..         MOV     ?V7,A
   1010                }
   1011              }
   1012            }
   1013          
   1014            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000051                ; Setup parameters for call to function osal_memset
   \   000051   7C06         MOV     R4,#0x6
   \   000053   7D00         MOV     R5,#0x0
   \   000055   7900         MOV     R1,#0x0
   \   000057   AA..         MOV     R2,?XSP + 0
   \   000059   AB..         MOV     R3,?XSP + 1
   \   00005B   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   1015          
   1016            // Not Profile wide command (like READ, WRITE)
   1017            if ( specific )
   \   00005E   741F         MOV     A,#0x1f
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000066   6009         JZ      ??zcl_SendCommand_3
   1018            {
   1019              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000068   E0           MOVX    A,@DPTR
   \   000069   54FC         ANL     A,#0xfc
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   4401         ORL     A,#0x1
   \   00006F   8003         SJMP    ??zcl_SendCommand_4
   1020            }
   1021            else
   1022            {
   1023              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   000071   E0           MOVX    A,@DPTR
   \   000072   54FC         ANL     A,#0xfc
   1024            }
   \                     ??zcl_SendCommand_4:
   \   000074   12....       LCALL   ?Subroutine34 & 0xFFFF
   1025          
   1026            if ( ( epDesc->simpleDesc == NULL ) ||
   1027                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
   1028                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_34:
   \   000077   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   00007A   602B         JZ      ??zcl_SendCommand_5
   \   00007C   741E         MOV     A,#0x1e
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E0           MOVX    A,@DPTR
   \   000082   FE           MOV     R6,A
   \   000083                ; Setup parameters for call to function zcl_DeviceOperational
   \   000083   8882         MOV     DPL,R0
   \   000085   8983         MOV     DPH,R1
   \   000087   A3           INC     DPTR
   \   000088   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00008B   EE           MOV     A,R6
   \   00008C   FD           MOV     R5,A
   \   00008D   7402         MOV     A,#0x2
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   E0           MOVX    A,@DPTR
   \   000093   5403         ANL     A,#0x3
   \   000095   FC           MOV     R4,A
   \   000096   AA..         MOV     R2,?V0
   \   000098   AB..         MOV     R3,?V1
   \   00009A   A9..         MOV     R1,?V10
   \   00009C   12....       LCALL   `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   00009F   7402         MOV     A,#0x2
   \   0000A1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A4   E9           MOV     A,R1
   \   0000A5   7005         JNZ     ??zcl_SendCommand_6
   1029            {
   1030              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   0000A7   7901         MOV     R1,#0x1
   \   0000A9   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
   1031            }
   \                     ??zcl_SendCommand_6:
   \   0000AC   7422         MOV     A,#0x22
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   1032          
   1033            // Fill in the Maufacturer Code
   1034            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_367:
   \   0000B4   6012         JZ      ??CrossCallReturnLabel_479
   1035            {
   1036              hdr.fc.manuSpecific = 1;
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   4404         ORL     A,#0x4
   \   0000BF   F0           MOVX    @DPTR,A
   1037              hdr.manuCode = manuCode;
   \   0000C0   7402         MOV     A,#0x2
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   1038            }
   1039          
   1040            // Set the Command Direction
   1041            if ( direction )
   \                     ??CrossCallReturnLabel_479:
   \   0000C8   7420         MOV     A,#0x20
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   0000D0   6005         JZ      ??zcl_SendCommand_7
   1042            {
   1043              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   4408         ORL     A,#0x8
   \   0000D5   8003         SJMP    ??zcl_SendCommand_8
   1044            }
   1045            else
   1046            {
   1047              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000DA   F0           MOVX    @DPTR,A
   1048            }
   1049          
   1050            // Set the Disable Default Response field
   1051            if ( disableDefaultRsp )
   \   0000DB   7421         MOV     A,#0x21
   \   0000DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E0   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   0000E3   6005         JZ      ??zcl_SendCommand_9
   1052            {
   1053              hdr.fc.disableDefaultRsp = 1;
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   4410         ORL     A,#0x10
   \   0000E8   8003         SJMP    ??zcl_SendCommand_10
   1054            }
   1055            else
   1056            {
   1057              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000ED   F0           MOVX    @DPTR,A
   1058            }
   1059          
   1060            // Fill in the Transaction Sequence Number
   1061            hdr.transSeqNum = seqNum;
   \   0000EE   7424         MOV     A,#0x24
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   C0E0         PUSH    A
   \   0000F6   7404         MOV     A,#0x4
   \   0000F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FB   D0E0         POP     A
   \   0000FD   F0           MOVX    @DPTR,A
   1062          
   1063            // Fill in the command
   1064            hdr.commandID = cmd;
   \   0000FE   7405         MOV     A,#0x5
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   EE           MOV     A,R6
   \   000104   F0           MOVX    @DPTR,A
   1065          
   1066            // calculate the needed buffer size
   1067            msgLen = zclCalcHdrSize( &hdr );
   \   000105   7803         MOV     R0,#0x3
   \   000107   85..82       MOV     DPL,?XSP + 0
   \   00010A   85..83       MOV     DPH,?XSP + 1
   \   00010D   E0           MOVX    A,@DPTR
   \   00010E   5404         ANL     A,#0x4
   \   000110   6002         JZ      ??zcl_SendCommand_11
   \   000112   7805         MOV     R0,#0x5
   \                     ??zcl_SendCommand_11:
   \   000114   7425         MOV     A,#0x25
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   1068            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_332:
   \   00011C   E8           MOV     A,R0
   \   00011D   25..         ADD     A,?V8
   \   00011F   FE           MOV     R6,A
   \   000120   E4           CLR     A
   \   000121   35..         ADDC    A,?V9
   \   000123   FF           MOV     R7,A
   1069          
   1070            // Allocate the buffer needed
   1071            msgBuf = zcl_mem_alloc( msgLen );
   \   000124                ; Setup parameters for call to function osal_mem_alloc
   \   000124   EE           MOV     A,R6
   \   000125   FA           MOV     R2,A
   \   000126   EF           MOV     A,R7
   \   000127   FB           MOV     R3,A
   \   000128   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00012B   8A..         MOV     ?V2,R2
   \   00012D   8B..         MOV     ?V3,R3
   1072            if ( msgBuf != NULL )
   \   00012F   EA           MOV     A,R2
   \   000130   45..         ORL     A,?V3
   \   000132   6065         JZ      ??zcl_SendCommand_12
   1073            {
   1074              // Fill in the ZCL Header
   1075              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   000134                ; Setup parameters for call to function zclBuildHdr
   \   000134   AC..         MOV     R4,?V2
   \   000136   AD..         MOV     R5,?V3
   \   000138   AA..         MOV     R2,?XSP + 0
   \   00013A   AB..         MOV     R3,?XSP + 1
   \   00013C   12....       LCALL   `??zclBuildHdr::?relay`; Banked call to: zclBuildHdr
   1076          
   1077              // Fill in the command frame
   1078              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   00013F                ; Setup parameters for call to function osal_memcpy
   \   00013F   7427         MOV     A,#0x27
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00014A   AC..         MOV     R4,?V8
   \   00014C   AD..         MOV     R5,?V9
   \   00014E   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000151   7403         MOV     A,#0x3
   \   000153   12....       LCALL   ?DEALLOC_XSTACK8
   1079          
   1080              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
   1081                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   000156                ; Setup parameters for call to function AF_DataRequest
   \   000156   75..1E       MOV     ?V4,#0x1e
   \   000159   78..         MOV     R0,#?V4
   \   00015B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015E   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   000161   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   000164   78..         MOV     R0,#?V4
   \   000166   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000169   78..         MOV     R0,#?V2
   \   00016B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016E   8E..         MOV     ?V4,R6
   \   000170   8F..         MOV     ?V5,R7
   \   000172   78..         MOV     R0,#?V4
   \   000174   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000177   78..         MOV     R0,#?V0
   \   000179   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017C   A9..         MOV     R1,?V7
   \   00017E   AC..         MOV     R4,?V12
   \   000180   AD..         MOV     R5,?V13
   \   000182   AA..         MOV     R2,?V14
   \   000184   AB..         MOV     R3,?V15
   \   000186   12....       LCALL   `??AF_DataRequest::?relay`; Banked call to: AF_DataRequest
   \   000189   7409         MOV     A,#0x9
   \   00018B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00018E   E9           MOV     A,R1
   \   00018F   FE           MOV     R6,A
   1082              zcl_mem_free ( msgBuf );
   \   000190                ; Setup parameters for call to function osal_mem_free
   \   000190   AA..         MOV     R2,?V2
   \   000192   AB..         MOV     R3,?V3
   \   000194   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000197   8002         SJMP    ??zcl_SendCommand_13
   1083            }
   1084            else
   1085            {
   1086              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   000199   7E10         MOV     R6,#0x10
   1087            }
   1088          
   1089            return ( status );
   \                     ??zcl_SendCommand_13:
   \   00019B   EE           MOV     A,R6
   \   00019C   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   00019D   7406         MOV     A,#0x6
   \   00019F   80..         SJMP    ??Subroutine174_0
   1090          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine169:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000003   75..00       MOV     ?V6,#0x0
   \   000006   78..         MOV     R0,#?V4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine214_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V12
   \   000004   85..83       MOV     DPH,?V13
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1091          
   1092          #ifdef ZCL_READ
   1093          /*********************************************************************
   1094           * @fn      zcl_SendRead
   1095           *
   1096           * @brief   Send a Read command
   1097           *
   1098           * @param   srcEP - Application's endpoint
   1099           * @param   dstAddr - destination address
   1100           * @param   clusterID - cluster ID
   1101           * @param   readCmd - read command to be sent
   1102           * @param   direction - direction of the command
   1103           * @param   seqNum - transaction sequence number
   1104           *
   1105           * @return  ZSuccess if OK
   1106           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1107          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
   1108                                  uint16 clusterID, zclReadCmd_t *readCmd,
   1109                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
   1110          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine80 & 0xFFFF
   1111            uint16 dataLen;
   1112            uint8 *buf;
   1113            uint8 *pBuf;
   1114            ZStatus_t status;
   1115          
   1116            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_126:
   \   000017   25E0         ADD     A,0xE0 /* A   */
   \   000019   FE           MOV     R6,A
   \   00001A   E4           CLR     A
   \   00001B   33           RLC     A
   \   00001C   FF           MOV     R7,A
   1117          
   1118            buf = zcl_mem_alloc( dataLen );
   \   00001D                ; Setup parameters for call to function osal_mem_alloc
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000024   8A..         MOV     ?V0,R2
   \   000026   8B..         MOV     ?V1,R3
   1119            if ( buf != NULL )
   \   000028   EA           MOV     A,R2
   \   000029   45..         ORL     A,?V1
   \   00002B   7003         JNZ     $+5
   \   00002D   02....       LJMP    ??zcl_SendRead_0 & 0xFFFF
   1120            {
   1121              uint8 i;
   1122          
   1123              // Load the buffer - serially
   1124              pBuf = buf;
   1125              for (i = 0; i < readCmd->numAttr; i++)
   \   000030   7C00         MOV     R4,#0x0
   \   000032   8019         SJMP    ??zcl_SendRead_1
   1126              {
   1127                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   000034   EC           MOV     A,R4
   \   000035   25E0         ADD     A,0xE0 /* A   */
   \   000037   F8           MOV     R0,A
   \   000038   E4           CLR     A
   \   000039   33           RLC     A
   \   00003A   F9           MOV     R1,A
   \   00003B   12....       LCALL   ?Subroutine161 & 0xFFFF
   1128                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   1129              }
   \                     ??CrossCallReturnLabel_288:
   \   00003E   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_409:
   \   000041   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000044   F0           MOVX    @DPTR,A
   \   000045   EA           MOV     A,R2
   \   000046   2402         ADD     A,#0x2
   \   000048   FA           MOV     R2,A
   \   000049   5001         JNC     ??zcl_SendRead_3
   \   00004B   0B           INC     R3
   \                     ??zcl_SendRead_3:
   \   00004C   0C           INC     R4
   \                     ??zcl_SendRead_1:
   \   00004D   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000050   40E2         JC      ??zcl_SendRead_2
   1130          
   1131              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
   1132                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000052                ; Setup parameters for call to function zcl_SendCommand
   \   000052   78..         MOV     R0,#?V0
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   8E..         MOV     ?V4,R6
   \   000059   8F..         MOV     ?V5,R7
   \   00005B   78..         MOV     R0,#?V4
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   741C         MOV     A,#0x1c
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006B   E4           CLR     A
   \   00006C   F5..         MOV     ?V4,A
   \   00006E   F5..         MOV     ?V5,A
   \   000070   78..         MOV     R0,#?V4
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   741E         MOV     A,#0x1e
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   00007D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000080   741E         MOV     A,#0x1e
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008B   75..00       MOV     ?V3,#0x0
   \   00008E   78..         MOV     R0,#?V3
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000093   78..         MOV     R0,#?V3
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000098   AC..         MOV     R4,?V6
   \   00009A   AD..         MOV     R5,?V7
   \   00009C   AA..         MOV     R2,?V8
   \   00009E   AB..         MOV     R3,?V9
   \   0000A0   A9..         MOV     R1,?V2
   \   0000A2   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000A5   740B         MOV     A,#0xb
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   FE           MOV     R6,A
   1133              zcl_mem_free( buf );
   \   0000AC                ; Setup parameters for call to function osal_mem_free
   \   0000AC   AA..         MOV     R2,?V0
   \   0000AE   AB..         MOV     R3,?V1
   \   0000B0   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000B3   8002         SJMP    ??zcl_SendRead_4
   1134            }
   1135            else
   1136            {
   1137              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000B5   7E10         MOV     R6,#0x10
   1138            }
   1139          
   1140            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000B7   02....       LJMP    ?Subroutine10 & 0xFFFF
   1141          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine161:
   \   000000   E5..         MOV     A,?V4
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   E5..         MOV     A,?V5
   \   000007                REQUIRE ??Subroutine175_0
   \   000007                ; // Fall through to label ??Subroutine175_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000003   A882         MOV     R0,DPL
   \   000005   A983         MOV     R1,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine178_0
   \   000006                ; // Fall through to label ??Subroutine178_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine178_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   EC           MOV     A,R4
   \   000003   C3           CLR     C
   \   000004   98           SUBB    A,R0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine179_0:
   \   000000   7F0C         MOV     R7,#0xc
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine179_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine145:
   \   000000   12....       LCALL   ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   F583         MOV     DPH,A
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V3,A
   \   000003   78..         MOV     R0,#?V3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   12....       LCALL   ?Subroutine173 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine172:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine201_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET
   1142          
   1143          /*********************************************************************
   1144           * @fn      zcl_SendReadRsp
   1145           *
   1146           * @brief   Send a Read Response command.
   1147           *
   1148           * @param   srcEP - Application's endpoint
   1149           * @param   dstAddr - destination address
   1150           * @param   clusterID - cluster ID
   1151           * @param   readRspCmd - read response command to be sent
   1152           * @param   direction - direction of the command
   1153           * @param   seqNum - transaction sequence number
   1154           *
   1155           * @return  ZSuccess if OK
   1156           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1157          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1158                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1159                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1160          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V3,R1
   \   00000C   8A..         MOV     ?V12,R2
   \   00000E   8B..         MOV     ?V13,R3
   \   000010   8C..         MOV     ?V6,R4
   \   000012   8D..         MOV     ?V7,R5
   1161            uint8 *buf;
   1162            uint16 len = 0;
   \   000014   7E00         MOV     R6,#0x0
   \   000016   7F00         MOV     R7,#0x0
   1163            ZStatus_t status;
   1164            uint8 i;
   1165          
   1166            // calculate the size of the command
   1167            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000018   75..00       MOV     ?V2,#0x0
   \   00001B   7418         MOV     A,#0x18
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000023   8011         SJMP    ??zcl_SendReadRsp_0
   1168            {
   1169              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1170          
   1171              len += 2 + 1; // Attribute ID + Status
   1172          
   1173              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1174              {
   1175                len++; // Attribute Data Type length
   1176          
   1177                // Attribute Data length
   1178                if ( statusRec->data != NULL )
   1179                {
   1180                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1181                }
   1182                else
   1183                {
   1184                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000025                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000025   12....       LCALL   ?Subroutine84 & 0xFFFF
   1185                }
   \                     ??CrossCallReturnLabel_130:
   \   000028   12....       LCALL   `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_2:
   \   00002B   8B..         MOV     ?V1,R3
   \   00002D   EE           MOV     A,R6
   \   00002E   2A           ADD     A,R2
   \   00002F   FE           MOV     R6,A
   \   000030   EF           MOV     A,R7
   \   000031   35..         ADDC    A,?V1
   \   000033   FF           MOV     R7,A
   \                     ??zcl_SendReadRsp_3:
   \   000034   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000036   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_448:
   \   000039   5033         JNC     ??zcl_SendReadRsp_4
   \   00003B   E5..         MOV     A,?V2
   \   00003D   75F006       MOV     B,#0x6
   \   000040   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000043   2403         ADD     A,#0x3
   \   000045   FE           MOV     R6,A
   \   000046   E4           CLR     A
   \   000047   3F           ADDC    A,R7
   \   000048   FF           MOV     R7,A
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   70E6         JNZ     ??zcl_SendReadRsp_3
   \   00004E   0E           INC     R6
   \   00004F   EE           MOV     A,R6
   \   000050   7001         JNZ     ??zcl_SendReadRsp_5
   \   000052   0F           INC     R7
   \                     ??zcl_SendReadRsp_5:
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   00005E   8882         MOV     DPL,R0
   \   000060   8983         MOV     DPH,R1
   \   000062   60C1         JZ      ??zcl_SendReadRsp_1
   \   000064                ; Setup parameters for call to function zclGetAttrDataLength
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   F9           MOV     R1,A
   \   000069   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00006C   80BD         SJMP    ??zcl_SendReadRsp_2
   1186              }
   1187            }
   1188          
   1189            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_4:
   \   00006E                ; Setup parameters for call to function osal_mem_alloc
   \   00006E   EE           MOV     A,R6
   \   00006F   FA           MOV     R2,A
   \   000070   EF           MOV     A,R7
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000075   8A..         MOV     ?V0,R2
   \   000077   8B..         MOV     ?V1,R3
   \   000079   8A..         MOV     ?V4,R2
   \   00007B   8B..         MOV     ?V5,R3
   1190            if ( buf != NULL )
   \   00007D   EA           MOV     A,R2
   \   00007E   45..         ORL     A,?V5
   \   000080   7003         JNZ     $+5
   \   000082   02....       LJMP    ??zcl_SendReadRsp_6 & 0xFFFF
   1191            {
   1192              // Load the buffer - serially
   1193              uint8 *pBuf = buf;
   1194          
   1195              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000085   75..00       MOV     ?V2,#0x0
   \   000088   8036         SJMP    ??zcl_SendReadRsp_7
   1196              {
   1197                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1198          
   1199                *pBuf++ = LO_UINT16( statusRec->attrID );
   1200                *pBuf++ = HI_UINT16( statusRec->attrID );
   1201                *pBuf++ = statusRec->status;
   1202          
   1203                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1204                {
   1205                  *pBuf++ = statusRec->dataType;
   1206          
   1207                  if ( statusRec->data != NULL )
   1208                  {
   1209                    // Copy attribute data to the buffer to be sent out
   1210                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1211                  }
   1212                  else
   1213                  {
   1214                    uint16 dataLen;
   1215          
   1216                    // Read attribute data directly into the buffer to be sent out
   1217                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_8:
   \   00008A                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00008A   A8..         MOV     R0,?XSP + 0
   \   00008C   A9..         MOV     R1,?XSP + 1
   \   00008E   88..         MOV     ?V10,R0
   \   000090   89..         MOV     ?V11,R1
   \   000092   78..         MOV     R0,#?V10
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000097   78..         MOV     R0,#?V0
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   8A82         MOV     DPL,R2
   \   00009E   8B83         MOV     DPH,R3
   \   0000A0   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   0000A3   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
   1218                    pBuf += dataLen;
   \   0000AB   85..82       MOV     DPL,?XSP + 0
   \   0000AE   85..83       MOV     DPH,?XSP + 1
   \   0000B1   12....       LCALL   ??Subroutine218_0 & 0xFFFF
   1219                  }
   \                     ??CrossCallReturnLabel_500:
   \   0000B4   E5..         MOV     A,?V0
   \   0000B6   28           ADD     A,R0
   \   0000B7   F5..         MOV     ?V0,A
   \   0000B9   E5..         MOV     A,?V1
   \   0000BB   39           ADDC    A,R1
   \   0000BC   F5..         MOV     ?V1,A
   \                     ??zcl_SendReadRsp_9:
   \   0000BE   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_7:
   \   0000C0   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_449:
   \   0000C3   5073         JNC     ??zcl_SendReadRsp_10
   \   0000C5   E5..         MOV     A,?V2
   \   0000C7   75F006       MOV     B,#0x6
   \   0000CA   A4           MUL     AB
   \   0000CB   F8           MOV     R0,A
   \   0000CC   A9F0         MOV     R1,B
   \   0000CE   E5..         MOV     A,?V8
   \   0000D0   28           ADD     A,R0
   \   0000D1   F582         MOV     DPL,A
   \   0000D3   E5..         MOV     A,?V9
   \   0000D5   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   0000D8   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   0000DB   8A82         MOV     DPL,R2
   \   0000DD   8B83         MOV     DPH,R3
   \   0000DF   A3           INC     DPTR
   \   0000E0   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   0000E7   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   0000EA   F0           MOVX    @DPTR,A
   \   0000EB   E5..         MOV     A,?V0
   \   0000ED   2403         ADD     A,#0x3
   \   0000EF   F5..         MOV     ?V0,A
   \   0000F1   5002         JNC     ??zcl_SendReadRsp_11
   \   0000F3   05..         INC     ?V1
   \                     ??zcl_SendReadRsp_11:
   \   0000F5   8882         MOV     DPL,R0
   \   0000F7   8983         MOV     DPH,R1
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   70C2         JNZ     ??zcl_SendReadRsp_9
   \   0000FC   EA           MOV     A,R2
   \   0000FD   2403         ADD     A,#0x3
   \   0000FF   08           INC     R0
   \   000100   12....       LCALL   ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   000103   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000106   A3           INC     DPTR
   \   000107   8582..       MOV     ?V0,DPL
   \   00010A   8583..       MOV     ?V1,DPH
   \   00010D   8A82         MOV     DPL,R2
   \   00010F   8B83         MOV     DPH,R3
   \   000111   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_521:
   \   000114   8C82         MOV     DPL,R4
   \   000116   8D83         MOV     DPH,R5
   \   000118   E582         MOV     A,DPL
   \   00011A   4583         ORL     A,DPH
   \   00011C   7003         JNZ     $+5
   \   00011E   02....       LJMP    ??zcl_SendReadRsp_8 & 0xFFFF
   \   000121                ; Setup parameters for call to function zclSerializeData
   \   000121   AC..         MOV     R4,?V0
   \   000123   AD..         MOV     R5,?V1
   \   000125   AA82         MOV     R2,DPL
   \   000127   AB83         MOV     R3,DPH
   \   000129   8882         MOV     DPL,R0
   \   00012B   8983         MOV     DPH,R1
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   F9           MOV     R1,A
   \   00012F   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000132   8A..         MOV     ?V0,R2
   \   000134   8B..         MOV     ?V1,R3
   \   000136   8086         SJMP    ??zcl_SendReadRsp_9
   1220                }
   1221              } // for loop
   1222          
   1223              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1224                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_10:
   \   000138                ; Setup parameters for call to function zcl_SendCommand
   \   000138   78..         MOV     R0,#?V4
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00013D   8E..         MOV     ?V0,R6
   \   00013F   8F..         MOV     ?V1,R7
   \   000141   78..         MOV     R0,#?V0
   \   000143   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000146   7420         MOV     A,#0x20
   \   000148   12....       LCALL   ?XSTACK_DISP0_8
   \   00014B   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   00014E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000151   E4           CLR     A
   \   000152   F5..         MOV     ?V0,A
   \   000154   F5..         MOV     ?V1,A
   \   000156   78..         MOV     R0,#?V0
   \   000158   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015B   7422         MOV     A,#0x22
   \   00015D   12....       LCALL   ?XSTACK_DISP0_8
   \   000160   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000163   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000166   7422         MOV     A,#0x22
   \   000168   12....       LCALL   ?XSTACK_DISP0_8
   \   00016B   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00016E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000171   75..00       MOV     ?V0,#0x0
   \   000174   78..         MOV     R0,#?V0
   \   000176   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000179   75..01       MOV     ?V0,#0x1
   \   00017C   78..         MOV     R0,#?V0
   \   00017E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000181   AC..         MOV     R4,?V6
   \   000183   AD..         MOV     R5,?V7
   \   000185   AA..         MOV     R2,?V12
   \   000187   AB..         MOV     R3,?V13
   \   000189   A9..         MOV     R1,?V3
   \   00018B   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00018E   740B         MOV     A,#0xb
   \   000190   12....       LCALL   ?DEALLOC_XSTACK8
   \   000193   E9           MOV     A,R1
   \   000194   FE           MOV     R6,A
   1225              zcl_mem_free( buf );
   \   000195                ; Setup parameters for call to function osal_mem_free
   \   000195   AA..         MOV     R2,?V4
   \   000197   AB..         MOV     R3,?V5
   \   000199   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   00019C   8002         SJMP    ??zcl_SendReadRsp_12
   1226            }
   1227            else
   1228            {
   1229              status = ZMemError;
   \                     ??zcl_SendReadRsp_6:
   \   00019E   7E10         MOV     R6,#0x10
   1230            }
   1231          
   1232            return ( status );
   \                     ??zcl_SendReadRsp_12:
   \   0001A0   EE           MOV     A,R6
   \   0001A1   F9           MOV     R1,A
   \   0001A2   7402         MOV     A,#0x2
   \   0001A4                REQUIRE ?Subroutine11
   \   0001A4                ; // Fall through to label ?Subroutine11
   1233          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   80..         SJMP    ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   12....       LCALL   ??Subroutine224_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_534:
   \   000003   AA..         MOV     R2,?V6
   \   000005   AB..         MOV     R3,?V7
   \   000007   A9..         MOV     R1,?V3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine177_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   00000E   EE           MOV     A,R6
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine183_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V9,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine159:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   EA           MOV     A,R2
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004                REQUIRE ??Subroutine190_0
   \   000004                ; // Fall through to label ??Subroutine190_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine190_0:
   \   000000   E4           CLR     A
   \   000001   3B           ADDC    A,R3
   \   000002   F9           MOV     R1,A
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine208_0
   \   000006                ; // Fall through to label ??Subroutine208_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine208_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V2
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000003   AA82         MOV     R2,DPL
   \   000005   AB83         MOV     R3,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine218_0:
   \   000000   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_507:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine155:
   \   000000   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_513:
   \   000003   F9           MOV     R1,A
   \   000004   22           RET
   1234          #endif // ZCL_READ
   1235          
   1236          #ifdef ZCL_WRITE
   1237          /*********************************************************************
   1238           * @fn      sendWriteRequest
   1239           *
   1240           * @brief   Send a Write command
   1241           *
   1242           * @param   dstAddr - destination address
   1243           * @param   clusterID - cluster ID
   1244           * @param   writeCmd - write command to be sent
   1245           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1246           * @param   direction - direction of the command
   1247           * @param   seqNum - transaction sequence number
   1248           *
   1249           * @return  ZSuccess if OK
   1250           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1251          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1252                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1253                                          uint8 disableDefaultRsp, uint8 seqNum )
   1254          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1255            uint8 *buf;
   1256            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1257            ZStatus_t status;
   1258            uint8 i;
   1259          
   1260            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000013   75..00       MOV     ?V2,#0x0
   \   000016   7416         MOV     A,#0x16
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   00001E   8009         SJMP    ??CrossCallReturnLabel_209
   1261            {
   1262              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   000020   12....       LCALL   ?Subroutine77 & 0xFFFF
   1263          
   1264              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1265          
   1266              // Attribute Data
   1267              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   1268            }
   \                     ??CrossCallReturnLabel_120:
   \   000023   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000026   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000029   85..82       MOV     DPL,?V4
   \   00002C   85..83       MOV     DPH,?V5
   \   00002F   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_443:
   \   000032   40EC         JC      ??zcl_SendWriteRequest_0
   1269          
   1270            buf = zcl_mem_alloc( dataLen );
   \   000034                ; Setup parameters for call to function osal_mem_alloc
   \   000034   EE           MOV     A,R6
   \   000035   FA           MOV     R2,A
   \   000036   EF           MOV     A,R7
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V0,R2
   \   00003D   8B..         MOV     ?V1,R3
   1271            if ( buf != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V1
   \   000042   7003         JNZ     $+5
   \   000044   02....       LJMP    ??zcl_SendWriteRequest_1 & 0xFFFF
   1272            {
   1273              // Load the buffer - serially
   1274              uint8 *pBuf = buf;
   \   000047   A8..         MOV     R0,?V0
   \   000049   A9..         MOV     R1,?V1
   1275              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00004B   75..00       MOV     ?V2,#0x0
   \   00004E   8010         SJMP    ??zcl_SendWriteRequest_2
   1276              {
   1277                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_3:
   \   000050   12....       LCALL   ?Subroutine13 & 0xFFFF
   1278          
   1279                *pBuf++ = LO_UINT16( statusRec->attrID );
   1280                *pBuf++ = HI_UINT16( statusRec->attrID );
   1281                *pBuf++ = statusRec->dataType;
   1282          
   1283                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   1284              }
   \                     ??CrossCallReturnLabel_0:
   \   000053   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000056   8A..         MOV     ?V10,R2
   \   000058   8B..         MOV     ?V11,R3
   \   00005A   A8..         MOV     R0,?V10
   \   00005C   A9..         MOV     R1,?V11
   \   00005E   05..         INC     ?V2
   \                     ??zcl_SendWriteRequest_2:
   \   000060   85..82       MOV     DPL,?V4
   \   000063   85..83       MOV     DPH,?V5
   \   000066   E0           MOVX    A,@DPTR
   \   000067   FA           MOV     R2,A
   \   000068   E5..         MOV     A,?V2
   \   00006A   C3           CLR     C
   \   00006B   9A           SUBB    A,R2
   \   00006C   40E2         JC      ??zcl_SendWriteRequest_3
   1285          
   1286              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1287                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00006E                ; Setup parameters for call to function zcl_SendCommand
   \   00006E   78..         MOV     R0,#?V0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   8E..         MOV     ?V4,R6
   \   000075   8F..         MOV     ?V5,R7
   \   000077   78..         MOV     R0,#?V4
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   741F         MOV     A,#0x1f
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_463:
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000087   E4           CLR     A
   \   000088   F5..         MOV     ?V4,A
   \   00008A   F5..         MOV     ?V5,A
   \   00008C   78..         MOV     R0,#?V4
   \   00008E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000091   7421         MOV     A,#0x21
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_464:
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009C   7421         MOV     A,#0x21
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_465:
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   75..00       MOV     ?V2,#0x0
   \   0000AA   78..         MOV     R0,#?V2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AF   7422         MOV     A,#0x22
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_466:
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BA   AC..         MOV     R4,?V6
   \   0000BC   AD..         MOV     R5,?V7
   \   0000BE   AA..         MOV     R2,?V8
   \   0000C0   AB..         MOV     R3,?V9
   \   0000C2   A9..         MOV     R1,?V3
   \   0000C4   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000C7   740B         MOV     A,#0xb
   \   0000C9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CC   E9           MOV     A,R1
   \   0000CD   FE           MOV     R6,A
   1288              zcl_mem_free( buf );
   \   0000CE                ; Setup parameters for call to function osal_mem_free
   \   0000CE   AA..         MOV     R2,?V0
   \   0000D0   AB..         MOV     R3,?V1
   \   0000D2   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D5   8002         SJMP    ??zcl_SendWriteRequest_4
   1289            }
   1290            else
   1291            {
   1292              status = ZMemError;
   \                     ??zcl_SendWriteRequest_1:
   \   0000D7   7E10         MOV     R6,#0x10
   1293            }
   1294          
   1295            return ( status);
   \                     ??zcl_SendWriteRequest_4:
   \   0000D9                REQUIRE ?Subroutine12
   \   0000D9                ; // Fall through to label ?Subroutine12
   1296          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine177_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   8B..         MOV     ?V1,R3
   \   000002   EA           MOV     A,R2
   \   000003   2403         ADD     A,#0x3
   \   000005   F8           MOV     R0,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V1
   \   000009   F9           MOV     R1,A
   \   00000A   EE           MOV     A,R6
   \   00000B   28           ADD     A,R0
   \   00000C   FE           MOV     R6,A
   \   00000D   EF           MOV     A,R7
   \   00000E   39           ADDC    A,R1
   \   00000F   FF           MOV     R7,A
   \   000010   05..         INC     ?V2
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   12....       LCALL   ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   A4           MUL     AB
   \   000006   F8           MOV     R0,A
   \   000007   A9F0         MOV     R1,B
   \   000009   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   A4           MUL     AB
   \   000006   FA           MOV     R2,A
   \   000007   ABF0         MOV     R3,B
   \   000009   E5..         MOV     A,?V4
   \   00000B   2A           ADD     A,R2
   \   00000C   F582         MOV     DPL,A
   \   00000E   E5..         MOV     A,?V5
   \   000010   3B           ADDC    A,R3
   \   000011   F583         MOV     DPH,A
   \   000013   A3           INC     DPTR
   \   000014   8582..       MOV     ?V12,DPL
   \   000017   8583..       MOV     ?V13,DPH
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   8882         MOV     DPL,R0
   \   00001D   8983         MOV     DPH,R1
   \   00001F   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000022   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   000025   F0           MOVX    @DPTR,A
   \   000026   E5..         MOV     A,?V12
   \   000028   2402         ADD     A,#0x2
   \   00002A   FA           MOV     R2,A
   \   00002B   E4           CLR     A
   \   00002C   35..         ADDC    A,?V13
   \   00002E   FB           MOV     R3,A
   \   00002F   8A..         MOV     ?V10,R2
   \   000031   8B..         MOV     ?V11,R3
   \   000033   8A82         MOV     DPL,R2
   \   000035   F583         MOV     DPH,A
   \   000037   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   00003A   A3           INC     DPTR
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C                ; Setup parameters for call to function zclSerializeData
   \   00003C                ; Setup parameters for call to function zclSerializeData
   \   00003C   E8           MOV     A,R0
   \   00003D   2403         ADD     A,#0x3
   \   00003F   FC           MOV     R4,A
   \   000040   E4           CLR     A
   \   000041   39           ADDC    A,R1
   \   000042   FD           MOV     R5,A
   \   000043   85..82       MOV     DPL,?V12
   \   000046   85..83       MOV     DPH,?V13
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   00004F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V10
   \   000008   85..83       MOV     DPH,?V11
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine156:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine212_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   78..         MOV     R0,#?V2
   \   000005   22           RET
   1297          
   1298          /*********************************************************************
   1299           * @fn      zcl_SendWriteRsp
   1300           *
   1301           * @brief   Send a Write Response command
   1302           *
   1303           * @param   dstAddr - destination address
   1304           * @param   clusterID - cluster ID
   1305           * @param   wrtieRspCmd - write response command to be sent
   1306           * @param   direction - direction of the command
   1307           * @param   seqNum - transaction sequence number
   1308           *
   1309           * @return  ZSuccess if OK
   1310           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1311          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1312                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1313                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1314          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine56 & 0xFFFF
   1315            uint16 dataLen;
   1316            uint8 *buf;
   1317            ZStatus_t status;
   1318          
   1319            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   1320          
   1321            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_79:
   \   000017   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1322            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
   1323            {
   1324              // Load the buffer - serially
   1325              uint8 i;
   1326              uint8 *pBuf = buf;
   1327              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   000026   7C00         MOV     R4,#0x0
   \   000028   800D         SJMP    ??zcl_SendWriteRsp_1
   1328              {
   1329                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_2:
   \   00002A   12....       LCALL   ?Subroutine92 & 0xFFFF
   1330                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   1331                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1332              }
   \                     ??CrossCallReturnLabel_145:
   \   00002D   5001         JNC     ??zcl_SendWriteRsp_3
   \   00002F   09           INC     R1
   \                     ??zcl_SendWriteRsp_3:
   \   000030   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000033   5001         JNC     ??zcl_SendWriteRsp_4
   \   000035   0B           INC     R3
   \                     ??zcl_SendWriteRsp_4:
   \   000036   0C           INC     R4
   \                     ??zcl_SendWriteRsp_1:
   \   000037   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   00003A   40EE         JC      ??zcl_SendWriteRsp_2
   1333          
   1334              // If there's only a single status record and its status field is set to
   1335              // SUCCESS then omit the attribute ID field.
   1336              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   00003C   7401         MOV     A,#0x1
   \   00003E   68           XRL     A,R0
   \   00003F   700A         JNZ     ??zcl_SendWriteRsp_5
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   7006         JNZ     ??zcl_SendWriteRsp_5
   1337              {
   1338                dataLen = 1;
   \   000045   75..01       MOV     ?V6,#0x1
   \   000048   75..00       MOV     ?V7,#0x0
   1339              }
   1340          
   1341              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1342                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_5:
   \   00004B                ; Setup parameters for call to function zcl_SendCommand
   \   00004B   78..         MOV     R0,#?V0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   78..         MOV     R0,#?V6
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   741C         MOV     A,#0x1c
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000060   E4           CLR     A
   \   000061   F5..         MOV     ?V4,A
   \   000063   F5..         MOV     ?V5,A
   \   000065   78..         MOV     R0,#?V4
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   741E         MOV     A,#0x1e
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000075   741E         MOV     A,#0x1e
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00007D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000080   75..00       MOV     ?V3,#0x0
   \   000083   78..         MOV     R0,#?V3
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000088   75..04       MOV     ?V3,#0x4
   \   00008B   78..         MOV     R0,#?V3
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   EE           MOV     A,R6
   \   000091   FC           MOV     R4,A
   \   000092   EF           MOV     A,R7
   \   000093   FD           MOV     R5,A
   \   000094   AA..         MOV     R2,?V8
   \   000096   AB..         MOV     R3,?V9
   \   000098   A9..         MOV     R1,?V2
   \   00009A   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00009D   740B         MOV     A,#0xb
   \   00009F   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A2   E9           MOV     A,R1
   \   0000A3   FE           MOV     R6,A
   1343              zcl_mem_free( buf );
   \   0000A4                ; Setup parameters for call to function osal_mem_free
   \   0000A4   AA..         MOV     R2,?V0
   \   0000A6   AB..         MOV     R3,?V1
   \   0000A8   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000AB   8002         SJMP    ??zcl_SendWriteRsp_6
   1344            }
   1345            else
   1346            {
   1347              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000AD   7E10         MOV     R6,#0x10
   1348            }
   1349          
   1350            return ( status );
   \                     ??zcl_SendWriteRsp_6:
   \   0000AF   02....       LJMP    ?Subroutine10 & 0xFFFF
   1351          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   EC           MOV     A,R4
   \   000001   75F003       MOV     B,#0x3
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   A9F0         MOV     R1,B
   \   000008   E5..         MOV     A,?V4
   \   00000A   28           ADD     A,R0
   \   00000B   F8           MOV     R0,A
   \   00000C   E5..         MOV     A,?V5
   \   00000E   39           ADDC    A,R1
   \   00000F   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_416:
   \   000012   F0           MOVX    @DPTR,A
   \   000013   E8           MOV     A,R0
   \   000014   2402         ADD     A,#0x2
   \   000016   F8           MOV     R0,A
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000003   75F003       MOV     B,#0x3
   \   000006   A4           MUL     AB
   \   000007   F5..         MOV     ?V6,A
   \   000009   E5F0         MOV     A,B
   \   00000B   F5..         MOV     ?V7,A
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   AA..         MOV     R2,?V6
   \   00000F   FB           MOV     R3,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_412:
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   EA           MOV     A,R2
   \   00000E   2403         ADD     A,#0x3
   \   000010   FA           MOV     R2,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   F9           MOV     R1,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine201_0
   \   000006                ; // Fall through to label ??Subroutine201_0
   1352          #endif // ZCL_WRITE
   1353          
   1354          #ifdef ZCL_REPORT
   1355          /*********************************************************************
   1356           * @fn      zcl_SendConfigReportCmd
   1357           *
   1358           * @brief   Send a Configure Reporting command
   1359           *
   1360           * @param   dstAddr - destination address
   1361           * @param   clusterID - cluster ID
   1362           * @param   cfgReportCmd - configure reporting command to be sent
   1363           * @param   direction - direction of the command
   1364           * @param   seqNum - transaction sequence number
   1365           *
   1366           * @return  ZSuccess if OK
   1367           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   7402         MOV     A,#0x2
   \   000004                REQUIRE ??Subroutine174_0
   \   000004                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1368          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportCmd:
   1369                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1370                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1371          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine17 & 0xFFFF
   1372            uint8 *buf;
   1373            uint16 dataLen = 0;
   1374            ZStatus_t status;
   1375            uint8 i;
   1376          
   1377            // Find out the data length
   1378            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_6:
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   000013   8009         SJMP    ??zcl_SendConfigReportCmd_0
   1379            {
   1380              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1381          
   1382              dataLen += 1 + 2; // Direction + Attribute ID
   1383          
   1384              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1385              {
   1386                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1387          
   1388                // Find out the size of the Reportable Change field (for Analog data types)
   1389                if ( zclAnalogDataType( reportRec->dataType ) )
   1390                {
   1391                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1392                }
   1393              }
   1394              else
   1395              {
   1396                dataLen += 2; // Timeout Period
   \                     ??zcl_SendConfigReportCmd_1:
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \                     ??zcl_SendConfigReportCmd_2:
   \   000018   FE           MOV     R6,A
   \   000019   E4           CLR     A
   \   00001A   3F           ADDC    A,R7
   \   00001B   FF           MOV     R7,A
   1397              }
   \                     ??zcl_SendConfigReportCmd_3:
   \   00001C   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_0:
   \   00001E   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   000021   5040         JNC     ??zcl_SendConfigReportCmd_4
   \   000023   E5..         MOV     A,?V0
   \   000025   75F00C       MOV     B,#0xc
   \   000028   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   00002B   EE           MOV     A,R6
   \   00002C   2403         ADD     A,#0x3
   \   00002E   FE           MOV     R6,A
   \   00002F   E4           CLR     A
   \   000030   3F           ADDC    A,R7
   \   000031   FF           MOV     R7,A
   \   000032   E0           MOVX    A,@DPTR
   \   000033   70E0         JNZ     ??zcl_SendConfigReportCmd_1
   \   000035   EE           MOV     A,R6
   \   000036   2405         ADD     A,#0x5
   \   000038   FE           MOV     R6,A
   \   000039   E4           CLR     A
   \   00003A   3F           ADDC    A,R7
   \   00003B   FF           MOV     R7,A
   \   00003C   E582         MOV     A,DPL
   \   00003E   2403         ADD     A,#0x3
   \   000040   F5..         MOV     ?V2,A
   \   000042   E4           CLR     A
   \   000043   3583         ADDC    A,DPH
   \   000045   F5..         MOV     ?V3,A
   \   000047                ; Setup parameters for call to function zclAnalogDataType
   \   000047   85..82       MOV     DPL,?V2
   \   00004A   F583         MOV     DPH,A
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000051   E9           MOV     A,R1
   \   000052   60C8         JZ      ??zcl_SendConfigReportCmd_3
   \   000054                ; Setup parameters for call to function zclGetDataTypeLength
   \   000054   85..82       MOV     DPL,?V2
   \   000057   85..83       MOV     DPH,?V3
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F9           MOV     R1,A
   \   00005C   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00005F   EE           MOV     A,R6
   \   000060   29           ADD     A,R1
   \   000061   80B5         SJMP    ??zcl_SendConfigReportCmd_2
   1398            }
   1399          
   1400            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendConfigReportCmd_4:
   \   000063                ; Setup parameters for call to function osal_mem_alloc
   \   000063   EE           MOV     A,R6
   \   000064   FA           MOV     R2,A
   \   000065   EF           MOV     A,R7
   \   000066   FB           MOV     R3,A
   \   000067   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00006A   8A..         MOV     ?V2,R2
   \   00006C   8B..         MOV     ?V3,R3
   1401            if ( buf != NULL )
   \   00006E   EA           MOV     A,R2
   \   00006F   45..         ORL     A,?V3
   \   000071   7003         JNZ     $+5
   \   000073   02....       LJMP    ??zcl_SendConfigReportCmd_5 & 0xFFFF
   1402            {
   1403              // Load the buffer - serially
   1404              uint8 *pBuf = buf;
   \   000076   8A..         MOV     ?V6,R2
   \   000078   8B..         MOV     ?V7,R3
   1405          
   1406              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   00007A   75..00       MOV     ?V0,#0x0
   \   00007D   801E         SJMP    ??zcl_SendConfigReportCmd_6
   1407              {
   1408                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1409          
   1410                *pBuf++ = reportRec->direction;
   1411                *pBuf++ = LO_UINT16( reportRec->attrID );
   1412                *pBuf++ = HI_UINT16( reportRec->attrID );
   1413          
   1414                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1415                {
   1416                  *pBuf++ = reportRec->dataType;
   1417                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1418                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1419                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1420                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1421          
   1422                  if ( zclAnalogDataType( reportRec->dataType ) )
   1423                  {
   1424                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1425                  }
   1426                }
   1427                else
   1428                {
   1429                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   \                     ??zcl_SendConfigReportCmd_7:
   \   00007F   E5..         MOV     A,?V4
   \   000081   2408         ADD     A,#0x8
   \   000083   F5..         MOV     ?V4,A
   \   000085   5002         JNC     ??zcl_SendConfigReportCmd_8
   \   000087   05..         INC     ?V5
   \                     ??zcl_SendConfigReportCmd_8:
   \   000089   F582         MOV     DPL,A
   \   00008B   85..83       MOV     DPH,?V5
   \   00008E   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   1430                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1431                }
   \                     ??CrossCallReturnLabel_327:
   \   000091   12....       LCALL   ??Subroutine184_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   000094   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000097   8C..         MOV     ?V6,R4
   \   000099   8D..         MOV     ?V7,R5
   \                     ??zcl_SendConfigReportCmd_9:
   \   00009B   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_6:
   \   00009D   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   0000A0   4003         JC      $+5
   \   0000A2   02....       LJMP    ??zcl_SendConfigReportCmd_10 & 0xFFFF
   \   0000A5   E5..         MOV     A,?V0
   \   0000A7   75F00C       MOV     B,#0xc
   \   0000AA   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   0000AD   A882         MOV     R0,DPL
   \   0000AF   A983         MOV     R1,DPH
   \   0000B1   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   0000B4   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   E5..         MOV     A,?V6
   \   0000BA   2405         ADD     A,#0x5
   \   0000BC   FC           MOV     R4,A
   \   0000BD   E4           CLR     A
   \   0000BE   35..         ADDC    A,?V7
   \   0000C0   FD           MOV     R5,A
   \   0000C1   E5..         MOV     A,?V6
   \   0000C3   2404         ADD     A,#0x4
   \   0000C5   FA           MOV     R2,A
   \   0000C6   E4           CLR     A
   \   0000C7   35..         ADDC    A,?V7
   \   0000C9   FB           MOV     R3,A
   \   0000CA   E5..         MOV     A,?V6
   \   0000CC   2403         ADD     A,#0x3
   \   0000CE   F8           MOV     R0,A
   \   0000CF   E4           CLR     A
   \   0000D0   35..         ADDC    A,?V7
   \   0000D2   F9           MOV     R1,A
   \   0000D3   85..82       MOV     DPL,?V4
   \   0000D6   85..83       MOV     DPH,?V5
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   70A3         JNZ     ??zcl_SendConfigReportCmd_7
   \   0000DC   E5..         MOV     A,?V4
   \   0000DE   2403         ADD     A,#0x3
   \   0000E0   F5..         MOV     ?V10,A
   \   0000E2   E4           CLR     A
   \   0000E3   35..         ADDC    A,?V5
   \   0000E5   F5..         MOV     ?V11,A
   \   0000E7   85..82       MOV     DPL,?V10
   \   0000EA   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   E5..         MOV     A,?V4
   \   0000F0   2404         ADD     A,#0x4
   \   0000F2   F5..         MOV     ?V14,A
   \   0000F4   E4           CLR     A
   \   0000F5   35..         ADDC    A,?V5
   \   0000F7   F5..         MOV     ?V15,A
   \   0000F9   85..82       MOV     DPL,?V14
   \   0000FC   F583         MOV     DPH,A
   \   0000FE   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   000101   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000104   2406         ADD     A,#0x6
   \   000106   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00010E   A3           INC     DPTR
   \   00010F   A3           INC     DPTR
   \   000110   A3           INC     DPTR
   \   000111   F0           MOVX    @DPTR,A
   \   000112   E5..         MOV     A,?V6
   \   000114   2408         ADD     A,#0x8
   \   000116   F5..         MOV     ?V6,A
   \   000118   5002         JNC     ??zcl_SendConfigReportCmd_11
   \   00011A   05..         INC     ?V7
   \                     ??zcl_SendConfigReportCmd_11:
   \   00011C                ; Setup parameters for call to function zclAnalogDataType
   \   00011C   85..82       MOV     DPL,?V10
   \   00011F   85..83       MOV     DPH,?V11
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000127   E9           MOV     A,R1
   \   000128   7003         JNZ     $+5
   \   00012A   02....       LJMP    ??zcl_SendConfigReportCmd_9 & 0xFFFF
   \   00012D                ; Setup parameters for call to function zclSerializeData
   \   00012D   AC..         MOV     R4,?V6
   \   00012F   AD..         MOV     R5,?V7
   \   000131   85..82       MOV     DPL,?V4
   \   000134   85..83       MOV     DPH,?V5
   \   000137   A3           INC     DPTR
   \   000138   A3           INC     DPTR
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   A3           INC     DPTR
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   A3           INC     DPTR
   \   000141   12....       LCALL   ?Subroutine78 & 0xFFFF
   1432              } // for loop
   \                     ??CrossCallReturnLabel_122:
   \   000144   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000147   8A..         MOV     ?V6,R2
   \   000149   8B..         MOV     ?V7,R3
   \   00014B   02....       LJMP    ??zcl_SendConfigReportCmd_9 & 0xFFFF
   1433          
   1434              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1435                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportCmd_10:
   \   00014E                ; Setup parameters for call to function zcl_SendCommand
   \   00014E   78..         MOV     R0,#?V2
   \   000150   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000153   8E..         MOV     ?V4,R6
   \   000155   8F..         MOV     ?V5,R7
   \   000157   78..         MOV     R0,#?V4
   \   000159   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015C   7422         MOV     A,#0x22
   \   00015E   12....       LCALL   ?XSTACK_DISP0_8
   \   000161   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000164   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000167   E4           CLR     A
   \   000168   F5..         MOV     ?V4,A
   \   00016A   F5..         MOV     ?V5,A
   \   00016C   78..         MOV     R0,#?V4
   \   00016E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000171   7424         MOV     A,#0x24
   \   000173   12....       LCALL   ?XSTACK_DISP0_8
   \   000176   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000179   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017C   7424         MOV     A,#0x24
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000184   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000187   75..00       MOV     ?V0,#0x0
   \   00018A   78..         MOV     R0,#?V0
   \   00018C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00018F   75..06       MOV     ?V0,#0x6
   \   000192   78..         MOV     R0,#?V0
   \   000194   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000197   AC..         MOV     R4,?V12
   \   000199   AD..         MOV     R5,?V13
   \   00019B   740B         MOV     A,#0xb
   \   00019D   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A0   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_383:
   \   0001A3   A9..         MOV     R1,?V1
   \   0001A5   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001A8   740B         MOV     A,#0xb
   \   0001AA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001AD   E9           MOV     A,R1
   \   0001AE   FE           MOV     R6,A
   1436              zcl_mem_free( buf );
   \   0001AF                ; Setup parameters for call to function osal_mem_free
   \   0001AF   AA..         MOV     R2,?V2
   \   0001B1   AB..         MOV     R3,?V3
   \   0001B3   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001B6   8002         SJMP    ??zcl_SendConfigReportCmd_12
   1437            }
   1438            else
   1439            {
   1440              status = ZMemError;
   \                     ??zcl_SendConfigReportCmd_5:
   \   0001B8   7E10         MOV     R6,#0x10
   1441            }
   1442          
   1443            return ( status );
   \                     ??zcl_SendConfigReportCmd_12:
   \   0001BA   02....       LJMP    ?Subroutine5 & 0xFFFF
   1444          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009                REQUIRE ??Subroutine180_0
   \   000009                ; // Fall through to label ??Subroutine180_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine180_0:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine181_0
   \   000006                ; // Fall through to label ??Subroutine181_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine181_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V0
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine182_0
   \   000002                ; // Fall through to label ??Subroutine182_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine182_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000003   8582..       MOV     ?V4,DPL
   \   000006   8583..       MOV     ?V5,DPH
   \   000009   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   00000C                REQUIRE ??Subroutine184_0
   \   00000C                ; // Fall through to label ??Subroutine184_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine184_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V4
   \   000004   85..83       MOV     DPH,?V5
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine163:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine173 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   85..82       MOV     DPL,?V6
   \   000008   85..83       MOV     DPH,?V7
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V14
   \   000004   85..83       MOV     DPH,?V15
   \   000007   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_361:
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   E5..         MOV     A,?V4
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   EA           MOV     A,R2
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EB           MOV     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   89..         MOV     ?V1,R1
   \   00000D   8C..         MOV     ?V12,R4
   \   00000F   8D..         MOV     ?V13,R5
   \   000011   7E00         MOV     R6,#0x0
   \   000013   7F00         MOV     R7,#0x0
   \   000015   75..00       MOV     ?V0,#0x0
   \   000018   741A         MOV     A,#0x1a
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine157:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine191_0
   \   000001                ; // Fall through to label ??Subroutine191_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine191_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET
   1445          
   1446          /*********************************************************************
   1447           * @fn      zcl_SendConfigReportRspCmd
   1448           *
   1449           * @brief   Send a Configure Reporting Response command
   1450           *
   1451           * @param   dstAddr - destination address
   1452           * @param   clusterID - cluster ID
   1453           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1454           * @param   direction - direction of the command
   1455           * @param   seqNum - transaction sequence number
   1456           *
   1457           * @return  ZSuccess if OK
   1458           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1459          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1460                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1461                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1462          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine80 & 0xFFFF
   1463            uint16 dataLen;
   1464            uint8 *buf;
   1465            ZStatus_t status;
   1466          
   1467            // Atrribute list (Status, Direction and Attribute ID)
   1468            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \                     ??CrossCallReturnLabel_127:
   \   000017   F5..         MOV     ?V0,A
   \   000019   75..00       MOV     ?V1,#0x0
   \   00001C   7402         MOV     A,#0x2
   \   00001E   78..         MOV     R0,#?V0
   \   000020   12....       LCALL   ?S_SHL
   \   000023   85....       MOV     ?V6,?V0
   \   000026   85....       MOV     ?V7,?V1
   1469          
   1470            buf = zcl_mem_alloc( dataLen );
   \   000029                ; Setup parameters for call to function osal_mem_alloc
   \   000029   AA..         MOV     R2,?V6
   \   00002B   AB..         MOV     R3,?V7
   \   00002D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000030   8A..         MOV     ?V0,R2
   \   000032   8B..         MOV     ?V1,R3
   1471            if ( buf != NULL )
   \   000034   EA           MOV     A,R2
   \   000035   45..         ORL     A,?V1
   \   000037   7003         JNZ     $+5
   \   000039   02....       LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1472            {
   1473              // Load the buffer - serially
   1474              uint8 *pBuf = buf;
   1475              uint8 i;
   1476          
   1477              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003C   7C00         MOV     R4,#0x0
   \   00003E   803D         SJMP    ??zcl_SendConfigReportRspCmd_1
   1478              {
   1479                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   000040   8C..         MOV     ?V10,R4
   \   000042   75..00       MOV     ?V11,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V10
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   E5..         MOV     A,?V4
   \   00004E   25..         ADD     A,?V10
   \   000050   F8           MOV     R0,A
   \   000051   E5..         MOV     A,?V5
   \   000053   35..         ADDC    A,?V11
   \   000055   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_415:
   \   000058   12....       LCALL   ?Subroutine32 & 0xFFFF
   1480                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \                     ??CrossCallReturnLabel_29:
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   00005F   F0           MOVX    @DPTR,A
   1481                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \   000060   E8           MOV     A,R0
   \   000061   2403         ADD     A,#0x3
   \   000063   F8           MOV     R0,A
   \   000064   5001         JNC     ??zcl_SendConfigReportRspCmd_3
   \   000066   09           INC     R1
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   000067   8882         MOV     DPL,R0
   \   000069   8983         MOV     DPH,R1
   \   00006B   12....       LCALL   ?Subroutine101 & 0xFFFF
   1482                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1483              }
   \                     ??CrossCallReturnLabel_162:
   \   00006E   A3           INC     DPTR
   \   00006F   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   F0           MOVX    @DPTR,A
   \   000075   EA           MOV     A,R2
   \   000076   2404         ADD     A,#0x4
   \   000078   FA           MOV     R2,A
   \   000079   5001         JNC     ??zcl_SendConfigReportRspCmd_4
   \   00007B   0B           INC     R3
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   00007C   0C           INC     R4
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   00007D   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000080   40BE         JC      ??zcl_SendConfigReportRspCmd_2
   1484          
   1485              // If there's only a single status record and its status field is set to
   1486              // SUCCESS then omit the attribute ID field.
   1487              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000082   7401         MOV     A,#0x1
   \   000084   68           XRL     A,R0
   \   000085   700A         JNZ     ??zcl_SendConfigReportRspCmd_5
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   7006         JNZ     ??zcl_SendConfigReportRspCmd_5
   1488              {
   1489                dataLen = 1;
   \   00008B   75..01       MOV     ?V6,#0x1
   \   00008E   75..00       MOV     ?V7,#0x0
   1490              }
   1491          
   1492              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1493                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1494                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_5:
   \   000091                ; Setup parameters for call to function zcl_SendCommand
   \   000091   78..         MOV     R0,#?V0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   78..         MOV     R0,#?V6
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009B   741C         MOV     A,#0x1c
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A6   E4           CLR     A
   \   0000A7   F5..         MOV     ?V4,A
   \   0000A9   F5..         MOV     ?V5,A
   \   0000AB   78..         MOV     R0,#?V4
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B0   741E         MOV     A,#0x1e
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BB   741E         MOV     A,#0x1e
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   0000C3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C6   75..00       MOV     ?V3,#0x0
   \   0000C9   78..         MOV     R0,#?V3
   \   0000CB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CE   75..07       MOV     ?V3,#0x7
   \   0000D1   78..         MOV     R0,#?V3
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D6   EE           MOV     A,R6
   \   0000D7   FC           MOV     R4,A
   \   0000D8   EF           MOV     A,R7
   \   0000D9   FD           MOV     R5,A
   \   0000DA   AA..         MOV     R2,?V8
   \   0000DC   AB..         MOV     R3,?V9
   \   0000DE   A9..         MOV     R1,?V2
   \   0000E0   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000E3   740B         MOV     A,#0xb
   \   0000E5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E8   E9           MOV     A,R1
   \   0000E9   FE           MOV     R6,A
   1495              zcl_mem_free( buf );
   \   0000EA                ; Setup parameters for call to function osal_mem_free
   \   0000EA   AA..         MOV     R2,?V0
   \   0000EC   AB..         MOV     R3,?V1
   \   0000EE   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000F1   8002         SJMP    ??zcl_SendConfigReportRspCmd_6
   1496            }
   1497            else
   1498            {
   1499              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0000F3   7E10         MOV     R6,#0x10
   1500            }
   1501          
   1502            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_6:
   \   0000F5                REQUIRE ?Subroutine10
   \   0000F5                ; // Fall through to label ?Subroutine10
   1503          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_414:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
   1504          
   1505          /*********************************************************************
   1506           * @fn      zcl_SendReadReportCfgCmd
   1507           *
   1508           * @brief   Send a Read Reporting Configuration command
   1509           *
   1510           * @param   dstAddr - destination address
   1511           * @param   clusterID - cluster ID
   1512           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1513           * @param   direction - direction of the command
   1514           * @param   seqNum - transaction sequence number
   1515           *
   1516           * @return  ZSuccess if OK
   1517           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1518          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgCmd:
   1519                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1520                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1521          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine56 & 0xFFFF
   1522            uint16 dataLen;
   1523            uint8 *buf;
   1524            ZStatus_t status;
   1525          
   1526            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1527          
   1528            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_80:
   \   000017   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1529            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   6078         JZ      ??zcl_SendReadReportCfgCmd_0
   1530            {
   1531              // Load the buffer - serially
   1532              uint8 *pBuf = buf;
   1533              uint8 i;
   1534          
   1535              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   000023   7C00         MOV     R4,#0x0
   \   000025   800D         SJMP    ??zcl_SendReadReportCfgCmd_1
   1536              {
   1537                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   \                     ??zcl_SendReadReportCfgCmd_2:
   \   000027   12....       LCALL   ?Subroutine92 & 0xFFFF
   1538                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1539                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1540              }
   \                     ??CrossCallReturnLabel_146:
   \   00002A   5001         JNC     ??zcl_SendReadReportCfgCmd_3
   \   00002C   09           INC     R1
   \                     ??zcl_SendReadReportCfgCmd_3:
   \   00002D   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000030   5001         JNC     ??zcl_SendReadReportCfgCmd_4
   \   000032   0B           INC     R3
   \                     ??zcl_SendReadReportCfgCmd_4:
   \   000033   0C           INC     R4
   \                     ??zcl_SendReadReportCfgCmd_1:
   \   000034   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   000037   40EE         JC      ??zcl_SendReadReportCfgCmd_2
   1541          
   1542              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1543                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000039                ; Setup parameters for call to function zcl_SendCommand
   \   000039   78..         MOV     R0,#?V0
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   78..         MOV     R0,#?V6
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   741C         MOV     A,#0x1c
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004E   E4           CLR     A
   \   00004F   F5..         MOV     ?V4,A
   \   000051   F5..         MOV     ?V5,A
   \   000053   78..         MOV     R0,#?V4
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   741E         MOV     A,#0x1e
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000063   741E         MOV     A,#0x1e
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   75..00       MOV     ?V3,#0x0
   \   000071   78..         MOV     R0,#?V3
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   75..08       MOV     ?V3,#0x8
   \   000079   78..         MOV     R0,#?V3
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007E   EE           MOV     A,R6
   \   00007F   FC           MOV     R4,A
   \   000080   EF           MOV     A,R7
   \   000081   FD           MOV     R5,A
   \   000082   AA..         MOV     R2,?V8
   \   000084   AB..         MOV     R3,?V9
   \   000086   A9..         MOV     R1,?V2
   \   000088   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00008B   740B         MOV     A,#0xb
   \   00008D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000090   E9           MOV     A,R1
   \   000091   FE           MOV     R6,A
   1544              zcl_mem_free( buf );
   \   000092                ; Setup parameters for call to function osal_mem_free
   \   000092   AA..         MOV     R2,?V0
   \   000094   AB..         MOV     R3,?V1
   \   000096   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000099   8002         SJMP    ??zcl_SendReadReportCfgCmd_5
   1545            }
   1546            else
   1547            {
   1548              status = ZMemError;
   \                     ??zcl_SendReadReportCfgCmd_0:
   \   00009B   7E10         MOV     R6,#0x10
   1549            }
   1550          
   1551            return ( status );
   \                     ??zcl_SendReadReportCfgCmd_5:
   \   00009D   02....       LJMP    ?Subroutine10 & 0xFFFF
   1552          }
   1553          
   1554          /*********************************************************************
   1555           * @fn      zcl_SendReadReportCfgRspCmd
   1556           *
   1557           * @brief   Send a Read Reporting Configuration Response command
   1558           *
   1559           * @param   dstAddr - destination address
   1560           * @param   clusterID - cluster ID
   1561           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1562           * @param   direction - direction of the command
   1563           * @param   seqNum - transaction sequence number
   1564           *
   1565           * @return  ZSuccess if OK
   1566           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1567          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1568                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1569                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1570          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine17 & 0xFFFF
   1571            uint8 *buf;
   1572            uint16 dataLen = 0;
   1573            ZStatus_t status;
   1574            uint8 i;
   1575          
   1576            // Find out the data length
   1577            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_7:
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   000013   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_0
   1578            {
   1579              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1580          
   1581              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1582          
   1583              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1584              {
   1585                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1586                {
   1587                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1588          
   1589                  // Find out the size of the Reportable Change field (for Analog data types)
   1590                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1591                  {
   1592                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1593                  }
   1594                }
   1595                else
   1596                {
   1597                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000018   FE           MOV     R6,A
   \   000019   E4           CLR     A
   \   00001A   3F           ADDC    A,R7
   \   00001B   FF           MOV     R7,A
   1598                }
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   00001C   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   00001E   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000021   5041         JNC     ??zcl_SendReadReportCfgRspCmd_4
   \   000023   E5..         MOV     A,?V0
   \   000025   75F00D       MOV     B,#0xd
   \   000028   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   00002B   2404         ADD     A,#0x4
   \   00002D   FE           MOV     R6,A
   \   00002E   E4           CLR     A
   \   00002F   3F           ADDC    A,R7
   \   000030   FF           MOV     R7,A
   \   000031   E0           MOVX    A,@DPTR
   \   000032   70E8         JNZ     ??zcl_SendReadReportCfgRspCmd_3
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   70DD         JNZ     ??zcl_SendReadReportCfgRspCmd_1
   \   000038   EE           MOV     A,R6
   \   000039   2405         ADD     A,#0x5
   \   00003B   FE           MOV     R6,A
   \   00003C   E4           CLR     A
   \   00003D   3F           ADDC    A,R7
   \   00003E   FF           MOV     R7,A
   \   00003F   E8           MOV     A,R0
   \   000040   2404         ADD     A,#0x4
   \   000042   F5..         MOV     ?V2,A
   \   000044   E4           CLR     A
   \   000045   39           ADDC    A,R1
   \   000046   F5..         MOV     ?V3,A
   \   000048                ; Setup parameters for call to function zclAnalogDataType
   \   000048   85..82       MOV     DPL,?V2
   \   00004B   F583         MOV     DPH,A
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F9           MOV     R1,A
   \   00004F   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000052   E9           MOV     A,R1
   \   000053   60C7         JZ      ??zcl_SendReadReportCfgRspCmd_3
   \   000055                ; Setup parameters for call to function zclGetDataTypeLength
   \   000055   85..82       MOV     DPL,?V2
   \   000058   85..83       MOV     DPH,?V3
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000060   EE           MOV     A,R6
   \   000061   29           ADD     A,R1
   \   000062   80B4         SJMP    ??zcl_SendReadReportCfgRspCmd_2
   1599              }
   1600            }
   1601          
   1602            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   000064                ; Setup parameters for call to function osal_mem_alloc
   \   000064   EE           MOV     A,R6
   \   000065   FA           MOV     R2,A
   \   000066   EF           MOV     A,R7
   \   000067   FB           MOV     R3,A
   \   000068   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00006B   8A..         MOV     ?V2,R2
   \   00006D   8B..         MOV     ?V3,R3
   1603            if ( buf != NULL )
   \   00006F   EA           MOV     A,R2
   \   000070   45..         ORL     A,?V3
   \   000072   7003         JNZ     $+5
   \   000074   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1604            {
   1605              // Load the buffer - serially
   1606              uint8 *pBuf = buf;
   \   000077   8A..         MOV     ?V6,R2
   \   000079   8B..         MOV     ?V7,R3
   1607          
   1608              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   00007B   75..00       MOV     ?V0,#0x0
   \   00007E   801F         SJMP    ??zcl_SendReadReportCfgRspCmd_6
   1609              {
   1610                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1611          
   1612                *pBuf++ = reportRspRec->status;
   1613                *pBuf++ = reportRspRec->direction;
   1614                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1615                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1616          
   1617                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1618                {
   1619                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1620                  {
   1621                    *pBuf++ = reportRspRec->dataType;
   1622                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1623                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1624                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1625                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1626          
   1627                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1628                    {
   1629                      pBuf = zclSerializeData( reportRspRec->dataType,
   1630                                               reportRspRec->reportableChange, pBuf );
   1631                    }
   1632                  }
   1633                  else
   1634                  {
   1635                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   000080   E5..         MOV     A,?V4
   \   000082   2409         ADD     A,#0x9
   \   000084   FA           MOV     R2,A
   \   000085   E4           CLR     A
   \   000086   35..         ADDC    A,?V5
   \   000088   FB           MOV     R3,A
   \   000089   8A82         MOV     DPL,R2
   \   00008B   8B83         MOV     DPH,R3
   \   00008D   12....       LCALL   ?Subroutine110 & 0xFFFF
   1636                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   \                     ??CrossCallReturnLabel_176:
   \   000090   8A82         MOV     DPL,R2
   \   000092   8B83         MOV     DPH,R3
   \   000094   A3           INC     DPTR
   \   000095   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   1637                  }
   \                     ??CrossCallReturnLabel_328:
   \   000098   F0           MOVX    @DPTR,A
   \   000099   8C..         MOV     ?V6,R4
   \   00009B   8D..         MOV     ?V7,R5
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   00009D   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   00009F   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   0000A2   4003         JC      $+5
   \   0000A4   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_9 & 0xFFFF
   \   0000A7   E5..         MOV     A,?V0
   \   0000A9   75F00D       MOV     B,#0xd
   \   0000AC   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   0000AF   AA82         MOV     R2,DPL
   \   0000B1   AB83         MOV     R3,DPH
   \   0000B3   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   0000B6   F0           MOVX    @DPTR,A
   \   0000B7   E5..         MOV     A,?V4
   \   0000B9   2402         ADD     A,#0x2
   \   0000BB   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   0000BE   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000C1   A3           INC     DPTR
   \   0000C2   F0           MOVX    @DPTR,A
   \   0000C3   E5..         MOV     A,?V6
   \   0000C5   2404         ADD     A,#0x4
   \   0000C7   F5..         MOV     ?V6,A
   \   0000C9   5002         JNC     ??zcl_SendReadReportCfgRspCmd_10
   \   0000CB   05..         INC     ?V7
   \                     ??zcl_SendReadReportCfgRspCmd_10:
   \   0000CD   85..82       MOV     DPL,?V4
   \   0000D0   85..83       MOV     DPH,?V5
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   70C7         JNZ     ??zcl_SendReadReportCfgRspCmd_8
   \   0000D6   E5..         MOV     A,?V6
   \   0000D8   2402         ADD     A,#0x2
   \   0000DA   FC           MOV     R4,A
   \   0000DB   E4           CLR     A
   \   0000DC   35..         ADDC    A,?V7
   \   0000DE   FD           MOV     R5,A
   \   0000DF   85..82       MOV     DPL,?V6
   \   0000E2   85..83       MOV     DPH,?V7
   \   0000E5   A3           INC     DPTR
   \   0000E6   A882         MOV     R0,DPL
   \   0000E8   A983         MOV     R1,DPH
   \   0000EA   8A82         MOV     DPL,R2
   \   0000EC   8B83         MOV     DPH,R3
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   708F         JNZ     ??zcl_SendReadReportCfgRspCmd_7
   \   0000F1   E5..         MOV     A,?V4
   \   0000F3   2404         ADD     A,#0x4
   \   0000F5   F5..         MOV     ?V10,A
   \   0000F7   E4           CLR     A
   \   0000F8   35..         ADDC    A,?V5
   \   0000FA   F5..         MOV     ?V11,A
   \   0000FC   85..82       MOV     DPL,?V10
   \   0000FF   F583         MOV     DPH,A
   \   000101   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000104   E5..         MOV     A,?V4
   \   000106   2405         ADD     A,#0x5
   \   000108   F5..         MOV     ?V14,A
   \   00010A   E4           CLR     A
   \   00010B   35..         ADDC    A,?V5
   \   00010D   F5..         MOV     ?V15,A
   \   00010F   85..82       MOV     DPL,?V14
   \   000112   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   000115   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000118   2407         ADD     A,#0x7
   \   00011A   F8           MOV     R0,A
   \   00011B   E4           CLR     A
   \   00011C   35..         ADDC    A,?V5
   \   00011E   F9           MOV     R1,A
   \   00011F   8882         MOV     DPL,R0
   \   000121   8983         MOV     DPH,R1
   \   000123   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000126   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000129   F0           MOVX    @DPTR,A
   \   00012A   E5..         MOV     A,?V6
   \   00012C   2405         ADD     A,#0x5
   \   00012E   F5..         MOV     ?V6,A
   \   000130   5002         JNC     ??zcl_SendReadReportCfgRspCmd_11
   \   000132   05..         INC     ?V7
   \                     ??zcl_SendReadReportCfgRspCmd_11:
   \   000134                ; Setup parameters for call to function zclAnalogDataType
   \   000134   85..82       MOV     DPL,?V10
   \   000137   85..83       MOV     DPH,?V11
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   F9           MOV     R1,A
   \   00013C   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00013F   E9           MOV     A,R1
   \   000140   7003         JNZ     $+5
   \   000142   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   \   000145                ; Setup parameters for call to function zclSerializeData
   \   000145   AC..         MOV     R4,?V6
   \   000147   AD..         MOV     R5,?V7
   \   000149   E5..         MOV     A,?V4
   \   00014B   240B         ADD     A,#0xb
   \   00014D   F582         MOV     DPL,A
   \   00014F   E4           CLR     A
   \   000150   35..         ADDC    A,?V5
   \   000152   F583         MOV     DPH,A
   \   000154   12....       LCALL   ?Subroutine78 & 0xFFFF
   1638                }
   1639              }
   \                     ??CrossCallReturnLabel_123:
   \   000157   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   00015A   8A..         MOV     ?V6,R2
   \   00015C   8B..         MOV     ?V7,R3
   \   00015E   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   1640          
   1641              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1642                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1643                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   000161                ; Setup parameters for call to function zcl_SendCommand
   \   000161   78..         MOV     R0,#?V2
   \   000163   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000166   8E..         MOV     ?V4,R6
   \   000168   8F..         MOV     ?V5,R7
   \   00016A   78..         MOV     R0,#?V4
   \   00016C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016F   7422         MOV     A,#0x22
   \   000171   12....       LCALL   ?XSTACK_DISP0_8
   \   000174   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000177   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017A   E4           CLR     A
   \   00017B   F5..         MOV     ?V4,A
   \   00017D   F5..         MOV     ?V5,A
   \   00017F   78..         MOV     R0,#?V4
   \   000181   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000184   7424         MOV     A,#0x24
   \   000186   12....       LCALL   ?XSTACK_DISP0_8
   \   000189   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   00018C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00018F   7424         MOV     A,#0x24
   \   000191   12....       LCALL   ?XSTACK_DISP0_8
   \   000194   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000197   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00019A   75..00       MOV     ?V0,#0x0
   \   00019D   78..         MOV     R0,#?V0
   \   00019F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001A2   75..09       MOV     ?V0,#0x9
   \   0001A5   78..         MOV     R0,#?V0
   \   0001A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001AA   AC..         MOV     R4,?V12
   \   0001AC   AD..         MOV     R5,?V13
   \   0001AE   740B         MOV     A,#0xb
   \   0001B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B3   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_384:
   \   0001B6   A9..         MOV     R1,?V1
   \   0001B8   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001BB   740B         MOV     A,#0xb
   \   0001BD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C0   E9           MOV     A,R1
   \   0001C1   FE           MOV     R6,A
   1644              zcl_mem_free( buf );
   \   0001C2                ; Setup parameters for call to function osal_mem_free
   \   0001C2   AA..         MOV     R2,?V2
   \   0001C4   AB..         MOV     R3,?V3
   \   0001C6   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001C9   8002         SJMP    ??zcl_SendReadReportCfgRspCmd_12
   1645            }
   1646            else
   1647            {
   1648              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   0001CB   7E10         MOV     R6,#0x10
   1649            }
   1650          
   1651            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_12:
   \   0001CD   02....       LJMP    ?Subroutine5 & 0xFFFF
   1652          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET
   1653          
   1654          /*********************************************************************
   1655           * @fn      zcl_SendReportCmd
   1656           *
   1657           * @brief   Send a Report command
   1658           *
   1659           * @param   dstAddr - destination address
   1660           * @param   clusterID - cluster ID
   1661           * @param   reportCmd - report command to be sent
   1662           * @param   direction - direction of the command
   1663           * @param   seqNum - transaction sequence number
   1664           *
   1665           * @return  ZSuccess if OK
   1666           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1667          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1668                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1669                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1670          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1671            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1672            uint8 *buf;
   1673            ZStatus_t status;
   1674            uint8 i;
   1675          
   1676            // calculate the size of the command
   1677            for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000013   75..00       MOV     ?V2,#0x0
   \   000016   7416         MOV     A,#0x16
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   00001E   8009         SJMP    ??CrossCallReturnLabel_210
   1678            {
   1679              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_0:
   \   000020   12....       LCALL   ?Subroutine77 & 0xFFFF
   1680          
   1681              dataLen += 2 + 1; // Attribute ID + data type
   1682          
   1683              // Attribute Data
   1684              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1685            }
   \                     ??CrossCallReturnLabel_121:
   \   000023   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000026   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000029   85..82       MOV     DPL,?V4
   \   00002C   85..83       MOV     DPH,?V5
   \   00002F   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_444:
   \   000032   40EC         JC      ??zcl_SendReportCmd_0
   1686          
   1687            buf = zcl_mem_alloc( dataLen );
   \   000034                ; Setup parameters for call to function osal_mem_alloc
   \   000034   EE           MOV     A,R6
   \   000035   FA           MOV     R2,A
   \   000036   EF           MOV     A,R7
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V0,R2
   \   00003D   8B..         MOV     ?V1,R3
   1688            if ( buf != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V1
   \   000042   7003         JNZ     $+5
   \   000044   02....       LJMP    ??zcl_SendReportCmd_1 & 0xFFFF
   1689            {
   1690              // Load the buffer - serially
   1691              uint8 *pBuf = buf;
   \   000047   A8..         MOV     R0,?V0
   \   000049   A9..         MOV     R1,?V1
   1692          
   1693              for ( i = 0; i < reportCmd->numAttr; i++ )
   \   00004B   75..00       MOV     ?V2,#0x0
   \   00004E   8010         SJMP    ??zcl_SendReportCmd_2
   1694              {
   1695                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_3:
   \   000050   12....       LCALL   ?Subroutine13 & 0xFFFF
   1696          
   1697                *pBuf++ = LO_UINT16( reportRec->attrID );
   1698                *pBuf++ = HI_UINT16( reportRec->attrID );
   1699                *pBuf++ = reportRec->dataType;
   1700          
   1701                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1702              }
   \                     ??CrossCallReturnLabel_1:
   \   000053   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000056   8A..         MOV     ?V10,R2
   \   000058   8B..         MOV     ?V11,R3
   \   00005A   A8..         MOV     R0,?V10
   \   00005C   A9..         MOV     R1,?V11
   \   00005E   05..         INC     ?V2
   \                     ??zcl_SendReportCmd_2:
   \   000060   85..82       MOV     DPL,?V4
   \   000063   85..83       MOV     DPH,?V5
   \   000066   E0           MOVX    A,@DPTR
   \   000067   FA           MOV     R2,A
   \   000068   E5..         MOV     A,?V2
   \   00006A   C3           CLR     C
   \   00006B   9A           SUBB    A,R2
   \   00006C   40E2         JC      ??zcl_SendReportCmd_3
   1703          
   1704              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1705                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00006E                ; Setup parameters for call to function zcl_SendCommand
   \   00006E   78..         MOV     R0,#?V0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   8E..         MOV     ?V4,R6
   \   000075   8F..         MOV     ?V5,R7
   \   000077   78..         MOV     R0,#?V4
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   741E         MOV     A,#0x1e
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_467:
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000087   E4           CLR     A
   \   000088   F5..         MOV     ?V4,A
   \   00008A   F5..         MOV     ?V5,A
   \   00008C   78..         MOV     R0,#?V4
   \   00008E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000091   7420         MOV     A,#0x20
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_468:
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009C   7420         MOV     A,#0x20
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_469:
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   75..00       MOV     ?V2,#0x0
   \   0000AA   78..         MOV     R0,#?V2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AF   75..0A       MOV     ?V2,#0xa
   \   0000B2   78..         MOV     R0,#?V2
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B7   AC..         MOV     R4,?V6
   \   0000B9   AD..         MOV     R5,?V7
   \   0000BB   AA..         MOV     R2,?V8
   \   0000BD   AB..         MOV     R3,?V9
   \   0000BF   A9..         MOV     R1,?V3
   \   0000C1   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000C4   740B         MOV     A,#0xb
   \   0000C6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C9   E9           MOV     A,R1
   \   0000CA   FE           MOV     R6,A
   1706              zcl_mem_free( buf );
   \   0000CB                ; Setup parameters for call to function osal_mem_free
   \   0000CB   AA..         MOV     R2,?V0
   \   0000CD   AB..         MOV     R3,?V1
   \   0000CF   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D2   8002         SJMP    ??zcl_SendReportCmd_4
   1707            }
   1708            else
   1709            {
   1710              status = ZMemError;
   \                     ??zcl_SendReportCmd_1:
   \   0000D4   7E10         MOV     R6,#0x10
   1711            }
   1712          
   1713            return ( status );
   \                     ??zcl_SendReportCmd_4:
   \   0000D6   02....       LJMP    ?Subroutine12 & 0xFFFF
   1714          }
   1715          #endif // ZCL_REPORT
   1716          
   1717          /*********************************************************************
   1718           * @fn      zcl_SendDefaultRspCmd
   1719           *
   1720           * @brief   Send a Default Response command
   1721           *
   1722           *          Note: The manufacturer code field should be set if this
   1723           *          command is being sent in response to a manufacturer specific
   1724           *          command.
   1725           *
   1726           * @param   dstAddr - destination address
   1727           * @param   clusterID - cluster ID
   1728           * @param   defaultRspCmd - default response command to be sent
   1729           * @param   direction - direction of the command
   1730           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1731           * @param   seqNum - transaction sequence number
   1732           *
   1733           * @return  ZSuccess if OK
   1734           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1735          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1736                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1737                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1738          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine96 & 0xFFFF
   1739            uint8 buf[2]; // Command ID and Status;
   1740          
   1741            // Load the buffer - serially
   1742            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_151:
   \   000014   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000017   12....       LCALL   ?Subroutine32 & 0xFFFF
   1743            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_30:
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   C0E0         PUSH    A
   \   00001D   7401         MOV     A,#0x1
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   D0E0         POP     A
   \   000024   F0           MOVX    @DPTR,A
   1744          
   1745            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1746                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000025                ; Setup parameters for call to function zcl_SendCommand
   \   000025   A8..         MOV     R0,?XSP + 0
   \   000027   A9..         MOV     R1,?XSP + 1
   \   000029   88..         MOV     ?V0,R0
   \   00002B   89..         MOV     ?V1,R1
   \   00002D   78..         MOV     R0,#?V0
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75..02       MOV     ?V0,#0x2
   \   000035   75..00       MOV     ?V1,#0x0
   \   000038   78..         MOV     R0,#?V0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7416         MOV     A,#0x16
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000048   7415         MOV     A,#0x15
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000050   7416         MOV     A,#0x16
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005B   7416         MOV     A,#0x16
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000066   75..00       MOV     ?V0,#0x0
   \   000069   78..         MOV     R0,#?V0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   75..0B       MOV     ?V0,#0xb
   \   000071   78..         MOV     R0,#?V0
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   EE           MOV     A,R6
   \   000077   F9           MOV     R1,A
   \   000078   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00007B   740B         MOV     A,#0xb
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   02....       LJMP    ?Subroutine3 & 0xFFFF
   1747          }
   1748          
   1749          #ifdef ZCL_DISCOVER
   1750          /*********************************************************************
   1751           * @fn      zcl_SendDiscoverCmdsCmd
   1752           *
   1753           * @brief   Send a Discover Commands command
   1754           *
   1755           * @param   dstAddr - destination address
   1756           * @param   clusterID - cluster ID
   1757           * @param   cmdType - requesting command ID
   1758           * @param   pDiscoverCmd - discover command to be sent
   1759           * @param   direction - direction of the command
   1760           * @param   seqNum - transaction sequence number
   1761           *
   1762           * @return  ZSuccess if OK
   1763           */
   1764          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1765                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1766                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1767          {
   1768            uint8 payload[2]; // size of startCmdID and maxCmdID
   1769            ZStatus_t status;
   1770          
   1771            payload[0] = pDiscoverCmd->startCmdID;
   1772            payload[1] = pDiscoverCmd->maxCmdID;
   1773          
   1774            // Send message for either commands received or generated
   1775            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1776            {
   1777              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1778                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1779            }
   1780            else  // generated
   1781            {
   1782              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1783                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1784            }
   1785          
   1786            return ( status );
   1787          }
   1788          
   1789          /*********************************************************************
   1790           * @fn      zcl_SendDiscoverCmdsRspCmd
   1791           *
   1792           * @brief   Send a Discover Commands Response command
   1793           *
   1794           * @param   dstAddr - destination address
   1795           * @param   clusterID - cluster ID
   1796           * @param   pDiscoverRspCmd - response command to be sent
   1797           * @param   direction - direction of the command
   1798           * @param   seqNum - transaction sequence number
   1799           *
   1800           * @return  ZSuccess if OK
   1801           */
   1802          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1803                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1804                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1805          {
   1806            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1807            uint8 *pCmdBuf;
   1808            uint8 i;
   1809            ZStatus_t status = ZSuccess;
   1810          
   1811            // allocate memory
   1812            pCmdBuf = zcl_mem_alloc( payloadSize );
   1813            if ( pCmdBuf != NULL )
   1814            {
   1815              uint8 *pBuf = pCmdBuf;
   1816          
   1817              // Load the buffer - serially
   1818              *pBuf++ = pDiscoverRspCmd->discComplete;
   1819              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1820              {
   1821                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1822              }
   1823          
   1824              // Send response message for either commands received or generated
   1825              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1826              {
   1827                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1828                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1829              }
   1830              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1831              {
   1832                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1833                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1834              }
   1835          
   1836              zcl_mem_free( pCmdBuf );
   1837            }
   1838            else
   1839            {
   1840              status = ZMemError;
   1841            }
   1842          
   1843            return ( status );
   1844          }
   1845          
   1846          /*********************************************************************
   1847           * @fn      zcl_SendDiscoverAttrsCmd
   1848           *
   1849           * @brief   Send a Discover Attributes command
   1850           *
   1851           * @param   dstAddr - destination address
   1852           * @param   clusterID - cluster ID
   1853           * @param   pDiscoverCmd - discover command to be sent
   1854           * @param   direction - direction of the command
   1855           * @param   seqNum - transaction sequence number
   1856           *
   1857           * @return  ZSuccess if OK
   1858           */
   1859          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1860                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1861                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1862          {
   1863            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1864            uint8 *buf;
   1865            ZStatus_t status;
   1866          
   1867            buf = zcl_mem_alloc( dataLen );
   1868            if ( buf != NULL )
   1869            {
   1870              // Load the buffer - serially
   1871              uint8 *pBuf = buf;
   1872              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1873              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1874              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1875          
   1876              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1877                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1878              zcl_mem_free( buf );
   1879            }
   1880            else
   1881            {
   1882              status = ZMemError;
   1883            }
   1884          
   1885            return ( status );
   1886          }
   1887          
   1888          /*********************************************************************
   1889           * @fn      zcl_SendDiscoverAttrsRspCmd
   1890           *
   1891           * @brief   Send a Discover Attributes Response command
   1892           *
   1893           * @param   dstAddr - destination address
   1894           * @param   clusterID - cluster ID
   1895           * @param   reportRspCmd - report response command to be sent
   1896           * @param   direction - direction of the command
   1897           * @param   seqNum - transaction sequence number
   1898           *
   1899           * @return  ZSuccess if OK
   1900           */
   1901          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1902                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1903                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1904          {
   1905            uint16 dataLen = 1; // Discovery complete
   1906            uint8 *buf;
   1907            ZStatus_t status;
   1908          
   1909            // calculate the size of the command
   1910            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1911          
   1912            buf = zcl_mem_alloc( dataLen );
   1913            if ( buf != NULL )
   1914            {
   1915              // Load the buffer - serially
   1916              uint8 i;
   1917              uint8 *pBuf = buf;
   1918          
   1919              *pBuf++ = pDiscoverRspCmd->discComplete;
   1920          
   1921              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1922              {
   1923                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1924                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1925                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1926              }
   1927          
   1928              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1929                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1930              zcl_mem_free( buf );
   1931            }
   1932            else
   1933            {
   1934              status = ZMemError;
   1935            }
   1936          
   1937            return ( status );
   1938          }
   1939          
   1940          /*********************************************************************
   1941           * @fn      zcl_SendDiscoverAttrsExt
   1942           *
   1943           * @brief   Send a Discover Attributes Extended command
   1944           *
   1945           * @param   dstAddr - destination address
   1946           * @param   clusterID - cluster ID
   1947           * @param   pDiscoverAttrsExt:
   1948           *            - startAttrID: the first attribute to be selected
   1949           *            - maxAttrIDs: maximum number of returned attributes
   1950           * @param   direction - direction of the command
   1951           * @param   seqNum - transaction sequence number
   1952           *
   1953           * @return  ZSuccess if OK
   1954           */
   1955          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1956                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1957                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1958          {
   1959            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1960            ZStatus_t status;
   1961          
   1962            // Load the buffer - serially
   1963            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1964            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1965            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1966          
   1967            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1968                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1969          
   1970            return ( status );
   1971          }
   1972          
   1973          /*********************************************************************
   1974           * @fn      zcl_SendDiscoverAttrsExtRsp
   1975           *
   1976           * @brief   Send a Discover Attributes Extended Response command
   1977           *
   1978           * @param   dstAddr - destination address
   1979           * @param   clusterID - cluster ID
   1980           * @param   pDiscoverRspCmd:
   1981           *            - discComplete: indicates whether all requested attributes returned
   1982           *            - attrID: attribute ID
   1983           *            - attrDataType: data type of the given attribute
   1984           *            - attrAccessControl: access control of the given attribute
   1985           * @param   direction - direction of the command
   1986           * @param   seqNum - transaction sequence number
   1987           *
   1988           * @return  ZSuccess if OK
   1989           */
   1990          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1991                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1992                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1993          {
   1994            uint8 *buf;
   1995            uint8 i;
   1996            uint16 dataLen = 1; // Discovery complete
   1997            ZStatus_t status;
   1998          
   1999            // calculate the size of the command
   2000            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   2001          
   2002            buf = zcl_mem_alloc( dataLen );
   2003            if ( buf != NULL )
   2004            {
   2005              // Load the buffer - serially
   2006              uint8 *pBuf = buf;
   2007              *pBuf++ = pDiscoverRspCmd->discComplete;
   2008              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   2009              {
   2010                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2011                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2012                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   2013                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   2014              }
   2015          
   2016              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   2017                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   2018              zcl_mem_free( buf );
   2019            }
   2020            else
   2021            {
   2022              status = ZMemError;
   2023            }
   2024          
   2025            return ( status );
   2026          }
   2027          #endif // ZCL_DISCOVER
   2028          
   2029          /*********************************************************************
   2030           * @fn      zcl_ProcessMessageMSG
   2031           *
   2032           * @brief   Data message processor callback.  This function processes
   2033           *          any incoming data - probably from other devices.  So, based
   2034           *          on cluster ID, perform the intended action.
   2035           *
   2036           * @param   pkt - incoming message
   2037           *
   2038           * @return  zclProcMsgStatus_t
   2039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2040          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   2041          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2042            endPointDesc_t *epDesc;
   2043            zclIncoming_t inMsg;
   2044            zclLibPlugin_t *pInPlugin;
   2045            zclDefaultRspCmd_t defautlRspCmd;
   2046            uint8 options;
   2047            uint8 securityEnable;
   2048            uint8 interPanMsg;
   2049            ZStatus_t status = ZFailure;
   2050            uint8 defaultResponseSent = FALSE;
   \   00000E   75..00       MOV     ?V2,#0x0
   2051          
   2052            if ( pkt->cmd.DataLength < ZCL_VALID_MIN_HEADER_LEN  )
   \   000011   EE           MOV     A,R6
   \   000012   2420         ADD     A,#0x20
   \   000014   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000017   C3           CLR     C
   \   000018   E0           MOVX    A,@DPTR
   \   000019   9403         SUBB    A,#0x3
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   9400         SUBB    A,#0x0
   \   00001F   5005         JNC     ??zcl_ProcessMessageMSG_0
   2053            {
   2054              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   000021   7901         MOV     R1,#0x1
   \   000023   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2055            }
   2056          
   2057            // Initialize
   2058            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   000026   90....       MOV     DPTR,#rawAFMsg
   \   000029   EE           MOV     A,R6
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   EF           MOV     A,R7
   \   00002D   F0           MOVX    @DPTR,A
   2059            inMsg.msg = pkt;
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   EE           MOV     A,R6
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   EF           MOV     A,R7
   \   000037   F0           MOVX    @DPTR,A
   2060            inMsg.attrCmd = NULL;
   \   000038   740E         MOV     A,#0xe
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E4           CLR     A
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   F0           MOVX    @DPTR,A
   2061            inMsg.pData = NULL;
   \   000041   740A         MOV     A,#0xa
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E4           CLR     A
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
   2062            inMsg.pDataLen = 0;
   \   00004A   740C         MOV     A,#0xc
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   E4           CLR     A
   \   000050   F0           MOVX    @DPTR,A
   \   000051   A3           INC     DPTR
   \   000052   F0           MOVX    @DPTR,A
   2063          
   2064            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000053   EE           MOV     A,R6
   \   000054   2422         ADD     A,#0x22
   \   000056   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000059   12....       LCALL   ??Subroutine220_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_515:
   \   00005C   7404         MOV     A,#0x4
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   `??zclParseHdr::?relay`; Banked call to: zclParseHdr
   \   000068   8A..         MOV     ?V6,R2
   \   00006A   8B..         MOV     ?V7,R3
   \   00006C   A8..         MOV     R0,?V6
   \   00006E   A9..         MOV     R1,?V7
   \   000070   740A         MOV     A,#0xa
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   2065            inMsg.pDataLen = pkt->cmd.DataLength;
   2066            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_480:
   \   000078   85..82       MOV     DPL,?V4
   \   00007B   85..83       MOV     DPH,?V5
   \   00007E   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   000081   EA           MOV     A,R2
   \   000082   C3           CLR     C
   \   000083   98           SUBB    A,R0
   \   000084   F8           MOV     R0,A
   \   000085   EB           MOV     A,R3
   \   000086   99           SUBB    A,R1
   \   000087   F9           MOV     R1,A
   \   000088   85..82       MOV     DPL,?V0
   \   00008B   85..83       MOV     DPH,?V1
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   28           ADD     A,R0
   \   000090   F8           MOV     R0,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   39           ADDC    A,R1
   \   000094   F9           MOV     R1,A
   \   000095   740C         MOV     A,#0xc
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   2067          
   2068            // Temporary workaround to allow callback functions access to the
   2069            // transaction sequence number.  Callback functions will call
   2070            // zcl_getParsedTransSeqNum() to retrieve this number.
   2071            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_481:
   \   00009D   7408         MOV     A,#0x8
   \   00009F   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   0000A6   F0           MOVX    @DPTR,A
   2072          
   2073            // Find the wanted endpoint
   2074            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000A7   EE           MOV     A,R6
   \   0000A8   2414         ADD     A,#0x14
   \   0000AA   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   F9           MOV     R1,A
   \   0000AF   12....       LCALL   `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   0000B2   8A82         MOV     DPL,R2
   \   0000B4   8B83         MOV     DPH,R3
   2075            if ( epDesc == NULL )
   \   0000B6   E582         MOV     A,DPL
   \   0000B8   4583         ORL     A,DPH
   \   0000BA   700C         JNZ     ??zcl_ProcessMessageMSG_2
   2076            {
   2077              rawAFMsg = NULL;
   \   0000BC   90....       MOV     DPTR,#rawAFMsg
   \   0000BF   E4           CLR     A
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   F0           MOVX    @DPTR,A
   2078              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000C3   7902         MOV     R1,#0x2
   \   0000C5   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2079            }
   2080          
   2081            if ( ( epDesc->simpleDesc == NULL ) ||
   2082                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   2083                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000C8   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   0000CB   602B         JZ      ??zcl_ProcessMessageMSG_3
   \   0000CD   EE           MOV     A,R6
   \   0000CE   2404         ADD     A,#0x4
   \   0000D0   F5..         MOV     ?V4,A
   \   0000D2   E4           CLR     A
   \   0000D3   3F           ADDC    A,R7
   \   0000D4   F5..         MOV     ?V5,A
   \   0000D6                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000D6   A3           INC     DPTR
   \   0000D7   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000DA   740B         MOV     A,#0xb
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   FD           MOV     R5,A
   \   0000E1   7406         MOV     A,#0x6
   \   0000E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   5403         ANL     A,#0x3
   \   0000E9   FC           MOV     R4,A
   \   0000EA   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   0000ED   12....       LCALL   `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   0000F0   7402         MOV     A,#0x2
   \   0000F2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F5   E9           MOV     A,R1
   \   0000F6   700C         JNZ     ??zcl_ProcessMessageMSG_4
   2084            {
   2085              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   0000F8   90....       MOV     DPTR,#rawAFMsg
   \   0000FB   E4           CLR     A
   \   0000FC   F0           MOVX    @DPTR,A
   \   0000FD   A3           INC     DPTR
   \   0000FE   F0           MOVX    @DPTR,A
   2086              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   0000FF   7903         MOV     R1,#0x3
   \   000101   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2087            }
   2088          
   2089          #if defined ( INTER_PAN )
   2090            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   2091            {
   2092              // No foundation command is supported thru Inter-PAN communication.
   2093              // But the Light Link cluster uses a different Frame Control format
   2094              // for it's Inter-PAN messages, where the messages could be confused
   2095              // with the foundation commands.
   2096              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   2097              {
   2098                rawAFMsg = NULL;
   2099                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   2100              }
   2101          
   2102              interPanMsg = TRUE;
   2103              options = AF_TX_OPTIONS_NONE;
   2104            }
   2105            else
   2106          #endif
   2107            {
   2108              interPanMsg = FALSE;
   2109              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   000104                ; Setup parameters for call to function zclGetClusterOption
   \   000104   12....       LCALL   ?Subroutine60 & 0xFFFF
   2110            }
   \                     ??CrossCallReturnLabel_98:
   \   000107   12....       LCALL   `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00010A   E9           MOV     A,R1
   \   00010B   F5..         MOV     ?V3,A
   2111          
   2112            // Find the appropriate plugin
   2113            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   00010D   85..82       MOV     DPL,?V4
   \   000110   85..83       MOV     DPH,?V5
   \   000113   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_386:
   \   000116   EA           MOV     A,R2
   \   000117   FC           MOV     R4,A
   \   000118   EB           MOV     A,R3
   \   000119   FD           MOV     R5,A
   \   00011A   90....       MOV     DPTR,#plugins
   \   00011D   8004         SJMP    ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   00011F   8882         MOV     DPL,R0
   \   000121   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   000123   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   000126   7003         JNZ     $+5
   \   000128   02....       LJMP    ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   00012B   8882         MOV     DPL,R0
   \   00012D   8983         MOV     DPH,R1
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_404:
   \   000134   C3           CLR     C
   \   000135   EC           MOV     A,R4
   \   000136   95..         SUBB    A,?V6
   \   000138   ED           MOV     A,R5
   \   000139   95..         SUBB    A,?V7
   \   00013B   40E2         JC      ??zcl_ProcessMessageMSG_6
   \   00013D   8882         MOV     DPL,R0
   \   00013F   8983         MOV     DPH,R1
   \   000141   A3           INC     DPTR
   \   000142   A3           INC     DPTR
   \   000143   A3           INC     DPTR
   \   000144   A3           INC     DPTR
   \   000145   C3           CLR     C
   \   000146   E0           MOVX    A,@DPTR
   \   000147   9C           SUBB    A,R4
   \   000148   A3           INC     DPTR
   \   000149   E0           MOVX    A,@DPTR
   \   00014A   9D           SUBB    A,R5
   \   00014B   40D2         JC      ??zcl_ProcessMessageMSG_6
   \   00014D   E8           MOV     A,R0
   \   00014E   FC           MOV     R4,A
   \   00014F   E9           MOV     A,R1
   \   000150   FD           MOV     R5,A
   \   000151   7404         MOV     A,#0x4
   \   000153   12....       LCALL   ?XSTACK_DISP0_8
   \   000156   E0           MOVX    A,@DPTR
   \   000157   5407         ANL     A,#0x7
   \   000159   700D         JNZ     ??zcl_ProcessMessageMSG_8
   \   00015B   7409         MOV     A,#0x9
   \   00015D   12....       LCALL   ?XSTACK_DISP0_8
   \   000160   E0           MOVX    A,@DPTR
   \   000161   640B         XRL     A,#0xb
   \   000163   7003         JNZ     $+5
   \   000165   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2114          
   2115            // Local and remote Security options must match except for Default Response command
   2116            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   2117            {
   2118              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   000168   E5..         MOV     A,?V3
   \   00016A   A2E6         MOV     C,0xE0 /* A   */.6
   \   00016C   4003         JC      $+5
   \   00016E   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   000171   EE           MOV     A,R6
   \   000172   2419         ADD     A,#0x19
   \   000174   F582         MOV     DPL,A
   \   000176   E4           CLR     A
   \   000177   3F           ADDC    A,R7
   \   000178   F583         MOV     DPH,A
   \   00017A   E0           MOVX    A,@DPTR
   \   00017B   6003         JZ      $+5
   \   00017D   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2119          
   2120              // Make sure that Clusters specifically defined to use security are received secure,
   2121              // any other cluster that wants to use APS security will be allowed
   2122              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   2123              {
   2124                if ( UNICAST_MSG( inMsg.msg ) )
   \   000180   7402         MOV     A,#0x2
   \   000182   12....       LCALL   ?XSTACK_DISP0_8
   \   000185   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000188   707D         JNZ     ??zcl_ProcessMessageMSG_10
   \   00018A   7402         MOV     A,#0x2
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_375:
   \   000192   7073         JNZ     ??zcl_ProcessMessageMSG_10
   2125                {
   2126                  // Send a Default Response command back with no Application Link Key security
   2127                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   000194                ; Setup parameters for call to function zclSetSecurityOption
   \   000194   7C00         MOV     R4,#0x0
   \   000196   85..82       MOV     DPL,?V0
   \   000199   85..83       MOV     DPH,?V1
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   F9           MOV     R1,A
   \   00019E   12....       LCALL   `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2128          
   2129                  defautlRspCmd.statusCode = status;
   \   0001A1   7401         MOV     A,#0x1
   \   0001A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A6   7401         MOV     A,#0x1
   \   0001A8   F0           MOVX    @DPTR,A
   2130                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001A9   7409         MOV     A,#0x9
   \   0001AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AE   12....       LCALL   ?Subroutine90 & 0xFFFF
   2131                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2132                                         inMsg.msg->clusterId, &defautlRspCmd,
   2133                                         !inMsg.hdr.fc.direction, true,
   2134                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_139:
   \   0001B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B4   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_470:
   \   0001B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001BA   7407         MOV     A,#0x7
   \   0001BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BF   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001C2   75..01       MOV     ?V2,#0x1
   \   0001C5   78..         MOV     R0,#?V2
   \   0001C7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001CA   7408         MOV     A,#0x8
   \   0001CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CF   12....       LCALL   ??Subroutine216_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_488:
   \   0001D2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D5   7405         MOV     A,#0x5
   \   0001D7   12....       LCALL   ?XSTACK_DISP100_8
   \   0001DA   88..         MOV     ?V2,R0
   \   0001DC   89..         MOV     ?V3,R1
   \   0001DE   78..         MOV     R0,#?V2
   \   0001E0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001E3   7409         MOV     A,#0x9
   \   0001E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E8   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   0001EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EE   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   0001F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F4   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   0001F7   12....       LCALL   `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   0001FA   7407         MOV     A,#0x7
   \   0001FC   12....       LCALL   ?DEALLOC_XSTACK8
   2135          
   2136                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   0001FF                ; Setup parameters for call to function zclSetSecurityOption
   \   0001FF   7C01         MOV     R4,#0x1
   \   000201   12....       LCALL   ?Subroutine60 & 0xFFFF
   2137                }
   \                     ??CrossCallReturnLabel_99:
   \   000204   12....       LCALL   `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2138          
   2139                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   000207   90....       MOV     DPTR,#rawAFMsg
   \   00020A   E4           CLR     A
   \   00020B   F0           MOVX    @DPTR,A
   \   00020C   A3           INC     DPTR
   \   00020D   F0           MOVX    @DPTR,A
   2140                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   00020E   7905         MOV     R1,#0x5
   \   000210   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2141              }
   2142            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   000213   7C00         MOV     R4,#0x0
   \   000215   7D00         MOV     R5,#0x0
   2143          
   2144            // Is this a foundation type message
   2145            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   000217   7404         MOV     A,#0x4
   \   000219   12....       LCALL   ?XSTACK_DISP0_8
   \   00021C   E0           MOVX    A,@DPTR
   \   00021D   F8           MOV     R0,A
   \   00021E   5403         ANL     A,#0x3
   \   000220   6003         JZ      $+5
   \   000222   02....       LJMP    ??zcl_ProcessMessageMSG_11 & 0xFFFF
   2146            {
   2147              if ( inMsg.hdr.fc.manuSpecific )
   \   000225   E8           MOV     A,R0
   \   000226   5404         ANL     A,#0x4
   \   000228   6005         JZ      ??zcl_ProcessMessageMSG_12
   2148              {
   2149                // We don't support any manufacturer specific command
   2150                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   00022A   7E84         MOV     R6,#-0x7c
   \   00022C   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   2151              }
   2152              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2153                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   00022F   7409         MOV     A,#0x9
   \   000231   12....       LCALL   ?XSTACK_DISP0_8
   \   000234   E0           MOVX    A,@DPTR
   \   000235   F5..         MOV     ?V4,A
   \   000237   C3           CLR     C
   \   000238   9417         SUBB    A,#0x17
   \   00023A   4003         JC      $+5
   \   00023C   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   00023F   75..00       MOV     ?V5,#0x0
   \   000242   7402         MOV     A,#0x2
   \   000244   78..         MOV     R0,#?V4
   \   000246   12....       LCALL   ?S_SHL
   \   000249   74..         MOV     A,#zclCmdTable & 0xff
   \   00024B   25..         ADD     A,?V4
   \   00024D   F582         MOV     DPL,A
   \   00024F   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   000251   35..         ADDC    A,?V5
   \   000253   F583         MOV     DPH,A
   \   000255   E4           CLR     A
   \   000256   93           MOVC    A,@A+DPTR
   \   000257   F8           MOV     R0,A
   \   000258   7401         MOV     A,#0x1
   \   00025A   93           MOVC    A,@A+DPTR
   \   00025B   F9           MOV     R1,A
   \   00025C   E8           MOV     A,R0
   \   00025D   49           ORL     A,R1
   \   00025E   7003         JNZ     $+5
   \   000260   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   2154              {
   2155                zclParseCmd_t parseCmd;
   2156          
   2157                parseCmd.endpoint = pkt->endPoint;
   \   000263   85..82       MOV     DPL,?V0
   \   000266   85..83       MOV     DPH,?V1
   \   000269   E0           MOVX    A,@DPTR
   \   00026A   C0E0         PUSH    A
   \   00026C   7410         MOV     A,#0x10
   \   00026E   12....       LCALL   ?XSTACK_DISP0_8
   \   000271   D0E0         POP     A
   \   000273   F0           MOVX    @DPTR,A
   2158                parseCmd.dataLen = inMsg.pDataLen;
   \   000274   740C         MOV     A,#0xc
   \   000276   12....       LCALL   ?XSTACK_DISP0_8
   \   000279   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   00027C   7411         MOV     A,#0x11
   \   00027E   12....       LCALL   ?XSTACK_DISP0_8
   \   000281   12....       LCALL   ??Subroutine225_0 & 0xFFFF
   2159                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_539:
   \   000284   740A         MOV     A,#0xa
   \   000286   12....       LCALL   ?XSTACK_DISP0_8
   \   000289   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_388:
   \   00028C   7413         MOV     A,#0x13
   \   00028E   12....       LCALL   ?XSTACK_DISP0_8
   \   000291   12....       LCALL   ??Subroutine225_0 & 0xFFFF
   2160          
   2161                // Parse the command, remember that the return value is a pointer to allocated memory
   2162                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_540:
   \   000294                ; Setup parameters for indirect call
   \   000294   7410         MOV     A,#0x10
   \   000296   12....       LCALL   ?XSTACK_DISP101_8
   \   000299   8882         MOV     DPL,R0
   \   00029B   8983         MOV     DPH,R1
   \   00029D   12....       LCALL   ?CALL_IND
   \   0002A0   8A..         MOV     ?V0,R2
   \   0002A2   8B..         MOV     ?V1,R3
   \   0002A4   A8..         MOV     R0,?V0
   \   0002A6   A9..         MOV     R1,?V1
   \   0002A8   740E         MOV     A,#0xe
   \   0002AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AD   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   2163                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_482:
   \   0002B0   E8           MOV     A,R0
   \   0002B1   49           ORL     A,R1
   \   0002B2   604C         JZ      ??zcl_ProcessMessageMSG_15
   \   0002B4   7409         MOV     A,#0x9
   \   0002B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B9   E0           MOVX    A,@DPTR
   \   0002BA   F5..         MOV     ?V0,A
   \   0002BC   75..00       MOV     ?V1,#0x0
   \   0002BF   7402         MOV     A,#0x2
   \   0002C1   78..         MOV     R0,#?V0
   \   0002C3   12....       LCALL   ?S_SHL
   \   0002C6   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   0002C8   25..         ADD     A,?V0
   \   0002CA   F582         MOV     DPL,A
   \   0002CC   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002CE   35..         ADDC    A,?V1
   \   0002D0   F583         MOV     DPH,A
   \   0002D2   E4           CLR     A
   \   0002D3   93           MOVC    A,@A+DPTR
   \   0002D4   F8           MOV     R0,A
   \   0002D5   7401         MOV     A,#0x1
   \   0002D7   93           MOVC    A,@A+DPTR
   \   0002D8   F9           MOV     R1,A
   \   0002D9   8882         MOV     DPL,R0
   \   0002DB   8983         MOV     DPH,R1
   \   0002DD   E582         MOV     A,DPL
   \   0002DF   4583         ORL     A,DPH
   \   0002E1   6012         JZ      ??zcl_ProcessMessageMSG_16
   2164                {
   2165                  // Process the command
   2166                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0002E3                ; Setup parameters for indirect call
   \   0002E3   7402         MOV     A,#0x2
   \   0002E5   12....       LCALL   ?XSTACK_DISP101_8
   \   0002E8   12....       LCALL   ?CALL_IND
   2167                  {
   2168                    // Couldn't find attribute in the table.
   2169                  }
   2170                }
   2171          
   2172                // Free the buffer
   2173                if ( inMsg.attrCmd )
   \   0002EB   740E         MOV     A,#0xe
   \   0002ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F0   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_370:
   \   0002F3   600B         JZ      ??zcl_ProcessMessageMSG_15
   2174                {
   2175                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   0002F5                ; Setup parameters for call to function osal_mem_free
   \   0002F5   740E         MOV     A,#0xe
   \   0002F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002FA   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   2176                }
   \                     ??CrossCallReturnLabel_389:
   \   0002FD   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2177          
   2178                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_15:
   \   000300   7409         MOV     A,#0x9
   \   000302   12....       LCALL   ?XSTACK_DISP0_8
   \   000305   E0           MOVX    A,@DPTR
   \   000306   F8           MOV     R0,A
   \   000307   6054         JZ      ??zcl_ProcessMessageMSG_17
   \   000309   7402         MOV     A,#0x2
   \   00030B   68           XRL     A,R0
   \   00030C   604F         JZ      ??zcl_ProcessMessageMSG_17
   \   00030E   7403         MOV     A,#0x3
   \   000310   68           XRL     A,R0
   \   000311   604A         JZ      ??zcl_ProcessMessageMSG_17
   \   000313   7406         MOV     A,#0x6
   \   000315   68           XRL     A,R0
   \   000316   6045         JZ      ??zcl_ProcessMessageMSG_17
   \   000318   7408         MOV     A,#0x8
   \   00031A   68           XRL     A,R0
   \   00031B   6040         JZ      ??zcl_ProcessMessageMSG_17
   \   00031D   740C         MOV     A,#0xc
   \   00031F   68           XRL     A,R0
   \   000320   603B         JZ      ??zcl_ProcessMessageMSG_17
   \   000322   7411         MOV     A,#0x11
   \   000324   68           XRL     A,R0
   \   000325   6036         JZ      ??zcl_ProcessMessageMSG_17
   \   000327   7413         MOV     A,#0x13
   \   000329   68           XRL     A,R0
   \   00032A   6031         JZ      ??zcl_ProcessMessageMSG_17
   \   00032C   7415         MOV     A,#0x15
   \   00032E   68           XRL     A,R0
   \   00032F   602C         JZ      ??zcl_ProcessMessageMSG_17
   \   000331   740B         MOV     A,#0xb
   \   000333   68           XRL     A,R0
   \   000334   6027         JZ      ??zcl_ProcessMessageMSG_17
   2179                {
   2180                  rawAFMsg = NULL;
   2181                  return ( ZCL_PROC_SUCCESS ); // We're done
   2182                }
   2183          
   2184                status = ZSuccess;
   \   000336   7E00         MOV     R6,#0x0
   \   000338   8043         SJMP    ??zcl_ProcessMessageMSG_13
   2185              }
   2186              else
   2187              {
   2188                // Unsupported message
   2189                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   00033A   7E82         MOV     R6,#-0x7e
   \   00033C   803F         SJMP    ??zcl_ProcessMessageMSG_13
   2190              }
   2191            }
   2192            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2193            {
   2194              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_11:
   \   00033E   EC           MOV     A,R4
   \   00033F   4D           ORL     A,R5
   \   000340   602B         JZ      ??zcl_ProcessMessageMSG_18
   \   000342   8C82         MOV     DPL,R4
   \   000344   8D83         MOV     DPH,R5
   \   000346   A3           INC     DPTR
   \   000347   A3           INC     DPTR
   \   000348   A3           INC     DPTR
   \   000349   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   00034C   601F         JZ      ??zcl_ProcessMessageMSG_18
   2195              {
   2196                // The return value of the plugin function will be
   2197                //  ZSuccess - Supported and need default response
   2198                //  ZFailure - Unsupported
   2199                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2200                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2201                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2202                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2203                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   00034E                ; Setup parameters for indirect call
   \   00034E   7402         MOV     A,#0x2
   \   000350   12....       LCALL   ?XSTACK_DISP101_8
   \   000353   12....       LCALL   ?CALL_IND
   \   000356   E9           MOV     A,R1
   \   000357   FE           MOV     R6,A
   2204                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000358   74FF         MOV     A,#-0x1
   \   00035A   6E           XRL     A,R6
   \   00035B   700B         JNZ     ??zcl_ProcessMessageMSG_19
   2205                {
   2206                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   00035D   90....       MOV     DPTR,#rawAFMsg
   \   000360   E4           CLR     A
   \   000361   F0           MOVX    @DPTR,A
   \   000362   A3           INC     DPTR
   \   000363   F0           MOVX    @DPTR,A
   2207                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   000364   F9           MOV     R1,A
   \   000365   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2208                }
   2209              }
   2210          
   2211              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   000368   7401         MOV     A,#0x1
   \   00036A   6E           XRL     A,R6
   \   00036B   7010         JNZ     ??zcl_ProcessMessageMSG_13
   2212              {
   2213                // Unsupported message
   2214                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   00036D   7404         MOV     A,#0x4
   \   00036F   12....       LCALL   ?XSTACK_DISP0_8
   \   000372   E0           MOVX    A,@DPTR
   \   000373   5404         ANL     A,#0x4
   \   000375   6004         JZ      ??zcl_ProcessMessageMSG_20
   2215                {
   2216                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000377   7E83         MOV     R6,#-0x7d
   \   000379   8002         SJMP    ??zcl_ProcessMessageMSG_13
   2217                }
   2218                else
   2219                {
   2220                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   00037B   7E81         MOV     R6,#-0x7f
   2221                }
   2222              }
   2223            }
   2224          
   2225            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   00037D   7402         MOV     A,#0x2
   \   00037F   12....       LCALL   ?XSTACK_DISP0_8
   \   000382   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000385   707B         JNZ     ??zcl_ProcessMessageMSG_21
   \   000387   7402         MOV     A,#0x2
   \   000389   12....       LCALL   ?XSTACK_DISP0_8
   \   00038C   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   00038F   7071         JNZ     ??zcl_ProcessMessageMSG_21
   \   000391   7404         MOV     A,#0x4
   \   000393   12....       LCALL   ?XSTACK_DISP0_8
   \   000396   E0           MOVX    A,@DPTR
   \   000397   FA           MOV     R2,A
   \   000398   5410         ANL     A,#0x10
   \   00039A   7066         JNZ     ??zcl_ProcessMessageMSG_21
   2226            {
   2227              // Send a Default Response command back
   2228              defautlRspCmd.statusCode = status;
   \   00039C   7401         MOV     A,#0x1
   \   00039E   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A1   EE           MOV     A,R6
   \   0003A2   F0           MOVX    @DPTR,A
   2229              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003A3   7409         MOV     A,#0x9
   \   0003A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A8   12....       LCALL   ?Subroutine90 & 0xFFFF
   2230              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2231                                     inMsg.msg->clusterId, &defautlRspCmd,
   2232                                     !inMsg.hdr.fc.direction, true,
   2233                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_140:
   \   0003AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003AE   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   0003B1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003B4   7407         MOV     A,#0x7
   \   0003B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B9   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0003BC   75..01       MOV     ?V0,#0x1
   \   0003BF   78..         MOV     R0,#?V0
   \   0003C1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003C4   EA           MOV     A,R2
   \   0003C5   13           RRC     A
   \   0003C6   13           RRC     A
   \   0003C7   13           RRC     A
   \   0003C8   541F         ANL     A,#0x1f
   \   0003CA   6401         XRL     A,#0x1
   \   0003CC   5401         ANL     A,#0x1
   \   0003CE   F5..         MOV     ?V0,A
   \   0003D0   78..         MOV     R0,#?V0
   \   0003D2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003D5   7405         MOV     A,#0x5
   \   0003D7   12....       LCALL   ?XSTACK_DISP100_8
   \   0003DA   88..         MOV     ?V0,R0
   \   0003DC   89..         MOV     ?V1,R1
   \   0003DE   78..         MOV     R0,#?V0
   \   0003E0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003E3   7409         MOV     A,#0x9
   \   0003E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E8   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   0003EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EE   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   0003F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F4   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   0003F7   12....       LCALL   `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   0003FA   7407         MOV     A,#0x7
   \   0003FC   12....       LCALL   ?DEALLOC_XSTACK8
   2234              defaultResponseSent = TRUE;
   \   0003FF   75..01       MOV     ?V2,#0x1
   2235            }
   2236          
   2237            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   000402   90....       MOV     DPTR,#rawAFMsg
   \   000405   E4           CLR     A
   \   000406   F0           MOVX    @DPTR,A
   \   000407   A3           INC     DPTR
   \   000408   F0           MOVX    @DPTR,A
   2238            if ( status == ZSuccess )
   \   000409   EE           MOV     A,R6
   \   00040A   7004         JNZ     ??zcl_ProcessMessageMSG_22
   2239            {
   2240              return ( ZCL_PROC_SUCCESS );
   \   00040C   7900         MOV     R1,#0x0
   \   00040E   801F         SJMP    ??zcl_ProcessMessageMSG_1
   2241            }
   2242            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   000410   7484         MOV     A,#-0x7c
   \   000412   6E           XRL     A,R6
   \   000413   700E         JNZ     ??zcl_ProcessMessageMSG_23
   2243            {
   2244              if ( defaultResponseSent )
   \   000415   E5..         MOV     A,?V2
   \   000417   A2E0         MOV     C,0xE0 /* A   */.0
   \   000419   5004         JNC     ??zcl_ProcessMessageMSG_24
   2245              {
   2246                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   00041B   7907         MOV     R1,#0x7
   \   00041D   8010         SJMP    ??zcl_ProcessMessageMSG_1
   2247              }
   2248              else
   2249              {
   2250                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   00041F   7906         MOV     R1,#0x6
   \   000421   800C         SJMP    ??zcl_ProcessMessageMSG_1
   2251              }
   2252            }
   2253            else
   2254            {
   2255              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   000423   E5..         MOV     A,?V2
   \   000425   A2E0         MOV     C,0xE0 /* A   */.0
   \   000427   5004         JNC     ??zcl_ProcessMessageMSG_25
   2256              {
   2257                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000429   7909         MOV     R1,#0x9
   \   00042B   8002         SJMP    ??zcl_ProcessMessageMSG_1
   2258              }
   2259              else
   2260              {
   2261                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   00042D   7908         MOV     R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   00042F   7415         MOV     A,#0x15
   2262              }
   2263            }
   \   000431   02....       LJMP    ?Subroutine8 & 0xFFFF
   2264          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   F5..         MOV     ?V0,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V1,A
   \   000006                ; Setup parameters for call to function zclParseHdr
   \   000006                ; Setup parameters for call to function afFindEndPointDesc
   \   000006   85..82       MOV     DPL,?V0
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000006   38           ADDC    A,R0
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_510:
   \   000003   C8           XCH     A,R0
   \   000004   2415         ADD     A,#0x15
   \   000006   F582         MOV     DPL,A
   \   000008   E4           CLR     A
   \   000009   38           ADDC    A,R0
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000003   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_536:
   \   000006   7409         MOV     A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine185_0
   \   000003                ; // Fall through to label ??Subroutine185_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine185_0:
   \   000000   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   000003   E582         MOV     A,DPL
   \   000005   4583         ORL     A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_399:
   \   000009   85..82       MOV     DPL,?V0
   \   00000C   85..83       MOV     DPH,?V1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine194_0
   \   000003                ; // Fall through to label ??Subroutine194_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine194_0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine195_0
   \   000005                ; // Fall through to label ??Subroutine195_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine150:
   \   000000   12....       LCALL   ?Subroutine170 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine170:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine200_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V6,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V7,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine216_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   F5..         MOV     ?V2,A
   \   00000C   78..         MOV     R0,#?V2
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   F5..         MOV     ?V4,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V5,A
   \   000006   85..82       MOV     DPL,?V4
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine144:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine224_0
   \   000004                ; // Fall through to label ??Subroutine224_0
   2265          
   2266          /*********************************************************************
   2267           * PRIVATE FUNCTIONS
   2268           *********************************************************************/
   2269          
   2270          /*********************************************************************
   2271           * @fn      zclParseHdr
   2272           *
   2273           * @brief   Parse header of the ZCL format
   2274           *
   2275           * @param   hdr - place to put the frame control information
   2276           * @param   pData - incoming buffer to parse
   2277           *
   2278           * @return  pointer past the header
   2279           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2280          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2281          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2282            // Clear the header
   2283            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2284          
   2285            // Parse the Frame Control
   2286            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0
   \   000019   85..83       MOV     DPH,?V1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   F8           MOV     R0,A
   \   00002B   EA           MOV     A,R2
   \   00002C   48           ORL     A,R0
   \   00002D   F8           MOV     R0,A
   \   00002E   EB           MOV     A,R3
   \   00002F   F9           MOV     R1,A
   \   000030   85..82       MOV     DPL,?V0
   \   000033   85..83       MOV     DPH,?V1
   \   000036   E8           MOV     A,R0
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   E9           MOV     A,R1
   \   00003A   12....       LCALL   ?Subroutine38 & 0xFFFF
   2287            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_43:
   \   00003D   A2E2         MOV     C,0xE0 /* A   */.2
   \   00003F   5004         JNC     ??zclParseHdr_0
   \   000041   D2F0         SETB    B.0
   \   000043   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000045   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   000047   85..82       MOV     DPL,?V0
   \   00004A   85..83       MOV     DPH,?V1
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   54FB         ANL     A,#0xfb
   \   000050   F0           MOVX    @DPTR,A
   \   000051   A2F0         MOV     C,B.0
   \   000053   E4           CLR     A
   \   000054   33           RLC     A
   \   000055   F5..         MOV     ?V2,A
   \   000057   75..00       MOV     ?V3,#0x0
   \   00005A   7402         MOV     A,#0x2
   \   00005C   78..         MOV     R0,#?V2
   \   00005E   12....       LCALL   ?S_SHL
   \   000061   E0           MOVX    A,@DPTR
   \   000062   45..         ORL     A,?V2
   \   000064   12....       LCALL   ?Subroutine38 & 0xFFFF
   2288            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_44:
   \   000067   A2E3         MOV     C,0xE0 /* A   */.3
   \   000069   85..82       MOV     DPL,?V0
   \   00006C   85..83       MOV     DPH,?V1
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   5004         JNC     ??zclParseHdr_2
   2289            {
   2290              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000072   4408         ORL     A,#0x8
   \   000074   8002         SJMP    ??zclParseHdr_3
   2291            }
   2292            else
   2293            {
   2294              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000076   54F7         ANL     A,#0xf7
   2295            }
   \                     ??zclParseHdr_3:
   \   000078   12....       LCALL   ?Subroutine38 & 0xFFFF
   2296          
   2297            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_45:
   \   00007B   A2E4         MOV     C,0xE0 /* A   */.4
   \   00007D   5004         JNC     ??zclParseHdr_4
   \   00007F   D2F0         SETB    B.0
   \   000081   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000083   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   000085   85..82       MOV     DPL,?V0
   \   000088   85..83       MOV     DPH,?V1
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   54EF         ANL     A,#0xef
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A2F0         MOV     C,B.0
   \   000091   E4           CLR     A
   \   000092   33           RLC     A
   \   000093   F5..         MOV     ?V2,A
   \   000095   7404         MOV     A,#0x4
   \   000097   78..         MOV     R0,#?V2
   \   000099   12....       LCALL   ?S_SHL
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   45..         ORL     A,?V2
   \   00009F   12....       LCALL   ?Subroutine33 & 0xFFFF
   2298            pData++;  // move past the frame control field
   2299          
   2300            // parse the manfacturer code
   2301            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_32:
   \   0000A2   85..82       MOV     DPL,?V0
   \   0000A5   85..83       MOV     DPH,?V1
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   5404         ANL     A,#0x4
   \   0000AB   6010         JZ      ??zclParseHdr_6
   2302            {
   2303              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000AD   8E82         MOV     DPL,R6
   \   0000AF   8F83         MOV     DPH,R7
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   FA           MOV     R2,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   2304              pData += 2;
   2305            }
   \                     ??CrossCallReturnLabel_427:
   \   0000B7   12....       LCALL   ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_352:
   \   0000BA   5001         JNC     ??zclParseHdr_6
   \   0000BC   0F           INC     R7
   2306          
   2307            // parse the Transaction Sequence Number
   2308            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000BD   8E82         MOV     DPL,R6
   \   0000BF   8F83         MOV     DPH,R7
   \   0000C1   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   12....       LCALL   ??Subroutine210_0 & 0xFFFF
   2309          
   2310            // parse the Cluster's command ID
   2311            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_456:
   \   0000C9   85..82       MOV     DPL,?V0
   \   0000CC   85..83       MOV     DPH,?V1
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   F0           MOVX    @DPTR,A
   2312          
   2313            // Should point to the frame payload
   2314            return ( pData );
   \   0000D5   EE           MOV     A,R6
   \   0000D6   2402         ADD     A,#0x2
   \   0000D8   FA           MOV     R2,A
   \   0000D9   E4           CLR     A
   \   0000DA   3F           ADDC    A,R7
   \   0000DB   FB           MOV     R3,A
   \   0000DC   02....       LJMP    ?Subroutine1 & 0xFFFF
   2315          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_459:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine188_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine189_0
   \   000001                ; // Fall through to label ??Subroutine189_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine189_0:
   \   000000   A3           INC     DPTR
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_439:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_420:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   12....       LCALL   ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_461:
   \   000003   A3           INC     DPTR
   \   000004   AE82         MOV     R6,DPL
   \   000006   AF83         MOV     R7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine204_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   EA           MOV     A,R2
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine206_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002   2402         ADD     A,#0x2
   \   000004   FE           MOV     R6,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine210_0:
   \   000000   12....       LCALL   ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_462:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET
   2316          
   2317          /*********************************************************************
   2318           * @fn      zclBuildHdr
   2319           *
   2320           * @brief   Build header of the ZCL format
   2321           *
   2322           * @param   hdr - outgoing header information
   2323           * @param   pData - outgoing header space
   2324           *
   2325           * @return  pointer past the header
   2326           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2327          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2328          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2329            // Build the Frame Control byte
   2330            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   2331            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_364:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine40 & 0xFFFF
   2332            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_362:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine40 & 0xFFFF
   2333            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_363:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   F0           MOVX    @DPTR,A
   2334            pData++;  // move past the frame control field
   \   000027   A3           INC     DPTR
   \   000028   AC82         MOV     R4,DPL
   \   00002A   AD83         MOV     R5,DPH
   2335          
   2336            // Add the manfacturer code
   2337            if ( hdr->fc.manuSpecific )
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   E0           MOVX    A,@DPTR
   \   000031   5404         ANL     A,#0x4
   \   000033   6010         JZ      ??zclBuildHdr_0
   2338            {
   2339              *pData++ = LO_UINT16( hdr->manuCode );
   \   000035   12....       LCALL   ?Subroutine114 & 0xFFFF
   2340              *pData++ = HI_UINT16( hdr->manuCode );
   2341            }
   \                     ??CrossCallReturnLabel_357:
   \   000038   12....       LCALL   ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_358:
   \   00003B   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   00003E   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000041   FC           MOV     R4,A
   \   000042   5001         JNC     ??zclBuildHdr_0
   \   000044   0D           INC     R5
   2342          
   2343            // Add the Transaction Sequence Number
   2344            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_360:
   \   00004F   12....       LCALL   ?Subroutine35 & 0xFFFF
   2345          
   2346            // Add the Cluster's command ID
   2347            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_36:
   \   000052   12....       LCALL   ?Subroutine93 & 0xFFFF
   2348          
   2349            // Should point to the frame payload
   2350            return ( pData );
   \                     ??CrossCallReturnLabel_147:
   \   000055   FA           MOV     R2,A
   \   000056   E4           CLR     A
   \   000057   3D           ADDC    A,R5
   \   000058   FB           MOV     R3,A
   \   000059   80..         SJMP    ??Subroutine193_0
   2351          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   12....       LCALL   ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_359:
   \   000003   A3           INC     DPTR
   \   000004   F0           MOVX    @DPTR,A
   \   000005   EC           MOV     A,R4
   \   000006   2402         ADD     A,#0x2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine192_0
   \   000007                ; // Fall through to label ??Subroutine192_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine192_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET
   2352          
   2353          /*********************************************************************
   2354           * @fn      zclCalcHdrSize
   2355           *
   2356           * @brief   Calculate the number of bytes needed for an outgoing
   2357           *          ZCL header.
   2358           *
   2359           * @param   hdr - outgoing header information
   2360           *
   2361           * @return  returns the number of bytes needed
   2362           */
   2363          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2364          {
   2365            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2366          
   2367            // Add the manfacturer code
   2368            if ( hdr->fc.manuSpecific )
   2369            {
   2370              needed += 2;
   2371            }
   2372          
   2373            return ( needed );
   2374          }
   2375          
   2376          /*********************************************************************
   2377           * @fn      zclFindPlugin
   2378           *
   2379           * @brief   Find the right plugin for a cluster ID
   2380           *
   2381           * @param   clusterID - cluster ID to look for
   2382           * @param   profileID - profile ID
   2383           *
   2384           * @return  pointer to plugin, NULL if not found
   2385           */
   2386          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2387          {
   2388            zclLibPlugin_t *pLoop = plugins;
   2389          
   2390            (void)profileID;  // Intentionally unreferenced parameter
   2391          
   2392            while ( pLoop != NULL )
   2393            {
   2394              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2395              {
   2396                return ( pLoop );
   2397              }
   2398          
   2399              pLoop = pLoop->next;
   2400            }
   2401          
   2402            return ( (zclLibPlugin_t *)NULL );
   2403          }
   2404          
   2405          #ifdef ZCL_DISCOVER
   2406          /*********************************************************************
   2407           * @fn      zclFindCmdRecsList
   2408           *
   2409           * @brief   Find the right command record list for an endpoint
   2410           *
   2411           * @param   endpoint - endpoint to look for
   2412           *
   2413           * @return  pointer to record list, NULL if not found
   2414           */
   2415          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2416          {
   2417            zclCmdRecsList_t *pLoop = gpCmdList;
   2418          
   2419            while ( pLoop != NULL )
   2420            {
   2421              if ( pLoop->endpoint == endpoint )
   2422              {
   2423                return ( pLoop );
   2424              }
   2425          
   2426              pLoop = pLoop->pNext;
   2427            }
   2428          
   2429            return ( NULL );
   2430          }
   2431          
   2432          /*********************************************************************
   2433           * @fn      zclFindCmdRec
   2434           *
   2435           * @brief   Find the command record that matchs the parameters
   2436           *
   2437           * @param   endpoint - Application's endpoint
   2438           * @param   clusterID - cluster ID
   2439           * @param   attrId - attribute looking for
   2440           * @param   pAttr - attribute record to be returned
   2441           *
   2442           * @return  TRUE if record found. FALSE, otherwise.
   2443           */
   2444          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2445          {
   2446            uint8 i;
   2447            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2448          
   2449            if ( pRec != NULL )
   2450            {
   2451              for ( i = 0; i < pRec->numCommands; i++ )
   2452              {
   2453                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2454                {
   2455                  *pCmd = pRec->pCmdRecs[i];
   2456          
   2457                  return ( TRUE ); // EMBEDDED RETURN
   2458                }
   2459              }
   2460            }
   2461          
   2462            return ( FALSE );
   2463          }
   2464          #endif // ZCL_DISCOVER
   2465          
   2466          /*********************************************************************
   2467           * @fn      zclFindAttrRecsList
   2468           *
   2469           * @brief   Find the right attribute record list for an endpoint
   2470           *
   2471           * @param   clusterID - endpointto look for
   2472           *
   2473           * @return  pointer to record list, NULL if not found
   2474           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2475          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2476          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2477            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV     DPTR,#attrList
   \   000007   8004         SJMP    ??zclFindAttrRecsList_0
   2478          
   2479            while ( pLoop != NULL )
   2480            {
   2481              if ( pLoop->endpoint == endpoint )
   2482              {
   2483                return ( pLoop );
   2484              }
   2485          
   2486              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000010   600C         JZ      ??zclFindAttrRecsList_2
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   69           XRL     A,R1
   \   00001A   70ED         JNZ     ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP    ??zclFindAttrRecsList_3
   2487            }
   2488          
   2489            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP    ?Subroutine0 & 0xFFFF
   2490          }
   2491          
   2492          /*********************************************************************
   2493           * @fn      zclFindAttrRec
   2494           *
   2495           * @brief   Find the attribute record that matchs the parameters
   2496           *
   2497           * @param   endpoint - Application's endpoint
   2498           * @param   clusterID - cluster ID
   2499           * @param   attrId - attribute looking for
   2500           * @param   pAttr - attribute record to be returned
   2501           *
   2502           * @return  TRUE if record found. FALSE, otherwise.
   2503           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2504          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2505          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2506            uint8 x;
   2507            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   2508          
   2509            if ( pRec != NULL )
   \   000014   EA           MOV     A,R2
   \   000015   45..         ORL     A,?V5
   \   000017   6075         JZ      ??zclFindAttrRec_0
   2510            {
   2511              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000019   7C00         MOV     R4,#0x0
   \   00001B   8001         SJMP    ??zclFindAttrRec_1
   \                     ??zclFindAttrRec_2:
   \   00001D   0C           INC     R4
   \                     ??zclFindAttrRec_1:
   \   00001E   85..82       MOV     DPL,?V4
   \   000021   85..83       MOV     DPH,?V5
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00002E   505E         JNC     ??zclFindAttrRec_0
   2512              {
   2513                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000030   8C..         MOV     ?V6,R4
   \   000032   75..00       MOV     ?V7,#0x0
   \   000035   7403         MOV     A,#0x3
   \   000037   78..         MOV     R0,#?V6
   \   000039   12....       LCALL   ?S_SHL
   \   00003C   85..82       MOV     DPL,?V4
   \   00003F   85..83       MOV     DPH,?V5
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   25..         ADD     A,?V6
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   35..         ADDC    A,?V7
   \   000052   F9           MOV     R1,A
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   E4           CLR     A
   \   000058   93           MOVC    A,@A+DPTR
   \   000059   FA           MOV     R2,A
   \   00005A   7401         MOV     A,#0x1
   \   00005C   93           MOVC    A,@A+DPTR
   \   00005D   FB           MOV     R3,A
   \   00005E   E5..         MOV     A,?V0
   \   000060   6A           XRL     A,R2
   \   000061   7003         JNZ     ??zclFindAttrRec_3
   \   000063   E5..         MOV     A,?V1
   \   000065   6B           XRL     A,R3
   \                     ??zclFindAttrRec_3:
   \   000066   70B5         JNZ     ??zclFindAttrRec_2
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E4           CLR     A
   \   00006B   93           MOVC    A,@A+DPTR
   \   00006C   FA           MOV     R2,A
   \   00006D   7401         MOV     A,#0x1
   \   00006F   93           MOVC    A,@A+DPTR
   \   000070   FB           MOV     R3,A
   \   000071   EE           MOV     A,R6
   \   000072   6A           XRL     A,R2
   \   000073   7002         JNZ     ??zclFindAttrRec_4
   \   000075   EF           MOV     A,R7
   \   000076   6B           XRL     A,R3
   \                     ??zclFindAttrRec_4:
   \   000077   70A4         JNZ     ??zclFindAttrRec_2
   2514                {
   2515                  *pAttr = pRec->attrs[x];
   \   000079   7410         MOV     A,#0x10
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   12....       LCALL   ??Subroutine220_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_516:
   \   000081   8983         MOV     DPH,R1
   \   000083   8882         MOV     DPL,R0
   \   000085   7408         MOV     A,#0x8
   \   000087   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   2516          
   2517                  return ( TRUE ); // EMBEDDED RETURN
   \   00008A   7901         MOV     R1,#0x1
   \   00008C   8002         SJMP    ??zclFindAttrRec_5
   2518                }
   2519              }
   2520            }
   2521          
   2522            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   00008E   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   000090   80..         SJMP    ??Subroutine194_0
   2523          }
   2524          
   2525          #if defined ( ZCL_STANDALONE )
   2526          /*********************************************************************
   2527           * @fn      zclSetAttrRecList
   2528           *
   2529           * @brief   Set attribute record list for end point
   2530           *
   2531           * @param   endpoint - endpoint the attribute list belongs to
   2532           * @param   numAttr - number of attributes in list
   2533           * @param   attrList - array of attribute records.
   2534           *                     NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE
   2535           *                     IN ASCENDING ORDER. OTHERWISE, THE DISCOVERY
   2536           *                     RESPONSE COMMAND WILL NOT HAVE THE RIGHT
   2537           *                     ATTRIBUTE INFO
   2538           *
   2539           * @return  TRUE if successful, FALSE otherwise.
   2540           */
   2541          uint8 zclSetAttrRecList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t attrList[] )
   2542          {
   2543            zclAttrRecsList *pRecsList = zclFindAttrRecsList( endpoint );
   2544          
   2545            if ( pRecsList != NULL )
   2546            {
   2547              pRecsList->numAttributes = numAttr;
   2548              pRecsList->attrs = attrList;
   2549              return ( TRUE );
   2550            }
   2551          
   2552            return ( FALSE );
   2553          }
   2554          
   2555          #endif // ZCL_STANDALONE
   2556          
   2557          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2558          /*********************************************************************
   2559           * @fn      zclGetReadWriteCB
   2560           *
   2561           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2562           *
   2563           * @param   endpoint - Application's endpoint
   2564           *
   2565           * @return  Read/Write CB, NULL if not found
   2566           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2567          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2568          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2569            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2570          
   2571            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetReadWriteCB_0
   2572            {
   2573              return ( pRec->pfnReadWriteCB );
   \   000012   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   2574            }
   \                     ??CrossCallReturnLabel_394:
   \   000015   8004         SJMP    ??zclGetReadWriteCB_1
   2575          
   2576            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   00001B   02....       LJMP    ?Subroutine3 & 0xFFFF
   2577          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine197_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine198_0
   \   000003                ; // Fall through to label ??Subroutine198_0
   2578          
   2579          /*********************************************************************
   2580           * @fn      zclGetAuthorizeCB
   2581           *
   2582           * @brief   Get the Read/Write Authorization callback function pointer
   2583           *          for a given endpoint.
   2584           *
   2585           * @param   endpoint - Application's endpoint
   2586           *
   2587           * @return  Authorization CB, NULL if not found
   2588           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2589          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2590          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2591            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2592          
   2593            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetAuthorizeCB_0
   2594            {
   2595              return ( pRec->pfnAuthorizeCB );
   \   000012   12....       LCALL   ?Subroutine95 & 0xFFFF
   2596            }
   \                     ??CrossCallReturnLabel_397:
   \   000015   8004         SJMP    ??zclGetAuthorizeCB_1
   2597          
   2598            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00001B   80..         SJMP    ?Subroutine3
   2599          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine196_0
   \   000001                ; // Fall through to label ??Subroutine196_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine196_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine197_0
   \   000001                ; // Fall through to label ??Subroutine197_0
   2600          #endif // ZCL_READ || ZCL_WRITE
   2601          
   2602          /*********************************************************************
   2603           * @fn      zclFindClusterOption
   2604           *
   2605           * @brief   Find the option record that matchs the cluster id
   2606           *
   2607           * @param   endpoint - Application's endpoint
   2608           * @param   clusterID - cluster ID looking for
   2609           *
   2610           * @return  pointer to clutser option, NULL if not found
   2611           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2612          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2613          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   2614            zclClusterOptionList *pLoop;
   2615          
   2616            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000011   8009         SJMP    ??zclFindClusterOption_0
   2617            while ( pLoop != NULL )
   2618            {
   2619              if ( pLoop->endpoint == endpoint )
   2620              {
   2621                uint8 x;
   2622                for ( x = 0; x < pLoop->numOptions; x++ )
   2623                {
   2624                  if ( pLoop->options[x].clusterID == clusterID )
   2625                  {
   2626                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2627                  }
   2628                }
   2629              }
   2630          
   2631              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000013   8C82         MOV     DPL,R4
   \   000015   8D83         MOV     DPH,R5
   \   000017   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   00001A   FC           MOV     R4,A
   \   00001B   E9           MOV     A,R1
   \                     ??zclFindClusterOption_0:
   \   00001C   FD           MOV     R5,A
   \   00001D   EC           MOV     A,R4
   \   00001E   4D           ORL     A,R5
   \   00001F   6045         JZ      ??zclFindClusterOption_2
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   65..         XRL     A,?V1
   \   00002A   70E7         JNZ     ??zclFindClusterOption_1
   \   00002C   75..00       MOV     ?V0,#0x0
   \   00002F   8002         SJMP    ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000031   05..         INC     ?V0
   \                     ??zclFindClusterOption_3:
   \   000033   8C82         MOV     DPL,R4
   \   000035   8D83         MOV     DPH,R5
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   12....       LCALL   ??Subroutine181_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   00003D   50D4         JNC     ??zclFindClusterOption_1
   \   00003F   E5..         MOV     A,?V0
   \   000041   75F003       MOV     B,#0x3
   \   000044   A4           MUL     AB
   \   000045   F8           MOV     R0,A
   \   000046   A9F0         MOV     R1,B
   \   000048   8C82         MOV     DPL,R4
   \   00004A   8D83         MOV     DPH,R5
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   28           ADD     A,R0
   \   000052   FA           MOV     R2,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   39           ADDC    A,R1
   \   000056   FB           MOV     R3,A
   \   000057   8A82         MOV     DPL,R2
   \   000059   8B83         MOV     DPH,R3
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   6E           XRL     A,R6
   \   00005D   7003         JNZ     ??zclFindClusterOption_5
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   6F           XRL     A,R7
   \                     ??zclFindClusterOption_5:
   \   000062   70CD         JNZ     ??zclFindClusterOption_4
   \   000064   8004         SJMP    ??zclFindClusterOption_6
   2632            }
   2633          
   2634            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   000066   7A00         MOV     R2,#0x0
   \   000068   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   00006A                REQUIRE ?Subroutine3
   \   00006A                ; // Fall through to label ?Subroutine3
   2635          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_379:
   \   000003   22           RET
   2636          
   2637          /*********************************************************************
   2638           * @fn      zclGetClusterOption
   2639           *
   2640           * @brief   Get the option record that matchs the cluster id
   2641           *
   2642           * @param   endpoint - Application's endpoint
   2643           * @param   clusterID - cluster ID looking for
   2644           *
   2645           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2646           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2647          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2648          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2649            uint8 option;
   2650            zclOptionRec_t *pOption;
   2651          
   2652            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2653            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6006         JZ      ??zclGetClusterOption_0
   2654            {
   2655              option = pOption->option;
   2656              if ( !ZG_SECURE_ENABLED )
   2657              {
   2658                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2659              }
   2660          
   2661              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   8002         SJMP    ??zclGetClusterOption_1
   2662            }
   2663          
   2664            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000018   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001A   80..         SJMP    ?Subroutine3
   2665          }
   2666          
   2667          /*********************************************************************
   2668           * @fn      zclSetSecurityOption
   2669           *
   2670           * @brief   Set the security option for the cluster id
   2671           *
   2672           * @param   endpoint - Application's endpoint
   2673           * @param   clusterID - cluster ID looking for
   2674           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2675           *
   2676           * @return  none
   2677           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2678          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2679          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2680            zclOptionRec_t *pOption;
   2681          
   2682            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   A8..         MOV     R0,?V0
   \   000010   A9..         MOV     R1,?V1
   2683            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   6015         JZ      ??zclSetSecurityOption_0
   2684            {
   2685              if ( enable )
   \   000016   E8           MOV     A,R0
   \   000017   2402         ADD     A,#0x2
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   39           ADDC    A,R1
   \   00001D   F583         MOV     DPH,A
   \   00001F   EF           MOV     A,R7
   \   000020   6005         JZ      ??zclSetSecurityOption_1
   2686              {
   2687                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E6         SETB    0xE0 /* A   */.6
   \   000025   8003         SJMP    ??zclSetSecurityOption_2
   2688              }
   2689              else
   2690              {
   2691                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   00002A   F0           MOVX    @DPTR,A
   2692              }
   2693            }
   2694          }
   \                     ??zclSetSecurityOption_0:
   \   00002B   80..         SJMP    ?Subroutine3
   2695          
   2696          #ifdef ZCL_DISCOVER
   2697          /*********************************************************************
   2698           * @fn      zclFindNextCmdRec
   2699           *
   2700           * @brief   Find the command (or next) record that matchs the parameters
   2701           *
   2702           * @param   endpoint - Application's endpoint
   2703           * @param   clusterID - cluster ID
   2704           * @param   commandID - command ID from requesting command
   2705           * @param   direction- direction of received command
   2706           * @param   pCmdID - command looking for
   2707           * @param   pCmd - command information within command record list
   2708           *
   2709           * @return  pointer to command record, NULL no more records of this cluster
   2710           */
   2711          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2712                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2713          {
   2714            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2715            uint8 i;
   2716          
   2717            if ( pRec != NULL )
   2718            {
   2719              for ( i = 0; i < pRec->numCommands; i++ )
   2720              {
   2721                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2722                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2723                {
   2724                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2725                  {
   2726                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2727                    {
   2728                      *pCmd = pRec->pCmdRecs[i];
   2729          
   2730                      // Update command ID
   2731                      *pCmdID = pCmd->cmdID;
   2732          
   2733                      return ( TRUE ); // EMBEDDED RETURN
   2734                    }
   2735                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2736                    {
   2737                      *pCmd = pRec->pCmdRecs[i];
   2738          
   2739                      // Update command ID
   2740                      *pCmdID = pCmd->cmdID;
   2741          
   2742                      return ( TRUE ); // EMBEDDED RETURN
   2743                    }
   2744                  }
   2745                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2746                  {
   2747                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2748                    {
   2749                      *pCmd = pRec->pCmdRecs[i];
   2750          
   2751                      // Update command ID
   2752                      *pCmdID = pCmd->cmdID;
   2753          
   2754                      return ( TRUE ); // EMBEDDED RETURN
   2755                    }
   2756                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2757                    {
   2758                      *pCmd = pRec->pCmdRecs[i];
   2759          
   2760                      // Update command ID
   2761                      *pCmdID = pCmd->cmdID;
   2762          
   2763                      return ( TRUE ); // EMBEDDED RETURN
   2764                    }
   2765                  }
   2766                  else
   2767                  {
   2768                    return ( FALSE ); // Incorrect Command ID
   2769                  }
   2770                }
   2771              }
   2772            }
   2773          
   2774            return ( FALSE );
   2775          }
   2776          
   2777          /*********************************************************************
   2778           * @fn      zclFindNextAttrRec
   2779           *
   2780           * @brief   Find the attribute (or next) record that matchs the parameters
   2781           *
   2782           * @param   endpoint - Application's endpoint
   2783           * @param   clusterID - cluster ID
   2784           * @param   attr - attribute looking for
   2785           *
   2786           * @return  pointer to attribute record, NULL if not found
   2787           */
   2788          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2789                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2790          {
   2791            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2792            uint8 attrDir;
   2793          
   2794            if ( pRec != NULL )
   2795            {
   2796              uint16 x;
   2797          
   2798              for ( x = 0; x < pRec->numAttributes; x++ )
   2799              {
   2800                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2801                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2802                {
   2803                  // also make sure direction is right
   2804                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2805                  if ( attrDir == direction )
   2806                  {
   2807                    // return attribute and found attribute ID
   2808                    *pAttr = pRec->attrs[x];
   2809                    *attrId = pAttr->attr.attrId;
   2810          
   2811                    return ( TRUE ); // EMBEDDED RETURN
   2812                  }
   2813                }
   2814              }
   2815            }
   2816          
   2817            return ( FALSE );
   2818          }
   2819          #endif // ZCL_DISCOVER
   2820          
   2821          /*********************************************************************
   2822           * @fn      zclSerializeData
   2823           *
   2824           * @brief   Builds a buffer from the attribute data to sent out over
   2825           *          the air.
   2826           *          NOTE - Not compatible with application's attributes callbacks.
   2827           *
   2828           * @param   dataType - data types defined in zcl.h
   2829           * @param   attrData - pointer to the attribute data
   2830           * @param   buf - where to put the serialized data
   2831           *
   2832           * @return  pointer to end of destination buffer
   2833           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2834          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2835          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   2836            uint8 *pStr;
   2837            uint16 len;
   2838          
   2839            if ( attrData == NULL )
   \   00000D   EE           MOV     A,R6
   \   00000E   4F           ORL     A,R7
   \   00000F   7003         JNZ     $+5
   \   000011   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2840            {
   2841              return ( buf );
   2842            }
   2843          
   2844            switch ( dataType )
   \   000014   EA           MOV     A,R2
   \   000015   2402         ADD     A,#0x2
   \   000017   F5..         MOV     ?V4,A
   \   000019   E4           CLR     A
   \   00001A   3B           ADDC    A,R3
   \   00001B   F5..         MOV     ?V5,A
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   A3           INC     DPTR
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   8E..         MOV     ?V0,R6
   \   000028   8F..         MOV     ?V1,R7
   \   00002A   75..00       MOV     ?V2,#0x0
   \   00002D   E9           MOV     A,R1
   \   00002E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000031   04           DB        4
   \   000032   41           DB        65
   \   000033   42           DB        66
   \   000034   ....         DW        ??zclSerializeData_1
   \   000036   43           DB        67
   \   000037   44           DB        68
   \   000038   ....         DW        ??zclSerializeData_2
   \   00003A   E0           DB        224
   \   00003B   E2           DB        226
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   E8           DB        232
   \   00003F   E9           DB        233
   \   000040   ....         DW        ??zclSerializeData_4
   \   000042   21           DB        33
   \   000043   08           DB        8
   \   000044   ....         DW        ??zclSerializeData_5
   \   000046   09           DB        9
   \   000047   ....         DW        ??zclSerializeData_4
   \   000049   0A           DB        10
   \   00004A   ....         DW        ??zclSerializeData_6
   \   00004C   0B           DB        11
   \   00004D   ....         DW        ??zclSerializeData_3
   \   00004F   10           DB        16
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   18           DB        24
   \   000053   ....         DW        ??zclSerializeData_5
   \   000055   19           DB        25
   \   000056   ....         DW        ??zclSerializeData_4
   \   000058   1A           DB        26
   \   000059   ....         DW        ??zclSerializeData_6
   \   00005B   1B           DB        27
   \   00005C   ....         DW        ??zclSerializeData_3
   \   00005E   20           DB        32
   \   00005F   ....         DW        ??zclSerializeData_5
   \   000061   21           DB        33
   \   000062   ....         DW        ??zclSerializeData_4
   \   000064   22           DB        34
   \   000065   ....         DW        ??zclSerializeData_6
   \   000067   23           DB        35
   \   000068   ....         DW        ??zclSerializeData_3
   \   00006A   24           DB        36
   \   00006B   ....         DW        ??zclSerializeData_7
   \   00006D   25           DB        37
   \   00006E   ....         DW        ??zclSerializeData_8
   \   000070   26           DB        38
   \   000071   ....         DW        ??zclSerializeData_9
   \   000073   27           DB        39
   \   000074   ....         DW        ??zclSerializeData_10
   \   000076   28           DB        40
   \   000077   ....         DW        ??zclSerializeData_5
   \   000079   29           DB        41
   \   00007A   ....         DW        ??zclSerializeData_4
   \   00007C   2A           DB        42
   \   00007D   ....         DW        ??zclSerializeData_6
   \   00007F   2B           DB        43
   \   000080   ....         DW        ??zclSerializeData_3
   \   000082   2C           DB        44
   \   000083   ....         DW        ??zclSerializeData_7
   \   000085   2D           DB        45
   \   000086   ....         DW        ??zclSerializeData_8
   \   000088   2E           DB        46
   \   000089   ....         DW        ??zclSerializeData_9
   \   00008B   2F           DB        47
   \   00008C   ....         DW        ??zclSerializeData_10
   \   00008E   30           DB        48
   \   00008F   ....         DW        ??zclSerializeData_5
   \   000091   31           DB        49
   \   000092   ....         DW        ??zclSerializeData_4
   \   000094   38           DB        56
   \   000095   ....         DW        ??zclSerializeData_4
   \   000097   39           DB        57
   \   000098   ....         DW        ??zclSerializeData_3
   \   00009A   3A           DB        58
   \   00009B   ....         DW        ??zclSerializeData_10
   \   00009D   EA           DB        234
   \   00009E   ....         DW        ??zclSerializeData_3
   \   0000A0   F0           DB        240
   \   0000A1   ....         DW        ??zclSerializeData_10
   \   0000A3   F1           DB        241
   \   0000A4   ....         DW        ??zclSerializeData_11
   \   0000A6   ....         DW        ??zclSerializeData_0
   2845            {
   2846              case ZCL_DATATYPE_DATA8:
   2847              case ZCL_DATATYPE_BOOLEAN:
   2848              case ZCL_DATATYPE_BITMAP8:
   2849              case ZCL_DATATYPE_INT8:
   2850              case ZCL_DATATYPE_UINT8:
   2851              case ZCL_DATATYPE_ENUM8:
   2852                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   0000A8   8E82         MOV     DPL,R6
   \   0000AA   8F83         MOV     DPH,R7
   \   0000AC   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   0000AF   EC           MOV     A,R4
   \   0000B0   FA           MOV     R2,A
   \   0000B1   ED           MOV     A,R5
   \   0000B2   FB           MOV     R3,A
   2853                 break;
   \   0000B3   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2854          
   2855              case ZCL_DATATYPE_DATA16:
   2856              case ZCL_DATATYPE_BITMAP16:
   2857              case ZCL_DATATYPE_UINT16:
   2858              case ZCL_DATATYPE_INT16:
   2859              case ZCL_DATATYPE_ENUM16:
   2860              case ZCL_DATATYPE_SEMI_PREC:
   2861              case ZCL_DATATYPE_CLUSTER_ID:
   2862              case ZCL_DATATYPE_ATTR_ID:
   2863                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000B6   12....       LCALL   ?Subroutine19 & 0xFFFF
   2864                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_454:
   \   0000B9   8C82         MOV     DPL,R4
   \   0000BB   8D83         MOV     DPH,R5
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   0A           INC     R2
   \   0000BF   0A           INC     R2
   \   0000C0   AB..         MOV     R3,?V5
   2865                break;
   \   0000C2   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2866          
   2867              case ZCL_DATATYPE_DATA24:
   2868              case ZCL_DATATYPE_BITMAP24:
   2869              case ZCL_DATATYPE_UINT24:
   2870              case ZCL_DATATYPE_INT24:
   2871                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000C5   8E82         MOV     DPL,R6
   \   0000C7   8F83         MOV     DPH,R7
   \   0000C9   78..         MOV     R0,#?V0
   \   0000CB   12....       LCALL   ?L_MOV_X
   \   0000CE   8A82         MOV     DPL,R2
   \   0000D0   8B83         MOV     DPH,R3
   \   0000D2   E5..         MOV     A,?V0
   \   0000D4   12....       LCALL   ?Subroutine39 & 0xFFFF
   2872                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_47:
   \   0000D7   78..         MOV     R0,#?V0
   \   0000D9   12....       LCALL   ?L_MOV_X
   \   0000DC   E5..         MOV     A,?V1
   \   0000DE   8C82         MOV     DPL,R4
   \   0000E0   8D83         MOV     DPH,R5
   \   0000E2   12....       LCALL   ?Subroutine39 & 0xFFFF
   2873                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_48:
   \   0000E5   78..         MOV     R0,#?V0
   \   0000E7   12....       LCALL   ?L_MOV_X
   \   0000EA   7410         MOV     A,#0x10
   \   0000EC   78..         MOV     R0,#?V0
   \   0000EE   12....       LCALL   ?UL_SHR
   \   0000F1   85..82       MOV     DPL,?V4
   \   0000F4   85..83       MOV     DPH,?V5
   \   0000F7   E5..         MOV     A,?V0
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   EA           MOV     A,R2
   \   0000FB   2403         ADD     A,#0x3
   \   0000FD   FA           MOV     R2,A
   \   0000FE   506D         JNC     ??zclSerializeData_0
   \   000100   0B           INC     R3
   2874                break;
   \   000101   806A         SJMP    ??zclSerializeData_0
   2875          
   2876              case ZCL_DATATYPE_DATA32:
   2877              case ZCL_DATATYPE_BITMAP32:
   2878              case ZCL_DATATYPE_UINT32:
   2879              case ZCL_DATATYPE_INT32:
   2880              case ZCL_DATATYPE_SINGLE_PREC:
   2881              case ZCL_DATATYPE_TOD:
   2882              case ZCL_DATATYPE_DATE:
   2883              case ZCL_DATATYPE_UTC:
   2884              case ZCL_DATATYPE_BAC_OID:
   2885                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   000103                ; Setup parameters for call to function osal_buffer_uint32
   \   000103   8E82         MOV     DPL,R6
   \   000105   8F83         MOV     DPH,R7
   \   000107   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00010A   12....       LCALL   `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   00010D   7404         MOV     A,#0x4
   \   00010F   12....       LCALL   ?DEALLOC_XSTACK8
   2886                break;
   \   000112   8059         SJMP    ??zclSerializeData_0
   2887          
   2888              case ZCL_DATATYPE_UINT40:
   2889              case ZCL_DATATYPE_INT40:
   2890                pStr = (uint8*)attrData;
   2891                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   000114                ; Setup parameters for call to function osal_memcpy
   \   000114   78..         MOV     R0,#?V0
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000119   7C05         MOV     R4,#0x5
   \   00011B   8046         SJMP    ??zclSerializeData_12
   2892                break;
   2893          
   2894              case ZCL_DATATYPE_UINT48:
   2895              case ZCL_DATATYPE_INT48:
   2896                pStr = (uint8*)attrData;
   2897                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   00011D                ; Setup parameters for call to function osal_memcpy
   \   00011D   78..         MOV     R0,#?V0
   \   00011F   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000122   7C06         MOV     R4,#0x6
   \   000124   803D         SJMP    ??zclSerializeData_12
   2898                break;
   2899          
   2900              case ZCL_DATATYPE_UINT56:
   2901              case ZCL_DATATYPE_INT56:
   2902                pStr = (uint8*)attrData;
   2903                buf = zcl_memcpy( buf, pStr, 7 );
   \                     ??zclSerializeData_9:
   \   000126                ; Setup parameters for call to function osal_memcpy
   \   000126   78..         MOV     R0,#?V0
   \   000128   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00012B   7C07         MOV     R4,#0x7
   \   00012D   8034         SJMP    ??zclSerializeData_12
   2904                break;
   2905          
   2906              case ZCL_DATATYPE_DOUBLE_PREC:
   2907              case ZCL_DATATYPE_IEEE_ADDR:
   2908              case ZCL_DATATYPE_UINT64:
   2909              case ZCL_DATATYPE_INT64:
   2910                pStr = (uint8*)attrData;
   2911                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_10:
   \   00012F                ; Setup parameters for call to function osal_memcpy
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000134   7C08         MOV     R4,#0x8
   \   000136   802B         SJMP    ??zclSerializeData_12
   2912                break;
   2913          
   2914              case ZCL_DATATYPE_CHAR_STR:
   2915              case ZCL_DATATYPE_OCTET_STR:
   2916                pStr = (uint8*)attrData;
   2917                len = *pStr;
   2918                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   000138                ; Setup parameters for call to function osal_memcpy
   \   000138   78..         MOV     R0,#?V0
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00013D   8E82         MOV     DPL,R6
   \   00013F   8F83         MOV     DPH,R7
   \   000141   E0           MOVX    A,@DPTR
   \   000142   2401         ADD     A,#0x1
   \   000144   FC           MOV     R4,A
   \   000145   E4           CLR     A
   \   000146   3400         ADDC    A,#0x0
   \   000148   800F         SJMP    ??zclSerializeData_13
   2919                break;
   2920          
   2921              case ZCL_DATATYPE_LONG_CHAR_STR:
   2922              case ZCL_DATATYPE_LONG_OCTET_STR:
   2923                pStr = (uint8*)attrData;
   2924                len = BUILD_UINT16( pStr[0], pStr[1] );
   2925                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   00014A                ; Setup parameters for call to function osal_memcpy
   \   00014A   78..         MOV     R0,#?V0
   \   00014C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00014F   8E82         MOV     DPL,R6
   \   000151   8F83         MOV     DPH,R7
   \   000153   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000156   FC           MOV     R4,A
   \   000157   E4           CLR     A
   \   000158   39           ADDC    A,R1
   \                     ??zclSerializeData_13:
   \   000159   FD           MOV     R5,A
   \   00015A   8009         SJMP    ??zclSerializeData_14
   2926                break;
   2927          
   2928              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2929                pStr = (uint8*)attrData;
   2930                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_11:
   \   00015C                ; Setup parameters for call to function osal_memcpy
   \   00015C   78..         MOV     R0,#?V0
   \   00015E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000161   7C10         MOV     R4,#0x10
   \                     ??zclSerializeData_12:
   \   000163   7D00         MOV     R5,#0x0
   \                     ??zclSerializeData_14:
   \   000165   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000168   7403         MOV     A,#0x3
   \   00016A   12....       LCALL   ?DEALLOC_XSTACK8
   2931                break;
   2932          
   2933              case ZCL_DATATYPE_NO_DATA:
   2934              case ZCL_DATATYPE_UNKNOWN:
   2935                // Fall through
   2936          
   2937              default:
   2938                break;
   2939            }
   2940          
   2941            return ( buf );
   \                     ??zclSerializeData_0:
   \   00016D                REQUIRE ?Subroutine9
   \   00016D                ; // Fall through to label ?Subroutine9
   2942          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   2402         ADD     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000007                REQUIRE ??Subroutine210_0
   \   000007                ; // Fall through to label ??Subroutine210_0
   2943          
   2944          #ifdef ZCL_REPORT
   2945          /*********************************************************************
   2946           * @fn      zclAnalogDataType
   2947           *
   2948           * @brief   Checks to see if Data Type is Analog
   2949           *
   2950           * @param   dataType - data type
   2951           *
   2952           * @return  TRUE if data type is analog
   2953           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2954          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   2955          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   2956            uint8 analog;
   2957          
   2958            switch ( dataType )
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000008   03           DB        3
   \   000009   20           DB        32
   \   00000A   2F           DB        47
   \   00000B   ....         DW        ??zclAnalogDataType_0
   \   00000D   38           DB        56
   \   00000E   3A           DB        58
   \   00000F   ....         DW        ??zclAnalogDataType_0
   \   000011   E0           DB        224
   \   000012   E2           DB        226
   \   000013   ....         DW        ??zclAnalogDataType_0
   \   000015   00           DB        0
   \   000016   ....         DW        ??zclAnalogDataType_1
   2959            {
   2960              case ZCL_DATATYPE_UINT8:
   2961              case ZCL_DATATYPE_UINT16:
   2962              case ZCL_DATATYPE_UINT24:
   2963              case ZCL_DATATYPE_UINT32:
   2964              case ZCL_DATATYPE_UINT40:
   2965              case ZCL_DATATYPE_UINT48:
   2966              case ZCL_DATATYPE_UINT56:
   2967              case ZCL_DATATYPE_UINT64:
   2968              case ZCL_DATATYPE_INT8:
   2969              case ZCL_DATATYPE_INT16:
   2970              case ZCL_DATATYPE_INT24:
   2971              case ZCL_DATATYPE_INT32:
   2972              case ZCL_DATATYPE_INT40:
   2973              case ZCL_DATATYPE_INT48:
   2974              case ZCL_DATATYPE_INT56:
   2975              case ZCL_DATATYPE_INT64:
   2976              case ZCL_DATATYPE_SEMI_PREC:
   2977              case ZCL_DATATYPE_SINGLE_PREC:
   2978              case ZCL_DATATYPE_DOUBLE_PREC:
   2979              case ZCL_DATATYPE_TOD:
   2980              case ZCL_DATATYPE_DATE:
   2981              case ZCL_DATATYPE_UTC:
   2982                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000018   7901         MOV     R1,#0x1
   2983                break;
   \   00001A   8002         SJMP    ??zclAnalogDataType_2
   2984          
   2985              default:
   2986                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001C   7900         MOV     R1,#0x0
   2987                break;
   2988            }
   2989          
   2990            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001E   02....       LJMP    ?Subroutine0 & 0xFFFF
   2991          }
   2992          
   2993          /*********************************************************************
   2994           * @fn      zclIsLittleEndianMachine
   2995           *
   2996           * @brief   Verifies endianness in system.
   2997           *
   2998           * @param   none
   2999           *
   3000           * @return  MSB-00 or LSB-01 depending on endianness in the system
   3001           */
   3002          static int zclIsLittleEndianMachine(void)
   3003          {
   3004            uint16 test = 0x0001;
   3005          
   3006            return (*((uint8 *)(&test)));
   3007          }
   3008          
   3009          /*********************************************************************
   3010           * @fn      zcl_BuildAnalogData
   3011           *
   3012           * @brief   Build an analog arribute out of sequential bytes.
   3013           *
   3014           * @param   dataType - type of data
   3015           * @param   pData - pointer to data
   3016           * @param   pBuf - where to put the data
   3017           *
   3018           * @return  none
   3019           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3020          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   \                     zcl_BuildAnalogData:
   3021          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   3022            int current_byte_index;
   3023            int remaining_bytes;
   3024            int step;
   3025          
   3026            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   \   000012                ; Setup parameters for call to function zclGetAttrDataLength
   \   000012   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   3027          
   3028            // decide if move forward or backwards to copy data
   3029            if ( zclIsLittleEndianMachine() )
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7401         MOV     A,#0x1
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   E4           CLR     A
   \   000020   F0           MOVX    @DPTR,A
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   E0           MOVX    A,@DPTR
   \   000028   600C         JZ      ??zcl_BuildAnalogData_0
   3030            {
   3031              step = 1;
   \   00002A   75..01       MOV     ?V4,#0x1
   \   00002D   75..00       MOV     ?V5,#0x0
   3032              current_byte_index = 0;
   \   000030   7800         MOV     R0,#0x0
   \   000032   7900         MOV     R1,#0x0
   \   000034   8033         SJMP    ??zcl_BuildAnalogData_1
   3033            }
   3034            else
   3035            {
   3036              step = -1;
   \                     ??zcl_BuildAnalogData_0:
   \   000036   75..FF       MOV     ?V4,#-0x1
   \   000039   75..FF       MOV     ?V5,#-0x1
   3037              current_byte_index = remaining_bytes - 1;
   \   00003C   EA           MOV     A,R2
   \   00003D   24FF         ADD     A,#-0x1
   \   00003F   F8           MOV     R0,A
   \   000040   EB           MOV     A,R3
   \   000041   34FF         ADDC    A,#-0x1
   \   000043   8023         SJMP    ??zcl_BuildAnalogData_2
   3038            }
   3039          
   3040            while ( remaining_bytes-- )
   3041            {
   3042              pData[current_byte_index] = *(pBuf++);
   \                     ??zcl_BuildAnalogData_3:
   \   000045   85..82       MOV     DPL,?V0
   \   000048   85..83       MOV     DPH,?V1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   C0E0         PUSH    A
   \   00004E   EE           MOV     A,R6
   \   00004F   28           ADD     A,R0
   \   000050   F582         MOV     DPL,A
   \   000052   EF           MOV     A,R7
   \   000053   39           ADDC    A,R1
   \   000054   F583         MOV     DPH,A
   \   000056   D0E0         POP     A
   \   000058   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   00005B   8582..       MOV     ?V0,DPL
   \   00005E   8583..       MOV     ?V1,DPH
   3043              current_byte_index += step;
   \   000061   E8           MOV     A,R0
   \   000062   25..         ADD     A,?V4
   \   000064   F8           MOV     R0,A
   \   000065   E9           MOV     A,R1
   \   000066   35..         ADDC    A,?V5
   \                     ??zcl_BuildAnalogData_2:
   \   000068   F9           MOV     R1,A
   3044            }
   \                     ??zcl_BuildAnalogData_1:
   \   000069   EA           MOV     A,R2
   \   00006A   FC           MOV     R4,A
   \   00006B   EB           MOV     A,R3
   \   00006C   FD           MOV     R5,A
   \   00006D   EC           MOV     A,R4
   \   00006E   24FF         ADD     A,#-0x1
   \   000070   1A           DEC     R2
   \   000071   ED           MOV     A,R5
   \   000072   34FF         ADDC    A,#-0x1
   \   000074   FB           MOV     R3,A
   \   000075   EC           MOV     A,R4
   \   000076   4D           ORL     A,R5
   \   000077   70CC         JNZ     ??zcl_BuildAnalogData_3
   3045          }
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007E   02....       LJMP    ?Subroutine4 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   3046          #endif // ZCL_REPORT
   3047          
   3048          /*********************************************************************
   3049           * @fn      zclGetDataTypeLength
   3050           *
   3051           * @brief   Return the length of the datatype in octet.
   3052           *
   3053           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   3054           *                ZCL_DATATYPE_CHAR_STR data types.
   3055           *
   3056           * @param   dataType - data type
   3057           *
   3058           * @return  length of data
   3059           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3060          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   3061          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   3062            uint8 len;
   3063          
   3064            switch ( dataType )
   \   000001   24F8         ADD     A,#-0x8
   \   000003   6078         JZ      ??zclGetDataTypeLength_0
   \   000005   14           DEC     A
   \   000006   6079         JZ      ??zclGetDataTypeLength_1
   \   000008   14           DEC     A
   \   000009   607A         JZ      ??zclGetDataTypeLength_2
   \   00000B   14           DEC     A
   \   00000C   607B         JZ      ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   606B         JZ      ??zclGetDataTypeLength_0
   \   000012   24F8         ADD     A,#-0x8
   \   000014   6067         JZ      ??zclGetDataTypeLength_0
   \   000016   14           DEC     A
   \   000017   6068         JZ      ??zclGetDataTypeLength_1
   \   000019   14           DEC     A
   \   00001A   6069         JZ      ??zclGetDataTypeLength_2
   \   00001C   14           DEC     A
   \   00001D   606A         JZ      ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   605A         JZ      ??zclGetDataTypeLength_0
   \   000023   14           DEC     A
   \   000024   605B         JZ      ??zclGetDataTypeLength_1
   \   000026   14           DEC     A
   \   000027   605C         JZ      ??zclGetDataTypeLength_2
   \   000029   14           DEC     A
   \   00002A   605D         JZ      ??zclGetDataTypeLength_3
   \   00002C   14           DEC     A
   \   00002D   605E         JZ      ??zclGetDataTypeLength_4
   \   00002F   14           DEC     A
   \   000030   605F         JZ      ??zclGetDataTypeLength_5
   \   000032   14           DEC     A
   \   000033   6060         JZ      ??zclGetDataTypeLength_6
   \   000035   14           DEC     A
   \   000036   6061         JZ      ??zclGetDataTypeLength_7
   \   000038   14           DEC     A
   \   000039   6042         JZ      ??zclGetDataTypeLength_0
   \   00003B   14           DEC     A
   \   00003C   6043         JZ      ??zclGetDataTypeLength_1
   \   00003E   14           DEC     A
   \   00003F   6044         JZ      ??zclGetDataTypeLength_2
   \   000041   14           DEC     A
   \   000042   6045         JZ      ??zclGetDataTypeLength_3
   \   000044   14           DEC     A
   \   000045   6046         JZ      ??zclGetDataTypeLength_4
   \   000047   14           DEC     A
   \   000048   6047         JZ      ??zclGetDataTypeLength_5
   \   00004A   14           DEC     A
   \   00004B   6048         JZ      ??zclGetDataTypeLength_6
   \   00004D   14           DEC     A
   \   00004E   6049         JZ      ??zclGetDataTypeLength_7
   \   000050   14           DEC     A
   \   000051   602A         JZ      ??zclGetDataTypeLength_0
   \   000053   14           DEC     A
   \   000054   602B         JZ      ??zclGetDataTypeLength_1
   \   000056   24F9         ADD     A,#-0x7
   \   000058   6027         JZ      ??zclGetDataTypeLength_1
   \   00005A   14           DEC     A
   \   00005B   602C         JZ      ??zclGetDataTypeLength_3
   \   00005D   14           DEC     A
   \   00005E   6039         JZ      ??zclGetDataTypeLength_7
   \   000060   245A         ADD     A,#0x5a
   \   000062   6025         JZ      ??zclGetDataTypeLength_3
   \   000064   14           DEC     A
   \   000065   6022         JZ      ??zclGetDataTypeLength_3
   \   000067   14           DEC     A
   \   000068   601F         JZ      ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD     A,#-0x6
   \   00006C   6013         JZ      ??zclGetDataTypeLength_1
   \   00006E   14           DEC     A
   \   00006F   6010         JZ      ??zclGetDataTypeLength_1
   \   000071   14           DEC     A
   \   000072   6015         JZ      ??zclGetDataTypeLength_3
   \   000074   24FA         ADD     A,#-0x6
   \   000076   6021         JZ      ??zclGetDataTypeLength_7
   \   000078   14           DEC     A
   \   000079   6022         JZ      ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP    ??zclGetDataTypeLength_9
   3065            {
   3066              case ZCL_DATATYPE_DATA8:
   3067              case ZCL_DATATYPE_BOOLEAN:
   3068              case ZCL_DATATYPE_BITMAP8:
   3069              case ZCL_DATATYPE_INT8:
   3070              case ZCL_DATATYPE_UINT8:
   3071              case ZCL_DATATYPE_ENUM8:
   3072                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV     R1,#0x1
   3073                break;
   \   00007F   8022         SJMP    ??zclGetDataTypeLength_10
   3074          
   3075              case ZCL_DATATYPE_DATA16:
   3076              case ZCL_DATATYPE_BITMAP16:
   3077              case ZCL_DATATYPE_UINT16:
   3078              case ZCL_DATATYPE_INT16:
   3079              case ZCL_DATATYPE_ENUM16:
   3080              case ZCL_DATATYPE_SEMI_PREC:
   3081              case ZCL_DATATYPE_CLUSTER_ID:
   3082              case ZCL_DATATYPE_ATTR_ID:
   3083                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV     R1,#0x2
   3084                break;
   \   000083   801E         SJMP    ??zclGetDataTypeLength_10
   3085          
   3086              case ZCL_DATATYPE_DATA24:
   3087              case ZCL_DATATYPE_BITMAP24:
   3088              case ZCL_DATATYPE_UINT24:
   3089              case ZCL_DATATYPE_INT24:
   3090                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV     R1,#0x3
   3091                break;
   \   000087   801A         SJMP    ??zclGetDataTypeLength_10
   3092          
   3093              case ZCL_DATATYPE_DATA32:
   3094              case ZCL_DATATYPE_BITMAP32:
   3095              case ZCL_DATATYPE_UINT32:
   3096              case ZCL_DATATYPE_INT32:
   3097              case ZCL_DATATYPE_SINGLE_PREC:
   3098              case ZCL_DATATYPE_TOD:
   3099              case ZCL_DATATYPE_DATE:
   3100              case ZCL_DATATYPE_UTC:
   3101              case ZCL_DATATYPE_BAC_OID:
   3102                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV     R1,#0x4
   3103                break;
   \   00008B   8016         SJMP    ??zclGetDataTypeLength_10
   3104          
   3105             case ZCL_DATATYPE_UINT40:
   3106             case ZCL_DATATYPE_INT40:
   3107                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV     R1,#0x5
   3108                 break;
   \   00008F   8012         SJMP    ??zclGetDataTypeLength_10
   3109          
   3110             case ZCL_DATATYPE_UINT48:
   3111             case ZCL_DATATYPE_INT48:
   3112                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV     R1,#0x6
   3113                 break;
   \   000093   800E         SJMP    ??zclGetDataTypeLength_10
   3114          
   3115             case ZCL_DATATYPE_UINT56:
   3116             case ZCL_DATATYPE_INT56:
   3117                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV     R1,#0x7
   3118                 break;
   \   000097   800A         SJMP    ??zclGetDataTypeLength_10
   3119          
   3120             case ZCL_DATATYPE_DOUBLE_PREC:
   3121             case ZCL_DATATYPE_IEEE_ADDR:
   3122             case ZCL_DATATYPE_UINT64:
   3123             case ZCL_DATATYPE_INT64:
   3124               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV     R1,#0x8
   3125               break;
   \   00009B   8006         SJMP    ??zclGetDataTypeLength_10
   3126          
   3127              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3128               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV     R1,#0x10
   3129               break;
   \   00009F   8002         SJMP    ??zclGetDataTypeLength_10
   3130          
   3131              case ZCL_DATATYPE_NO_DATA:
   3132              case ZCL_DATATYPE_UNKNOWN:
   3133                // Fall through
   3134          
   3135              default:
   3136                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV     R1,#0x0
   3137                break;
   3138            }
   3139          
   3140            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP    ?BRET
   3141          }
   3142          
   3143          /*********************************************************************
   3144           * @fn      zclGetAttrDataLength
   3145           *
   3146           * @brief   Return the length of the attribute.
   3147           *
   3148           * @param   dataType - data type
   3149           * @param   pData - pointer to data
   3150           *
   3151           * @return  returns atrribute length
   3152           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3153          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   3154          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   3155            uint16 dataLen = 0;
   3156          
   3157            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV     A,#0x44
   \   000009   6E           XRL     A,R6
   \   00000A   6005         JZ      ??zclGetAttrDataLength_0
   \   00000C   7443         MOV     A,#0x43
   \   00000E   6E           XRL     A,R6
   \   00000F   700C         JNZ     ??zclGetAttrDataLength_1
   3158            {
   3159              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ?Subroutine106 & 0xFFFF
   3160            }
   \                     ??CrossCallReturnLabel_171:
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   39           ADDC    A,R1
   \   00001B   8015         SJMP    ??zclGetAttrDataLength_2
   3161            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV     A,#0x42
   \   00001F   6E           XRL     A,R6
   \   000020   6005         JZ      ??zclGetAttrDataLength_3
   \   000022   7441         MOV     A,#0x41
   \   000024   6E           XRL     A,R6
   \   000025   700E         JNZ     ??zclGetAttrDataLength_4
   3162            {
   3163              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   2401         ADD     A,#0x1
   \   00002E   FA           MOV     R2,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV     R3,A
   \   000033   8007         SJMP    ??zclGetAttrDataLength_5
   3164            }
   3165            else
   3166            {
   3167              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV     A,R1
   \   000039   FA           MOV     R2,A
   \   00003A   7B00         MOV     R3,#0x0
   3168            }
   3169          
   3170            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP    ??Subroutine193_0 & 0xFFFF
   3171          }
   3172          
   3173          #ifdef ZCL_READ
   3174          /*********************************************************************
   3175           * @fn      zclReadAttrData
   3176           *
   3177           * @brief   Read the attribute's current value into pAttrData.
   3178           *          NOTE - Not compatible with application's attributes callbacks.
   3179           *
   3180           * @param   pAttrData - where to put attribute data
   3181           * @param   pAttr - pointer to attribute
   3182           * @param   pDataLen - where to put attribute data length
   3183           *
   3184           * @return Success
   3185           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3186          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   3187          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3188            uint16 dataLen;
   3189          
   3190            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   3D           ADDC    A,R5
   \   00000F   F9           MOV     R1,A
   \   000010   88..         MOV     ?V0,R0
   \   000012   89..         MOV     ?V1,R1
   \   000014   8882         MOV     DPL,R0
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   00001B   7004         JNZ     ??zclReadAttrData_0
   3191            {
   3192              return ( ZCL_STATUS_FAILURE );
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   804C         SJMP    ??zclReadAttrData_1
   3193            }
   3194          
   3195            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000021                ; Setup parameters for call to function zclGetAttrDataLength
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00002E   8A..         MOV     ?V2,R2
   \   000030   8B..         MOV     ?V3,R3
   3196            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   85..82       MOV     DPL,?V0
   \   000035   85..83       MOV     DPH,?V1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   85....       MOV     ?V4,?V0
   \   000040   F5..         MOV     ?V5,A
   \   000042   75..00       MOV     ?V6,#0x0
   \   000045   78..         MOV     R0,#?V4
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004A   AC..         MOV     R4,?V2
   \   00004C   AD..         MOV     R5,?V3
   \   00004E   EE           MOV     A,R6
   \   00004F   FA           MOV     R2,A
   \   000050   EF           MOV     A,R7
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   740F         MOV     A,#0xf
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   3197          
   3198            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_343:
   \   000062   6007         JZ      ??zclReadAttrData_2
   3199            {
   3200              *pDataLen = dataLen;
   \   000064   E5..         MOV     A,?V2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E5..         MOV     A,?V3
   \   00006A   F0           MOVX    @DPTR,A
   3201            }
   3202          
   3203            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   00006B   7900         MOV     R1,#0x0
   \                     ??zclReadAttrData_1:
   \   00006D   02....       LJMP    ?Subroutine9 & 0xFFFF
   3204          }
   3205          
   3206          /*********************************************************************
   3207           * @fn      zcl_ReadAttrData
   3208           *
   3209           * @brief   Read the attribute's current value into pAttrData.
   3210           *          Use application's callback function if assigned to this attribute.
   3211           *
   3212           * @param   endpoint - application's endpoint
   3213           * @param   clusterId - cluster that attribute belongs to
   3214           * @param   attrId - attribute id
   3215           * @param   pAttrData - where to put attribute data
   3216           * @param   pDataLen - where to put attribute data length
   3217           *
   3218           * @return  Successful if data was read
   3219           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3220          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   3221                                                   uint8 *pAttrData, uint16 *pDataLen )
   3222          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V2,R1
   \   00000C   8A..         MOV     ?V0,R2
   \   00000E   8B..         MOV     ?V1,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   3223            zclAttrRec_t attrRec;
   3224          
   3225            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   000014                ; Setup parameters for call to function zclFindAttrRec
   \   000014   A8..         MOV     R0,?XSP + 0
   \   000016   A9..         MOV     R1,?XSP + 1
   \   000018   88..         MOV     ?V4,R0
   \   00001A   89..         MOV     ?V5,R1
   \   00001C   78..         MOV     R0,#?V4
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   A9..         MOV     R1,?V2
   \   000023   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002B   E9           MOV     A,R1
   \   00002C   7004         JNZ     ??zcl_ReadAttrData_0
   3226            {
   3227              return ( ZCL_STATUS_FAILURE );
   \   00002E   7901         MOV     R1,#0x1
   \   000030   804C         SJMP    ??zcl_ReadAttrData_1
   3228            }
   \                     ??zcl_ReadAttrData_0:
   \   000032   7418         MOV     A,#0x18
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_405:
   \   00003A   741A         MOV     A,#0x1a
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine87 & 0xFFFF
   3229          
   3230            if ( attrRec.attr.dataPtr != NULL )
   \                     ??CrossCallReturnLabel_136:
   \   000042   7406         MOV     A,#0x6
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   00004A   78..         MOV     R0,#?V4
   \   00004C   6016         JZ      ??zcl_ReadAttrData_2
   3231            {
   3232              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   00004E                ; Setup parameters for call to function zclReadAttrData
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?XSTACK_DISP102_8
   \   000056   AA..         MOV     R2,?V6
   \   000058   AB..         MOV     R3,?V7
   \   00005A   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   801A         SJMP    ??zcl_ReadAttrData_1
   3233            }
   3234            else
   3235            {
   3236              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000064                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   78..         MOV     R0,#?V6
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V0
   \   000072   AB..         MOV     R3,?V1
   \   000074   A9..         MOV     R1,?V2
   \   000076   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   000079   7404         MOV     A,#0x4
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   00007E   7408         MOV     A,#0x8
   3237            }
   \   000080   02....       LJMP    ?Subroutine8 & 0xFFFF
   3238          }
   3239          
   3240          /*********************************************************************
   3241           * @fn      zclGetAttrDataLengthUsingCB
   3242           *
   3243           * @brief   Use application's callback to get the length of the attribute's
   3244           *          current value stored in the database.
   3245           *
   3246           * @param   endpoint - application's endpoint
   3247           * @param   clusterId - cluster that attribute belongs to
   3248           * @param   attrId - attribute id
   3249           *
   3250           * @return  returns attribute length
   3251           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3252          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3253          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3254            uint16 dataLen = 0;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   E4           CLR     A
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   3255            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001C                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001C   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   00001F   8A..         MOV     ?V0,R2
   \   000021   8B..         MOV     ?V1,R3
   3256          
   3257            if ( pfnReadWriteCB != NULL )
   \   000023   EA           MOV     A,R2
   \   000024   45..         ORL     A,?V1
   \   000026   602F         JZ      ??zclGetAttrDataLengthUsingCB_0
   3258            {
   3259              // Only get the attribute length
   3260              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000028                ; Setup parameters for indirect call
   \   000028   A8..         MOV     R0,?XSP + 0
   \   00002A   A9..         MOV     R1,?XSP + 1
   \   00002C   88..         MOV     ?V6,R0
   \   00002E   89..         MOV     ?V7,R1
   \   000030   78..         MOV     R0,#?V6
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   E4           CLR     A
   \   000036   F5..         MOV     ?V6,A
   \   000038   F5..         MOV     ?V7,A
   \   00003A   78..         MOV     R0,#?V6
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   7900         MOV     R1,#0x0
   \   000041   EE           MOV     A,R6
   \   000042   FC           MOV     R4,A
   \   000043   EF           MOV     A,R7
   \   000044   FD           MOV     R5,A
   \   000045   AA..         MOV     R2,?V4
   \   000047   AB..         MOV     R3,?V5
   \   000049   85..82       MOV     DPL,?V0
   \   00004C   85..83       MOV     DPH,?V1
   \   00004F   12....       LCALL   ?CALL_IND
   \   000052   7404         MOV     A,#0x4
   \   000054   12....       LCALL   ?DEALLOC_XSTACK8
   3261            }
   3262          
   3263            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_390:
   \   000060   7402         MOV     A,#0x2
   \   000062   02....       LJMP    ?Subroutine8 & 0xFFFF
   3264          }
   3265          
   3266          /*********************************************************************
   3267           * @fn      zclReadAttrDataUsingCB
   3268           *
   3269           * @brief   Use application's callback to read the attribute's current
   3270           *          value stored in the database.
   3271           *
   3272           * @param   endpoint - application's endpoint
   3273           * @param   clusterId - cluster that attribute belongs to
   3274           * @param   attrId - attribute id
   3275           * @param   pAttrData - where to put attribute data
   3276           * @param   pDataLen - where to put attribute data length
   3277           *
   3278           * @return  Successful if data was read
   3279           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3280          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3281                                                   uint8 *pAttrData, uint16 *pDataLen )
   3282          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   3283            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00000D   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000010   8A..         MOV     ?V2,R2
   \   000012   8B..         MOV     ?V3,R3
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   3284          
   3285            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_406:
   \   00001C   E5..         MOV     A,?V6
   \   00001E   45..         ORL     A,?V7
   \   000020   600A         JZ      ??zclReadAttrDataUsingCB_0
   3286            {
   3287              *pDataLen = 0; // Always initialize it to 0
   \   000022   85..82       MOV     DPL,?V6
   \   000025   85..83       MOV     DPH,?V7
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   F0           MOVX    @DPTR,A
   3288            }
   3289          
   3290            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00002C   EA           MOV     A,R2
   \   00002D   45..         ORL     A,?V3
   \   00002F   6027         JZ      ??zclReadAttrDataUsingCB_1
   3291            {
   3292              // Read the attribute value and its length
   3293              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000031                ; Setup parameters for indirect call
   \   000031   78..         MOV     R0,#?V6
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7412         MOV     A,#0x12
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003E   7901         MOV     R1,#0x1
   \   000040   EE           MOV     A,R6
   \   000041   FC           MOV     R4,A
   \   000042   EF           MOV     A,R7
   \   000043   FD           MOV     R5,A
   \   000044   AA..         MOV     R2,?V0
   \   000046   AB..         MOV     R3,?V1
   \   000048   85..82       MOV     DPL,?V2
   \   00004B   85..83       MOV     DPH,?V3
   \   00004E   12....       LCALL   ?CALL_IND
   \   000051   7404         MOV     A,#0x4
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   \   000056   8002         SJMP    ??zclReadAttrDataUsingCB_2
   3294            }
   3295          
   3296            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000058   79C1         MOV     R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00005A   02....       LJMP    ??Subroutine194_0 & 0xFFFF
   3297          }
   3298          
   3299          /*********************************************************************
   3300           * @fn      zclAuthorizeRead
   3301           *
   3302           * @brief   Use application's callback to authorize a Read operation
   3303           *          on a given attribute.
   3304           *
   3305           * @param   endpoint - application's endpoint
   3306           * @param   srcAddr - source Address
   3307           * @param   pAttr - pointer to attribute
   3308           *
   3309           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3310           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3311           */
   3312          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3313          {
   3314            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3315            {
   3316              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3317          
   3318              if ( pfnAuthorizeCB != NULL )
   3319              {
   3320                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3321              }
   3322            }
   3323          
   3324            return ( ZCL_STATUS_SUCCESS );
   3325          }
   3326          #endif // ZCL_READ
   3327          
   3328          #ifdef ZCL_WRITE
   3329          /*********************************************************************
   3330           * @fn      zclWriteAttrData
   3331           *
   3332           * @brief   Write the received data.
   3333           *
   3334           * @param   endpoint - application's endpoint
   3335           * @param   pAttr - where to write data to
   3336           * @param   pWriteRec - data to be written
   3337           *
   3338           * @return  Successful if data was written
   3339           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3340          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3341                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3342          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   3343            uint8 status;
   3344          
   3345            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   A2E1         MOV     C,0xE0 /* A   */.1
   \   000015   5077         JNC     ??zclWriteAttrData_0
   3346            {
   3347              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017                ; Setup parameters for call to function zclAuthorizeWrite
   \   000017   12....       LCALL   `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001A   E9           MOV     A,R1
   \   00001B   F5..         MOV     ?V2,A
   3348              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7072         JNZ     ??zclWriteAttrData_1
   \   00001F   740F         MOV     A,#0xf
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine147 & 0xFFFF
   3349              {
   3350                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \                     ??CrossCallReturnLabel_244:
   \   000027   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00002A   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   00002D   6013         JZ      ??zclWriteAttrData_2
   \   00002F                ; Setup parameters for indirect call
   \   00002F   AC..         MOV     R4,?V0
   \   000031   AD..         MOV     R5,?V1
   \   000033   EE           MOV     A,R6
   \   000034   FA           MOV     R2,A
   \   000035   EF           MOV     A,R7
   \   000036   FB           MOV     R3,A
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F583         MOV     DPH,A
   \   00003A   8882         MOV     DPL,R0
   \   00003C   12....       LCALL   ?CALL_IND
   \   00003F   E9           MOV     A,R1
   \   000040   6047         JZ      ??zclWriteAttrData_3
   3351                {
   3352                  // Write the attribute value
   3353                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000042   E5..         MOV     A,?V0
   \   000044   2403         ADD     A,#0x3
   \   000046   F8           MOV     R0,A
   \   000047   E4           CLR     A
   \   000048   35..         ADDC    A,?V1
   \   00004A   F9           MOV     R1,A
   \   00004B   88..         MOV     ?V0,R0
   \   00004D   89..         MOV     ?V1,R1
   \   00004F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00004F   8882         MOV     DPL,R0
   \   000051   F583         MOV     DPH,A
   \   000053   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_391:
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000063   8A..         MOV     ?V4,R2
   \   000065   8B..         MOV     ?V5,R3
   \   000067   AC..         MOV     R4,?V4
   \   000069   AD..         MOV     R5,?V5
   3354                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00006B                ; Setup parameters for call to function osal_memcpy
   \   00006B   85..82       MOV     DPL,?V0
   \   00006E   85..83       MOV     DPH,?V1
   \   000071   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000077   8E82         MOV     DPL,R6
   \   000079   8F83         MOV     DPH,R7
   \   00007B   A3           INC     DPTR
   \   00007C   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_398:
   \   00007F   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000082   7403         MOV     A,#0x3
   \   000084   12....       LCALL   ?DEALLOC_XSTACK8
   3355          
   3356                  status = ZCL_STATUS_SUCCESS;
   \   000087   8008         SJMP    ??zclWriteAttrData_1
   3357                }
   3358                else
   3359                {
   3360                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   000089   75..87       MOV     ?V2,#-0x79
   \   00008C   8003         SJMP    ??zclWriteAttrData_1
   3361                }
   3362              }
   3363            }
   3364            else
   3365            {
   3366              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   00008E   75..88       MOV     ?V2,#-0x78
   3367            }
   3368          
   3369            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000091   A9..         MOV     R1,?V2
   \   000093   02....       LJMP    ?Subroutine9 & 0xFFFF
   3370          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine147:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V1,A
   \   000007   22           RET
   3371          
   3372          /*********************************************************************
   3373           * @fn      zclWriteAttrDataUsingCB
   3374           *
   3375           * @brief   Use application's callback to write the attribute's current
   3376           *          value stored in the database.
   3377           *
   3378           * @param   endpoint - application's endpoint
   3379           * @param   pAttr - where to write data to
   3380           * @param   pAttrData - data to be written
   3381           *
   3382           * @return  Successful if data was written
   3383           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3384          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3385                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3386          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EC           MOV     A,R4
   \   000008   FE           MOV     R6,A
   \   000009   ED           MOV     A,R5
   \   00000A   FF           MOV     R7,A
   3387            uint8 status;
   3388          
   3389            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   8F83         MOV     DPH,R7
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   A2E1         MOV     C,0xE0 /* A   */.1
   \   000017   504D         JNC     ??zclWriteAttrDataUsingCB_0
   3390            {
   3391              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000019                ; Setup parameters for call to function zclAuthorizeWrite
   \   000019   12....       LCALL   `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001C   E9           MOV     A,R1
   \   00001D   F9           MOV     R1,A
   3392              if ( status == ZCL_STATUS_SUCCESS )
   \   00001E   7048         JNZ     ??zclWriteAttrDataUsingCB_1
   3393              {
   3394                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000020                ; Setup parameters for call to function zclGetReadWriteCB
   \   000020   A9..         MOV     R1,?V0
   \   000022   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000025   8A..         MOV     ?V2,R2
   \   000027   8B..         MOV     ?V3,R3
   3395                if ( pfnReadWriteCB != NULL )
   \   000029   EA           MOV     A,R2
   \   00002A   45..         ORL     A,?V3
   \   00002C   6034         JZ      ??zclWriteAttrDataUsingCB_2
   3396                {
   3397                  // Write the attribute value
   3398                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3399                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   00002E                ; Setup parameters for indirect call
   \   00002E   E4           CLR     A
   \   00002F   F5..         MOV     ?V4,A
   \   000031   F5..         MOV     ?V5,A
   \   000033   78..         MOV     R0,#?V4
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   7410         MOV     A,#0x10
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000040   7902         MOV     R1,#0x2
   \   000042   8E82         MOV     DPL,R6
   \   000044   8F83         MOV     DPH,R7
   \   000046   12....       LCALL   ??Subroutine219_0 & 0xFFFF
   3400                }
   \                     ??CrossCallReturnLabel_519:
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_392:
   \   000050   85..82       MOV     DPL,?V2
   \   000053   85..83       MOV     DPH,?V3
   \   000056   12....       LCALL   ?CALL_IND
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005E   E9           MOV     A,R1
   \   00005F   F9           MOV     R1,A
   \   000060   8006         SJMP    ??zclWriteAttrDataUsingCB_1
   3401                else
   3402                {
   3403                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000062   79C1         MOV     R1,#-0x3f
   \   000064   8002         SJMP    ??zclWriteAttrDataUsingCB_1
   3404                }
   3405              }
   3406            }
   3407            else
   3408            {
   3409              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   000066   7988         MOV     R1,#-0x78
   3410            }
   3411          
   3412            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000068                REQUIRE ?Subroutine4
   \   000068                ; // Fall through to label ?Subroutine4
   3413          }
   3414          
   3415          /*********************************************************************
   3416           * @fn      zclAuthorizeWrite
   3417           *
   3418           * @brief   Use application's callback to authorize a Write operation
   3419           *          on a given attribute.
   3420           *
   3421           * @param   endpoint - application's endpoint
   3422           * @param   srcAddr - source Address
   3423           * @param   pAttr - pointer to attribute
   3424           *
   3425           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3426           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3427           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3428          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3429          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   3430            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000D   8C82         MOV     DPL,R4
   \   00000F   8D83         MOV     DPH,R5
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E5         MOV     C,0xE0 /* A   */.5
   \   000019   501C         JNC     ??zclAuthorizeWrite_0
   3431            {
   3432              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001B                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001B   12....       LCALL   `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   3433          
   3434              if ( pfnAuthorizeCB != NULL )
   \   000022   E582         MOV     A,DPL
   \   000024   4583         ORL     A,DPH
   \   000026   600F         JZ      ??zclAuthorizeWrite_0
   3435              {
   3436                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000028                ; Setup parameters for indirect call
   \   000028   7902         MOV     R1,#0x2
   \   00002A   AC..         MOV     R4,?V0
   \   00002C   AD..         MOV     R5,?V1
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   EF           MOV     A,R7
   \   000031   FB           MOV     R3,A
   \   000032   12....       LCALL   ?CALL_IND
   \   000035   8002         SJMP    ??zclAuthorizeWrite_1
   3437              }
   3438            }
   3439          
   3440            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000037   7900         MOV     R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000039   80..         SJMP    ?Subroutine4
   3441          }
   3442          #endif // ZCL_WRITE
   3443          
   3444          #ifdef ZCL_READ
   3445          /*********************************************************************
   3446           * @fn      zclParseInReadCmd
   3447           *
   3448           * @brief   Parse the "Profile" Read Commands
   3449           *
   3450           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3451           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3452           *
   3453           * @param   pCmd - pointer to incoming data to parse
   3454           *
   3455           * @return  pointer to the parsed command structure
   3456           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3457          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3458          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3459            zclReadCmd_t *readCmd;
   3460            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine97 & 0xFFFF
   3461          
   3462            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_153:
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   8582..       MOV     ?V0,DPL
   \   000010   8583..       MOV     ?V1,DPH
   \   000013                ; Setup parameters for call to function osal_mem_alloc
   \   000013   E0           MOVX    A,@DPTR
   \   000014   2429         ADD     A,#0x29
   \   000016   FA           MOV     R2,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   3400         ADDC    A,#0x0
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3463            if ( readCmd != NULL )
   \   00001F   EA           MOV     A,R2
   \   000020   4B           ORL     A,R3
   \   000021   6049         JZ      ??zclParseInReadCmd_0
   3464            {
   3465              uint8 i;
   3466              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000023   85..82       MOV     DPL,?V0
   \   000026   85..83       MOV     DPH,?V1
   \   000029   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_509:
   \   00002C   C3           CLR     C
   \   00002D   13           RRC     A
   \   00002E   E8           MOV     A,R0
   \   00002F   13           RRC     A
   \   000030   8A82         MOV     DPL,R2
   \   000032   8B83         MOV     DPH,R3
   \   000034   F0           MOVX    @DPTR,A
   3467              for ( i = 0; i < readCmd->numAttr; i++ )
   \   000035   75..00       MOV     ?V0,#0x0
   \   000038   8029         SJMP    ??zclParseInReadCmd_1
   3468              {
   3469                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   12....       LCALL   ?Subroutine158 & 0xFFFF
   3470                pBuf += 2;
   3471              }
   \                     ??CrossCallReturnLabel_263:
   \   000041   F8           MOV     R0,A
   \   000042   E4           CLR     A
   \   000043   C8           XCH     A,R0
   \   000044   F9           MOV     R1,A
   \   000045   EC           MOV     A,R4
   \   000046   28           ADD     A,R0
   \   000047   E4           CLR     A
   \   000048   39           ADDC    A,R1
   \   000049   FD           MOV     R5,A
   \   00004A   A8..         MOV     R0,?V0
   \   00004C   E8           MOV     A,R0
   \   00004D   28           ADD     A,R0
   \   00004E   F8           MOV     R0,A
   \   00004F   E4           CLR     A
   \   000050   33           RLC     A
   \   000051   F9           MOV     R1,A
   \   000052   EA           MOV     A,R2
   \   000053   28           ADD     A,R0
   \   000054   F582         MOV     DPL,A
   \   000056   EB           MOV     A,R3
   \   000057   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   00005A   EC           MOV     A,R4
   \   00005B   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_438:
   \   00005E   5001         JNC     ??zclParseInReadCmd_3
   \   000060   0F           INC     R7
   \                     ??zclParseInReadCmd_3:
   \   000061   05..         INC     ?V0
   \                     ??zclParseInReadCmd_1:
   \   000063   8A82         MOV     DPL,R2
   \   000065   8B83         MOV     DPH,R3
   \   000067   12....       LCALL   ??Subroutine181_0 & 0xFFFF
   3472            }
   \                     ??CrossCallReturnLabel_322:
   \   00006A   40CE         JC      ??zclParseInReadCmd_2
   3473          
   3474            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   00006C   02....       LJMP    ?Subroutine1 & 0xFFFF
   3475          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine207_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   ED           MOV     A,R5
   \   000003   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_440:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_378:
   \   00000A   FE           MOV     R6,A
   \   00000B   E9           MOV     A,R1
   \   00000C   FF           MOV     R7,A
   \   00000D   22           RET
   3476          
   3477          /*********************************************************************
   3478           * @fn      zclParseInReadRspCmd
   3479           *
   3480           * @brief   Parse the "Profile" Read Response Commands
   3481           *
   3482           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3483           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3484           *
   3485           * @param   pCmd - pointer to incoming data to parse
   3486           *
   3487           * @return  pointer to the parsed command structure
   3488           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   AA..         MOV     R2,?V10
   \   000002   AB..         MOV     R3,?V11
   \   000004                REQUIRE ??Subroutine177_0
   \   000004                ; // Fall through to label ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3489          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3490          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   3491            zclReadRspCmd_t *readRspCmd;
   3492            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V4,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V5,A
   \   000013   85..82       MOV     DPL,?V4
   \   000016   12....       LCALL   ?Subroutine76 & 0xFFFF
   3493            uint8 *dataPtr;
   3494            uint8 numAttr = 0;
   3495            uint8 hdrLen;
   3496            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_118:
   \   000019   8049         SJMP    ??zclParseInReadRspCmd_0
   3497            uint16 attrDataLen;
   3498          
   3499            // find out the number of attributes and the length of attribute data
   3500            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3501            {
   3502              uint8 status;
   3503          
   3504              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00001B   05..         INC     ?V2
   3505              pBuf += 2; // move pass attribute id
   3506          
   3507              status = *pBuf++;
   \   00001D   8E82         MOV     DPL,R6
   \   00001F   8F83         MOV     DPH,R7
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F8           MOV     R0,A
   \   000025   EE           MOV     A,R6
   \   000026   2403         ADD     A,#0x3
   \   000028   FE           MOV     R6,A
   \   000029   5001         JNC     ??zclParseInReadRspCmd_2
   \   00002B   0F           INC     R7
   3508              if ( status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_2:
   \   00002C   E8           MOV     A,R0
   \   00002D   7035         JNZ     ??zclParseInReadRspCmd_0
   3509              {
   3510                uint8 dataType = *pBuf++;
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   A3           INC     DPTR
   \   000036   AE82         MOV     R6,DPL
   \   000038   AF83         MOV     R7,DPH
   3511          
   3512                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   00003A                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003A   EE           MOV     A,R6
   \   00003B   FA           MOV     R2,A
   \   00003C   EF           MOV     A,R7
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000041   8A..         MOV     ?V0,R2
   \   000043   8B..         MOV     ?V1,R3
   3513                pBuf += attrDataLen; // move pass attribute data
   \   000045   EE           MOV     A,R6
   \   000046   2A           ADD     A,R2
   \   000047   FE           MOV     R6,A
   \   000048   EF           MOV     A,R7
   \   000049   35..         ADDC    A,?V1
   \   00004B   FF           MOV     R7,A
   3514          
   3515                // add padding if needed
   3516                if ( PADDING_NEEDED( attrDataLen ) )
   \   00004C   EA           MOV     A,R2
   \   00004D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004F   5007         JNC     ??zclParseInReadRspCmd_3
   3517                {
   3518                  attrDataLen++;
   \   000051   05..         INC     ?V0
   \   000053   04           INC     A
   \   000054   7002         JNZ     ??zclParseInReadRspCmd_3
   \   000056   05..         INC     ?V1
   3519                }
   3520          
   3521                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   000058   E5..         MOV     A,?V6
   \   00005A   25..         ADD     A,?V0
   \   00005C   F5..         MOV     ?V6,A
   \   00005E   E5..         MOV     A,?V7
   \   000060   35..         ADDC    A,?V1
   \   000062   F5..         MOV     ?V7,A
   3522              }
   3523            }
   \                     ??zclParseInReadRspCmd_0:
   \   000064   85..82       MOV     DPL,?V8
   \   000067   85..83       MOV     DPH,?V9
   \   00006A   A3           INC     DPTR
   \   00006B   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   00006E   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_430:
   \   000071   40A8         JC      ??zclParseInReadRspCmd_1
   3524          
   3525            // calculate the length of the response header
   3526            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000073   75F006       MOV     B,#0x6
   \   000076   E5..         MOV     A,?V2
   \   000078   A4           MUL     AB
   \   000079   04           INC     A
   \   00007A   F5..         MOV     ?V0,A
   3527          
   3528            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   00007C                ; Setup parameters for call to function osal_mem_alloc
   \   00007C   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   00007F   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000082   8A..         MOV     ?V10,R2
   \   000084   8B..         MOV     ?V11,R3
   3529            if ( readRspCmd != NULL )
   \   000086   EA           MOV     A,R2
   \   000087   45..         ORL     A,?V11
   \   000089   7003         JNZ     $+5
   \   00008B   02....       LJMP    ??zclParseInReadRspCmd_4 & 0xFFFF
   3530            {
   3531              uint8 i;
   3532              pBuf = pCmd->pData;
   \   00008E   85..82       MOV     DPL,?V4
   \   000091   85..83       MOV     DPH,?V5
   \   000094   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   3533              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_422:
   \   000097   A8..         MOV     R0,?V0
   \   000099   EA           MOV     A,R2
   \   00009A   28           ADD     A,R0
   \   00009B   F5..         MOV     ?V8,A
   \   00009D   E4           CLR     A
   \   00009E   3B           ADDC    A,R3
   \   00009F   F5..         MOV     ?V9,A
   3534          
   3535              readRspCmd->numAttr = numAttr;
   \   0000A1   8A82         MOV     DPL,R2
   \   0000A3   8B83         MOV     DPH,R3
   \   0000A5   E5..         MOV     A,?V2
   \   0000A7   F0           MOVX    @DPTR,A
   3536              for ( i = 0; i < numAttr; i++ )
   \   0000A8   75..00       MOV     ?V3,#0x0
   \   0000AB   02....       LJMP    ??zclParseInReadRspCmd_5 & 0xFFFF
   3537              {
   3538                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   0000AE   E5..         MOV     A,?V3
   \   0000B0   75F006       MOV     B,#0x6
   \   0000B3   12....       LCALL   ?Subroutine162 & 0xFFFF
   3539          
   3540                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_267:
   \   0000B6   8E82         MOV     DPL,R6
   \   0000B8   8F83         MOV     DPH,R7
   \   0000BA   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   0000BD   12....       LCALL   ?Subroutine39 & 0xFFFF
   3541                pBuf += 2;
   3542          
   3543                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_49:
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F8           MOV     R0,A
   \   0000C4   85..82       MOV     DPL,?V12
   \   0000C7   85..83       MOV     DPH,?V13
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   EE           MOV     A,R6
   \   0000CE   2403         ADD     A,#0x3
   \   0000D0   FE           MOV     R6,A
   \   0000D1   5001         JNC     ??zclParseInReadRspCmd_7
   \   0000D3   0F           INC     R7
   3544                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_7:
   \   0000D4   E8           MOV     A,R0
   \   0000D5   7064         JNZ     ??zclParseInReadRspCmd_8
   3545                {
   3546                  statusRec->dataType = *pBuf++;
   \   0000D7   8E82         MOV     DPL,R6
   \   0000D9   8F83         MOV     DPH,R7
   \   0000DB   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   0000DE   A3           INC     DPTR
   \   0000DF   12....       LCALL   ?Subroutine33 & 0xFFFF
   3547          
   3548                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_33:
   \   0000E2                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000E2   EE           MOV     A,R6
   \   0000E3   FA           MOV     R2,A
   \   0000E4   EF           MOV     A,R7
   \   0000E5   FB           MOV     R3,A
   \   0000E6   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000E9   8A..         MOV     ?V0,R2
   \   0000EB   8B..         MOV     ?V1,R3
   3549                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000ED                ; Setup parameters for call to function osal_memcpy
   \   0000ED   8E..         MOV     ?V4,R6
   \   0000EF   8F..         MOV     ?V5,R7
   \   0000F1   75..00       MOV     ?V6,#0x0
   \   0000F4   78..         MOV     R0,#?V4
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F9   AC..         MOV     R4,?V0
   \   0000FB   AD..         MOV     R5,?V1
   \   0000FD   AA..         MOV     R2,?V8
   \   0000FF   AB..         MOV     R3,?V9
   \   000101   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000104   7403         MOV     A,#0x3
   \   000106   12....       LCALL   ?DEALLOC_XSTACK8
   3550                  statusRec->data = dataPtr;
   \   000109   85..82       MOV     DPL,?V12
   \   00010C   85..83       MOV     DPH,?V13
   \   00010F   A3           INC     DPTR
   \   000110   A3           INC     DPTR
   \   000111   A3           INC     DPTR
   \   000112   A3           INC     DPTR
   \   000113   E5..         MOV     A,?V8
   \   000115   F0           MOVX    @DPTR,A
   \   000116   A3           INC     DPTR
   \   000117   E5..         MOV     A,?V9
   \   000119   F0           MOVX    @DPTR,A
   3551          
   3552                  pBuf += attrDataLen; // move pass attribute data
   \   00011A   EE           MOV     A,R6
   \   00011B   25..         ADD     A,?V0
   \   00011D   FE           MOV     R6,A
   \   00011E   EF           MOV     A,R7
   \   00011F   35..         ADDC    A,?V1
   \   000121   FF           MOV     R7,A
   3553          
   3554                  // advance attribute data pointer
   3555                  if ( PADDING_NEEDED( attrDataLen ) )
   \   000122   E5..         MOV     A,?V0
   \   000124   A2E0         MOV     C,0xE0 /* A   */.0
   \   000126   5007         JNC     ??zclParseInReadRspCmd_9
   3556                  {
   3557                    attrDataLen++;
   \   000128   05..         INC     ?V0
   \   00012A   04           INC     A
   \   00012B   7002         JNZ     ??zclParseInReadRspCmd_9
   \   00012D   05..         INC     ?V1
   3558                  }
   3559          
   3560                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_9:
   \   00012F   E5..         MOV     A,?V8
   \   000131   25..         ADD     A,?V0
   \   000133   F5..         MOV     ?V8,A
   \   000135   E5..         MOV     A,?V9
   \   000137   35..         ADDC    A,?V1
   \   000139   F5..         MOV     ?V9,A
   3561                }
   3562              }
   \                     ??zclParseInReadRspCmd_8:
   \   00013B   05..         INC     ?V3
   \                     ??zclParseInReadRspCmd_5:
   \   00013D   E5..         MOV     A,?V3
   \   00013F   C3           CLR     C
   \   000140   95..         SUBB    A,?V2
   \   000142   5003         JNC     $+5
   \   000144   02....       LJMP    ??zclParseInReadRspCmd_6 & 0xFFFF
   3563            }
   3564          
   3565            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   000147   02....       LJMP    ?Subroutine7 & 0xFFFF
   3566          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   25..         ADD     A,?V6
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   35..         ADDC    A,?V7
   \   000006   FB           MOV     R3,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine203_0:
   \   000000   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_478:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_476:
   \   000003   75..00       MOV     ?V2,#0x0
   \   000006   75..00       MOV     ?V6,#0x0
   \   000009   75..00       MOV     ?V7,#0x0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine205_0:
   \   000000   12....       LCALL   ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_435:
   \   000003   EE           MOV     A,R6
   \   000004   98           SUBB    A,R0
   \   000005   EF           MOV     A,R7
   \   000006   99           SUBB    A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine160:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   F9           MOV     R1,A
   \   000007   C3           CLR     C
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine162:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V10
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V11
   \   00000B   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   00000E   8582..       MOV     ?V12,DPL
   \   000011   8583..       MOV     ?V13,DPH
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine148:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   85..82       MOV     DPL,?V12
   \   000005   85..83       MOV     DPH,?V13
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   EA           MOV     A,R2
   \   000006   85..82       MOV     DPL,?V12
   \   000009   85..83       MOV     DPH,?V13
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   E9           MOV     A,R1
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_506:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   85..83       MOV     DPH,?V5
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine146:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine213_0
   \   000002                ; // Fall through to label ??Subroutine213_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine213_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET
   3567          #endif // ZCL_READ
   3568          
   3569          #ifdef ZCL_WRITE
   3570          /*********************************************************************
   3571           * @fn      zclParseInWriteCmd
   3572           *
   3573           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3574           *          Response Commands
   3575           *
   3576           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3577           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3578           *
   3579           * @param   pCmd - pointer to incoming data to parse
   3580           *
   3581           * @return  pointer to the parsed command structure
   3582           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3583          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3584          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine73 & 0xFFFF
   3585            zclWriteCmd_t *writeCmd;
   3586            uint8 *pBuf = pCmd->pData;
   3587            uint16 attrDataLen;
   3588            uint8 *dataPtr;
   3589            uint8 numAttr = 0;
   3590            uint8 hdrLen;
   3591            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_114:
   \   000008   801A         SJMP    ??CrossCallReturnLabel_220
   3592          
   3593            // find out the number of attributes and the length of attribute data
   3594            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3595            {
   3596              uint8 dataType;
   3597          
   3598              numAttr++;
   \                     ??zclParseInWriteCmd_0:
   \   00000A   12....       LCALL   ?Subroutine105 & 0xFFFF
   3599              pBuf += 2; // move pass attribute id
   3600          
   3601              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_168:
   \   00000D   5002         JNC     ??zclParseInWriteCmd_1
   \   00000F   05..         INC     ?V1
   3602          
   3603              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??zclParseInWriteCmd_1:
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011   FA           MOV     R2,A
   \   000012   AB..         MOV     R3,?V1
   \   000014   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000017   12....       LCALL   ?Subroutine122 & 0xFFFF
   3604              pBuf += attrDataLen; // move pass attribute data
   3605          
   3606              // add padding if needed
   3607              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_205:
   \   00001A   5005         JNC     ??zclParseInWriteCmd_2
   3608              {
   3609                attrDataLen++;
   \   00001C   0E           INC     R6
   \   00001D   04           INC     A
   \   00001E   7001         JNZ     ??zclParseInWriteCmd_2
   \   000020   0F           INC     R7
   3610              }
   3611          
   3612              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000021   12....       LCALL   ?Subroutine129 & 0xFFFF
   3613            }
   \                     ??CrossCallReturnLabel_220:
   \   000024   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000027   40E1         JC      ??zclParseInWriteCmd_0
   3614          
   3615            // calculate the length of the response header
   3616            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   000029   75F005       MOV     B,#0x5
   \   00002C   E5..         MOV     A,?V7
   \   00002E   A4           MUL     AB
   \   00002F   04           INC     A
   \   000030   FE           MOV     R6,A
   3617          
   3618            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000031                ; Setup parameters for call to function osal_mem_alloc
   \   000031   25..         ADD     A,?V4
   \   000033   FA           MOV     R2,A
   \   000034   E4           CLR     A
   \   000035   35..         ADDC    A,?V5
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V10,R2
   \   00003D   8B..         MOV     ?V11,R3
   3619            if ( writeCmd != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V11
   \   000042   604C         JZ      ??zclParseInWriteCmd_3
   3620            {
   3621              uint8 i;
   3622              pBuf = pCmd->pData;
   \   000044   12....       LCALL   ?Subroutine59 & 0xFFFF
   3623              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   3624          
   3625              writeCmd->numAttr = numAttr;
   3626              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_95:
   \   000047   8040         SJMP    ??CrossCallReturnLabel_216
   3627              {
   3628                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_4:
   \   000049   12....       LCALL   ?Subroutine15 & 0xFFFF
   3629          
   3630                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3631                pBuf += 2;
   3632                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_2:
   \   00004C   5002         JNC     ??zclParseInWriteCmd_5
   \   00004E   05..         INC     ?V1
   3633          
   3634                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??zclParseInWriteCmd_5:
   \   000050                ; Setup parameters for call to function zclGetAttrDataLength
   \   000050   FA           MOV     R2,A
   \   000051   AB..         MOV     R3,?V1
   \   000053   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000056   8A..         MOV     ?V4,R2
   \   000058   8B..         MOV     ?V5,R3
   \   00005A   AE..         MOV     R6,?V4
   \   00005C   AF..         MOV     R7,?V5
   3635                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   00005E                ; Setup parameters for call to function osal_memcpy
   \   00005E   85....       MOV     ?V4,?V0
   \   000061   85....       MOV     ?V5,?V1
   \   000064   75..00       MOV     ?V6,#0x0
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V2
   \   000072   AB..         MOV     R3,?V3
   \   000074   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000077   7403         MOV     A,#0x3
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   3636                statusRec->attrData = dataPtr;
   \   00007C   12....       LCALL   ?Subroutine21 & 0xFFFF
   3637          
   3638                pBuf += attrDataLen; // move pass attribute data
   3639          
   3640                // advance attribute data pointer
   3641                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_10:
   \   00007F   5005         JNC     ??zclParseInWriteCmd_6
   3642                {
   3643                  attrDataLen++;
   \   000081   0E           INC     R6
   \   000082   04           INC     A
   \   000083   7001         JNZ     ??zclParseInWriteCmd_6
   \   000085   0F           INC     R7
   3644                }
   3645          
   3646                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_6:
   \   000086   12....       LCALL   ?Subroutine127 & 0xFFFF
   3647              }
   \                     ??CrossCallReturnLabel_216:
   \   000089   E5..         MOV     A,?V8
   \   00008B   C3           CLR     C
   \   00008C   95..         SUBB    A,?V7
   \   00008E   40B9         JC      ??zclParseInWriteCmd_4
   3648            }
   3649          
   3650            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_3:
   \   000090   02....       LJMP    ?Subroutine7 & 0xFFFF
   3651          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   E5..         MOV     A,?V4
   \   000002   2E           ADD     A,R6
   \   000003   F5..         MOV     ?V4,A
   \   000005   E5..         MOV     A,?V5
   \   000007   3F           ADDC    A,R7
   \   000008   F5..         MOV     ?V5,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   E5..         MOV     A,?V2
   \   000002   2E           ADD     A,R6
   \   000003   F5..         MOV     ?V2,A
   \   000005   E5..         MOV     A,?V3
   \   000007   3F           ADDC    A,R7
   \   000008   F5..         MOV     ?V3,A
   \   00000A   05..         INC     ?V8
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   8A..         MOV     ?V10,R2
   \   000002   8B..         MOV     ?V11,R3
   \   000004   AE..         MOV     R6,?V10
   \   000006   AF..         MOV     R7,?V11
   \   000008   E5..         MOV     A,?V0
   \   00000A   2A           ADD     A,R2
   \   00000B   F5..         MOV     ?V0,A
   \   00000D   E5..         MOV     A,?V1
   \   00000F   3F           ADDC    A,R7
   \   000010   F5..         MOV     ?V1,A
   \   000012   EE           MOV     A,R6
   \   000013   A2E0         MOV     C,0xE0 /* A   */.0
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   05..         INC     ?V7
   \   000002   85..82       MOV     DPL,?V0
   \   000005   85..83       MOV     DPH,?V1
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   E5..         MOV     A,?V0
   \   00000E   2403         ADD     A,#0x3
   \   000010   F5..         MOV     ?V0,A
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   8A..         MOV     ?V8,R2
   \   000002   8B..         MOV     ?V9,R3
   \   000004   EA           MOV     A,R2
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V2,A
   \   000009   E4           CLR     A
   \   00000A   35..         ADDC    A,?V9
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   F583         MOV     DPH,A
   \   000013   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000016   75..00       MOV     ?V7,#0x0
   \   000019   75..00       MOV     ?V4,#0x0
   \   00001C   75..00       MOV     ?V5,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000009   EA           MOV     A,R2
   \   00000A   2E           ADD     A,R6
   \   00000B   F5..         MOV     ?V2,A
   \   00000D   E4           CLR     A
   \   00000E   3B           ADDC    A,R3
   \   00000F   F5..         MOV     ?V3,A
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   E5..         MOV     A,?V7
   \   000017   F0           MOVX    @DPTR,A
   \   000018   75..00       MOV     ?V8,#0x0
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_527:
   \   00000A   12....       LCALL   ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_434:
   \   00000D   E5..         MOV     A,?V0
   \   00000F   98           SUBB    A,R0
   \   000010   E5..         MOV     A,?V1
   \   000012   99           SUBB    A,R1
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   85..82       MOV     DPL,?V12
   \   000003   85..83       MOV     DPH,?V13
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   E5..         MOV     A,?V2
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   E5..         MOV     A,?V3
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   E5..         MOV     A,?V0
   \   000012   2E           ADD     A,R6
   \   000013   F5..         MOV     ?V0,A
   \   000015   E5..         MOV     A,?V1
   \   000017   3F           ADDC    A,R7
   \   000018   F5..         MOV     ?V1,A
   \   00001A   EE           MOV     A,R6
   \   00001B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E5..         MOV     A,?V8
   \   000002   75F005       MOV     B,#0x5
   \   000005   12....       LCALL   ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000008   85..82       MOV     DPL,?V0
   \   00000B   85..83       MOV     DPH,?V1
   \   00000E   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000011   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000014   A3           INC     DPTR
   \   000015   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000018   F0           MOVX    @DPTR,A
   \   000019   E5..         MOV     A,?V0
   \   00001B   2403         ADD     A,#0x3
   \   00001D   F5..         MOV     ?V0,A
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine222_0
   \   000003                ; // Fall through to label ??Subroutine222_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine222_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000002                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000002   85..82       MOV     DPL,?V2
   \   000005   85..83       MOV     DPH,?V3
   \   000008   22           RET
   3652          
   3653          /*********************************************************************
   3654           * @fn      zclParseInWriteRspCmd
   3655           *
   3656           * @brief   Parse the "Profile" Write Response Commands
   3657           *
   3658           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3659           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3660           *
   3661           * @param   pCmd - pointer to incoming data to parse
   3662           *
   3663           * @return  pointer to the parsed command structure
   3664           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3665          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3666          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3667            zclWriteRspCmd_t *writeRspCmd;
   3668            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V2,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   12....       LCALL   ?Subroutine107 & 0xFFFF
   3669            uint8 i = 0;
   3670          
   3671            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_172:
   \   000014   8A82         MOV     DPL,R2
   \   000016   8B83         MOV     DPH,R3
   \   000018   A3           INC     DPTR
   \   000019   8582..       MOV     ?V0,DPL
   \   00001C   8583..       MOV     ?V1,DPH
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   2401         ADD     A,#0x1
   \   000022   FA           MOV     R2,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   3400         ADDC    A,#0x0
   \   000027   FB           MOV     R3,A
   \   000028   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3672            if ( writeRspCmd != NULL )
   \   00002B   EA           MOV     A,R2
   \   00002C   4B           ORL     A,R3
   \   00002D   6050         JZ      ??zclParseInWriteRspCmd_0
   3673            {
   3674              if ( pCmd->dataLen == 1 )
   \   00002F   85..82       MOV     DPL,?V0
   \   000032   85..83       MOV     DPH,?V1
   \   000035   E0           MOVX    A,@DPTR
   \   000036   6401         XRL     A,#0x1
   \   000038   7002         JNZ     ??zclParseInWriteRspCmd_1
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   00003C   702C         JNZ     ??zclParseInWriteRspCmd_2
   3675              {
   3676                // special case when all writes were successfull
   3677                writeRspCmd->attrList[i++].status = *pBuf;
   \   00003E   8E82         MOV     DPL,R6
   \   000040   8F83         MOV     DPH,R7
   \   000042   12....       LCALL   ?Subroutine101 & 0xFFFF
   3678              }
   \                     ??CrossCallReturnLabel_163:
   \   000045   F0           MOVX    @DPTR,A
   \   000046   75..01       MOV     ?V4,#0x1
   \   000049   802D         SJMP    ??zclParseInWriteRspCmd_3
   3679              else
   3680              {
   3681                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3682                {
   3683                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   00004B   E5..         MOV     A,?V4
   \   00004D   12....       LCALL   ?Subroutine18 & 0xFFFF
   3684                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_417:
   \   000050   F5..         MOV     ?V6,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FD           MOV     R5,A
   \   000055   E5..         MOV     A,?V6
   \   000057   8882         MOV     DPL,R0
   \   000059   8983         MOV     DPH,R1
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   ED           MOV     A,R5
   \   000060   F0           MOVX    @DPTR,A
   \   000061   05..         INC     ?V4
   3685                  pBuf += 2;
   \   000063   EE           MOV     A,R6
   \   000064   2402         ADD     A,#0x2
   \   000066   FE           MOV     R6,A
   \   000067   5001         JNC     ??zclParseInWriteRspCmd_2
   \   000069   0F           INC     R7
   3686                }
   \                     ??zclParseInWriteRspCmd_2:
   \   00006A   85..82       MOV     DPL,?V0
   \   00006D   85..83       MOV     DPH,?V1
   \   000070   12....       LCALL   ??Subroutine221_0 & 0xFFFF
   3687              }
   \                     ??CrossCallReturnLabel_523:
   \   000073   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_431:
   \   000076   40D3         JC      ??zclParseInWriteRspCmd_4
   3688          
   3689              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000078   8A82         MOV     DPL,R2
   \   00007A   8B83         MOV     DPH,R3
   \   00007C   E5..         MOV     A,?V4
   \   00007E   F0           MOVX    @DPTR,A
   3690            }
   3691          
   3692            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   00007F   02....       LJMP    ??Subroutine194_0 & 0xFFFF
   3693          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   75F003       MOV     B,#0x3
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007   EA           MOV     A,R2
   \   000008   28           ADD     A,R0
   \   000009   F8           MOV     R0,A
   \   00000A   EB           MOV     A,R3
   \   00000B   39           ADDC    A,R1
   \   00000C   F9           MOV     R1,A
   \   00000D   8E82         MOV     DPL,R6
   \   00000F   8F83         MOV     DPH,R7
   \   000011   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000014                REQUIRE ??Subroutine202_0
   \   000014                ; // Fall through to label ??Subroutine202_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine202_0:
   \   000000   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_421:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_477:
   \   000003   75..00       MOV     ?V4,#0x0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine221_0:
   \   000000   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_528:
   \   000003   22           RET
   3694          #endif // ZCL_WRITE
   3695          
   3696          #ifdef ZCL_REPORT
   3697          /*********************************************************************
   3698           * @fn      zclParseInConfigReportCmd
   3699           *
   3700           * @brief   Parse the "Profile" Configure Reporting Command
   3701           *
   3702           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3703           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3704           *
   3705           * @param   pCmd - pointer to incoming data to parse
   3706           *
   3707           * @return  pointer to the parsed command structure
   3708           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   AA..         MOV     R2,?V6
   \   000002   AB..         MOV     R3,?V7
   \   000004                REQUIRE ??Subroutine179_0
   \   000004                ; // Fall through to label ??Subroutine179_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine186_0
   \   000001                ; // Fall through to label ??Subroutine186_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine186_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine187_0
   \   000001                ; // Fall through to label ??Subroutine187_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine187_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine188_0
   \   000002                ; // Fall through to label ??Subroutine188_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3709          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   3710          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V4,R2
   \   000007   8B..         MOV     ?V5,R3
   3711            zclCfgReportCmd_t *cfgReportCmd;
   3712            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V5
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine76 & 0xFFFF
   3713            uint8 *dataPtr;
   3714            uint8 numAttr = 0;
   3715            uint8 dataType;
   3716            uint8 hdrLen;
   3717            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_119:
   \   000019   8007         SJMP    ??zclParseInConfigReportCmd_0
   3718            uint8 reportChangeLen; // length of Reportable Change field
   3719          
   3720            // Calculate the length of the Request command
   3721            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3722            {
   3723              uint8 direction;
   3724          
   3725              numAttr++;
   3726              direction = *pBuf++;
   3727              pBuf += 2; // move pass the attribute ID
   3728          
   3729              // Is there a Reportable Change field?
   3730              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3731              {
   3732                dataType = *pBuf++;
   3733                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3734          
   3735                // For attributes of 'discrete' data types this field is omitted
   3736                if ( zclAnalogDataType( dataType ) )
   3737                {
   3738                  reportChangeLen = zclGetDataTypeLength( dataType );
   3739                  pBuf += reportChangeLen;
   3740          
   3741                  // add padding if needed
   3742                  if ( PADDING_NEEDED( reportChangeLen ) )
   3743                  {
   3744                    reportChangeLen++;
   3745                  }
   3746          
   3747                  dataLen += reportChangeLen;
   3748                }
   3749                else
   3750                {
   3751                  pBuf++; // move past reportable change field
   3752                }
   3753              }
   3754              else
   3755              {
   3756                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_1:
   \   00001B   EE           MOV     A,R6
   \   00001C   2405         ADD     A,#0x5
   \   00001E   FE           MOV     R6,A
   \   00001F   5001         JNC     ??zclParseInConfigReportCmd_0
   \   000021   0F           INC     R7
   3757              }
   \                     ??zclParseInConfigReportCmd_0:
   \   000022   85..82       MOV     DPL,?V4
   \   000025   85..83       MOV     DPH,?V5
   \   000028   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_432:
   \   00002B   5039         JNC     ??zclParseInConfigReportCmd_2
   \   00002D   05..         INC     ?V2
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E0           MOVX    A,@DPTR
   \   000034   70E5         JNZ     ??zclParseInConfigReportCmd_1
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F5..         MOV     ?V3,A
   \   00003C   EE           MOV     A,R6
   \   00003D   2408         ADD     A,#0x8
   \   00003F   FE           MOV     R6,A
   \   000040   5001         JNC     ??zclParseInConfigReportCmd_3
   \   000042   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_3:
   \   000043                ; Setup parameters for call to function zclAnalogDataType
   \   000043   A9..         MOV     R1,?V3
   \   000045   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000048   E9           MOV     A,R1
   \   000049   6010         JZ      ??zclParseInConfigReportCmd_4
   \   00004B                ; Setup parameters for call to function zclGetDataTypeLength
   \   00004B   A9..         MOV     R1,?V3
   \   00004D   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000050   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000053   5001         JNC     ??zclParseInConfigReportCmd_5
   \   000055   0A           INC     R2
   \                     ??zclParseInConfigReportCmd_5:
   \   000056   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000059   80C7         SJMP    ??zclParseInConfigReportCmd_0
   \                     ??zclParseInConfigReportCmd_4:
   \   00005B   8E82         MOV     DPL,R6
   \   00005D   8F83         MOV     DPH,R7
   \   00005F   A3           INC     DPTR
   \   000060   AE82         MOV     R6,DPL
   \   000062   AF83         MOV     R7,DPH
   \   000064   80BC         SJMP    ??zclParseInConfigReportCmd_0
   3758            } // while loop
   3759          
   3760            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_2:
   \   000066   75F00C       MOV     B,#0xc
   \   000069   E5..         MOV     A,?V2
   \   00006B   A4           MUL     AB
   \   00006C   04           INC     A
   \   00006D   F5..         MOV     ?V3,A
   3761          
   3762            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   00006F                ; Setup parameters for call to function osal_mem_alloc
   \   00006F   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000072   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000075   8A..         MOV     ?V6,R2
   \   000077   8B..         MOV     ?V7,R3
   3763            if ( cfgReportCmd != NULL )
   \   000079   EA           MOV     A,R2
   \   00007A   45..         ORL     A,?V7
   \   00007C   7003         JNZ     $+5
   \   00007E   02....       LJMP    ??zclParseInConfigReportCmd_6 & 0xFFFF
   3764            {
   3765              uint8 i;
   3766              pBuf = pCmd->pData;
   \   000081   12....       LCALL   ?Subroutine108 & 0xFFFF
   3767              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_425:
   \   000084   A8..         MOV     R0,?V3
   \   000086   EA           MOV     A,R2
   \   000087   28           ADD     A,R0
   \   000088   F5..         MOV     ?V4,A
   \   00008A   E4           CLR     A
   \   00008B   3B           ADDC    A,R3
   \   00008C   F5..         MOV     ?V5,A
   3768          
   3769              cfgReportCmd->numAttr = numAttr;
   \   00008E   8A82         MOV     DPL,R2
   \   000090   8B83         MOV     DPH,R3
   \   000092   E5..         MOV     A,?V2
   \   000094   F0           MOVX    @DPTR,A
   3770              for ( i = 0; i < numAttr; i++ )
   \   000095   75..00       MOV     ?V3,#0x0
   \   000098   8008         SJMP    ??zclParseInConfigReportCmd_7
   3771              {
   3772                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3773          
   3774                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3775          
   3776                reportRec->direction = *pBuf++;
   3777                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3778                pBuf += 2;
   3779                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3780                {
   3781                  // Attribute to be reported
   3782                  reportRec->dataType = *pBuf++;
   3783                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3784                  pBuf += 2;
   3785                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3786                  pBuf += 2;
   3787          
   3788                  // For attributes of 'discrete' data types this field is omitted
   3789                  if ( zclAnalogDataType( reportRec->dataType ) )
   3790                  {
   3791                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3792                    reportRec->reportableChange = dataPtr;
   3793          
   3794                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3795                    pBuf += reportChangeLen;
   3796          
   3797                    // advance attribute data pointer
   3798                    if ( PADDING_NEEDED( reportChangeLen ) )
   3799                    {
   3800                      reportChangeLen++;
   3801                    }
   3802          
   3803                    dataPtr += reportChangeLen;
   3804                  }
   3805                }
   3806                else
   3807                {
   3808                  // Attribute reports to be received
   3809                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_8:
   \   00009A   12....       LCALL   ?Subroutine74 & 0xFFFF
   3810                  pBuf += 2;
   3811                }
   \                     ??CrossCallReturnLabel_428:
   \   00009D   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0000A0   05..         INC     ?V3
   \                     ??zclParseInConfigReportCmd_7:
   \   0000A2   E5..         MOV     A,?V3
   \   0000A4   C3           CLR     C
   \   0000A5   95..         SUBB    A,?V2
   \   0000A7   4003         JC      $+5
   \   0000A9   02....       LJMP    ??zclParseInConfigReportCmd_6 & 0xFFFF
   \   0000AC   E5..         MOV     A,?V3
   \   0000AE   75F00C       MOV     B,#0xc
   \   0000B1   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   0000B4                ; Setup parameters for call to function osal_memset
   \   0000B4   7C0C         MOV     R4,#0xc
   \   0000B6   7D00         MOV     R5,#0x0
   \   0000B8   7900         MOV     R1,#0x0
   \   0000BA   AA..         MOV     R2,?V0
   \   0000BC   AB..         MOV     R3,?V1
   \   0000BE   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   \   0000C1   8E82         MOV     DPL,R6
   \   0000C3   8F83         MOV     DPH,R7
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   FB           MOV     R3,A
   \   0000C7   85..82       MOV     DPL,?V0
   \   0000CA   85..83       MOV     DPH,?V1
   \   0000CD   12....       LCALL   ??Subroutine202_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_419:
   \   0000D0   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_450:
   \   0000D3   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_354:
   \   0000D6   5001         JNC     ??zclParseInConfigReportCmd_9
   \   0000D8   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_9:
   \   0000D9   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   0000DC   70BC         JNZ     ??zclParseInConfigReportCmd_8
   \   0000DE   E5..         MOV     A,?V0
   \   0000E0   2403         ADD     A,#0x3
   \   0000E2   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   0000E5   0E           INC     R6
   \   0000E6   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0000E9   12....       LCALL   ??Subroutine187_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_351:
   \   0000EC   5001         JNC     ??zclParseInConfigReportCmd_10
   \   0000EE   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_10:
   \   0000EF   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_451:
   \   0000F2   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_348:
   \   0000F5   5001         JNC     ??zclParseInConfigReportCmd_11
   \   0000F7   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_11:
   \   0000F8                ; Setup parameters for call to function zclAnalogDataType
   \   0000F8   EA           MOV     A,R2
   \   0000F9   F9           MOV     R1,A
   \   0000FA   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   0000FD   E9           MOV     A,R1
   \   0000FE   60A0         JZ      ??CrossCallReturnLabel_56
   \   000100                ; Setup parameters for call to function zcl_BuildAnalogData
   \   000100   EE           MOV     A,R6
   \   000101   FC           MOV     R4,A
   \   000102   EF           MOV     A,R7
   \   000103   FD           MOV     R5,A
   \   000104   AA..         MOV     R2,?V4
   \   000106   AB..         MOV     R3,?V5
   \   000108   85..82       MOV     DPL,?V8
   \   00010B   85..83       MOV     DPH,?V9
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   F9           MOV     R1,A
   \   000110   12....       LCALL   `??zcl_BuildAnalogData::?relay`; Banked call to: zcl_BuildAnalogData
   \   000113   85..82       MOV     DPL,?V0
   \   000116   85..83       MOV     DPH,?V1
   \   000119   A3           INC     DPTR
   \   00011A   A3           INC     DPTR
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   A3           INC     DPTR
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   E5..         MOV     A,?V4
   \   000125   F0           MOVX    @DPTR,A
   \   000126   A3           INC     DPTR
   \   000127   E5..         MOV     A,?V5
   \   000129   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   00012C   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00012F   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000132   5001         JNC     ??zclParseInConfigReportCmd_12
   \   000134   0A           INC     R2
   \                     ??zclParseInConfigReportCmd_12:
   \   000135   E5..         MOV     A,?V4
   \   000137   2A           ADD     A,R2
   \   000138   F5..         MOV     ?V4,A
   \   00013A   E4           CLR     A
   \   00013B   35..         ADDC    A,?V5
   \   00013D   F5..         MOV     ?V5,A
   \   00013F   02....       LJMP    ??CrossCallReturnLabel_56 & 0xFFFF
   3812              } // while loop
   3813            }
   3814          
   3815            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_6:
   \   000142   02....       LJMP    ?Subroutine6 & 0xFFFF
   3816          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006                REQUIRE ??Subroutine203_0
   \   000006                ; // Fall through to label ??Subroutine203_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004                REQUIRE ??Subroutine204_0
   \   000004                ; // Fall through to label ??Subroutine204_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_505:
   \   000004   85..82       MOV     DPL,?V0
   \   000007   85..83       MOV     DPH,?V1
   \   00000A                REQUIRE ??Subroutine205_0
   \   00000A                ; // Fall through to label ??Subroutine205_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   F5..         MOV     ?V8,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V1
   \   000005   F5..         MOV     ?V9,A
   \   000007   EA           MOV     A,R2
   \   000008   85..82       MOV     DPL,?V8
   \   00000B   85..83       MOV     DPH,?V9
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   E5..         MOV     A,?V6
   \   000002   2A           ADD     A,R2
   \   000003   F5..         MOV     ?V6,A
   \   000005   E4           CLR     A
   \   000006   35..         ADDC    A,?V7
   \   000008   F5..         MOV     ?V7,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V6
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V7
   \   00000B   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   00000E   8582..       MOV     ?V0,DPL
   \   000011   8583..       MOV     ?V1,DPH
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   E9           MOV     A,R1
   \   000001   FA           MOV     R2,A
   \   000002   EE           MOV     A,R6
   \   000003   29           ADD     A,R1
   \   000004   FE           MOV     R6,A
   \   000005   E4           CLR     A
   \   000006   3F           ADDC    A,R7
   \   000007   FF           MOV     R7,A
   \   000008   EA           MOV     A,R2
   \   000009   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   2402         ADD     A,#0x2
   \   000002   FC           MOV     R4,A
   \   000003   E4           CLR     A
   \   000004   3F           ADDC    A,R7
   \   000005   FD           MOV     R5,A
   \   000006   8E82         MOV     DPL,R6
   \   000008   8F83         MOV     DPH,R7
   \   00000A   A3           INC     DPTR
   \   00000B   A882         MOV     R0,DPL
   \   00000D   A983         MOV     R1,DPH
   \   00000F   8E82         MOV     DPL,R6
   \   000011   8F83         MOV     DPH,R7
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FA           MOV     R2,A
   \   000015   EB           MOV     A,R3
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E9           MOV     A,R1
   \   000001   FF           MOV     R7,A
   \   000002   8E82         MOV     DPL,R6
   \   000004   8F83         MOV     DPH,R7
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V10,A
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   E5..         MOV     A,?V10
   \   000011   85..82       MOV     DPL,?V0
   \   000014   85..83       MOV     DPH,?V1
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005                REQUIRE ??Subroutine209_0
   \   000005                ; // Fall through to label ??Subroutine209_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine209_0:
   \   000000   FC           MOV     R4,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   85..82       MOV     DPL,?V0
   \   000008   85..83       MOV     DPH,?V1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   E9           MOV     A,R1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   0E           INC     R6
   \   00000D   0E           INC     R6
   \   00000E   ED           MOV     A,R5
   \   00000F   FF           MOV     R7,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001   85..82       MOV     DPL,?V8
   \   000004   85..83       MOV     DPH,?V9
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET
   3817          
   3818          /*********************************************************************
   3819           * @fn      zclParseInConfigReportRspCmd
   3820           *
   3821           * @brief   Parse the "Profile" Configure Reporting Response Command
   3822           *
   3823           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3824           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3825           *
   3826           * @param   pCmd - pointer to incoming data to parse
   3827           *
   3828           * @return  pointer to the parsed command structure
   3829           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3830          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportRspCmd:
   3831          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3832            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3833            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine86 & 0xFFFF
   3834            uint8 numAttr;
   3835          
   3836            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   \                     ??CrossCallReturnLabel_132:
   \   000008   F5..         MOV     ?V0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F5..         MOV     ?V1,A
   \   00000E   7402         MOV     A,#0x2
   \   000010   78..         MOV     R0,#?V0
   \   000012   12....       LCALL   ?US_SHR
   \   000015   E5..         MOV     A,?V0
   \   000017   F5..         MOV     ?V0,A
   3837          
   3838            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3839                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   F5..         MOV     ?V2,A
   \   00001B   75..00       MOV     ?V3,#0x0
   \   00001E   7402         MOV     A,#0x2
   \   000020   78..         MOV     R0,#?V2
   \   000022   12....       LCALL   ?S_SHL
   \   000025   E5..         MOV     A,?V2
   \   000027   2401         ADD     A,#0x1
   \   000029   FA           MOV     R2,A
   \   00002A   E4           CLR     A
   \   00002B   35..         ADDC    A,?V3
   \   00002D   FB           MOV     R3,A
   \   00002E   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3840            if ( cfgReportRspCmd != NULL )
   \   000031   EA           MOV     A,R2
   \   000032   4B           ORL     A,R3
   \   000033   6051         JZ      ??zclParseInConfigReportRspCmd_0
   3841            {
   3842              uint8 i;
   3843              cfgReportRspCmd->numAttr = numAttr;
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   E5..         MOV     A,?V0
   \   00003B   F0           MOVX    @DPTR,A
   3844              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003C   75..00       MOV     ?V2,#0x0
   \   00003F   803C         SJMP    ??zclParseInConfigReportRspCmd_1
   3845              {
   3846                cfgReportRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInConfigReportRspCmd_2:
   \   000041   85....       MOV     ?V0,?V2
   \   000044   75..00       MOV     ?V1,#0x0
   \   000047   7402         MOV     A,#0x2
   \   000049   78..         MOV     R0,#?V0
   \   00004B   12....       LCALL   ?S_SHL
   \   00004E   EA           MOV     A,R2
   \   00004F   25..         ADD     A,?V0
   \   000051   F8           MOV     R0,A
   \   000052   EB           MOV     A,R3
   \   000053   35..         ADDC    A,?V1
   \   000055   F9           MOV     R1,A
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   00005D   A3           INC     DPTR
   \   00005E   12....       LCALL   ??Subroutine210_0 & 0xFFFF
   3847                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   \                     ??CrossCallReturnLabel_457:
   \   000061   8882         MOV     DPL,R0
   \   000063   8983         MOV     DPH,R1
   \   000065   A3           INC     DPTR
   \   000066   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_441:
   \   000069   5001         JNC     ??zclParseInConfigReportRspCmd_3
   \   00006B   0F           INC     R7
   3848                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportRspCmd_3:
   \   00006C   8E82         MOV     DPL,R6
   \   00006E   8F83         MOV     DPH,R7
   \   000070   E0           MOVX    A,@DPTR
   \   000071   12....       LCALL   ?Subroutine111 & 0xFFFF
   3849                pBuf += 2;
   3850              }
   \                     ??CrossCallReturnLabel_178:
   \   000074   A3           INC     DPTR
   \   000075   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_436:
   \   000078   5001         JNC     ??zclParseInConfigReportRspCmd_4
   \   00007A   0F           INC     R7
   \                     ??zclParseInConfigReportRspCmd_4:
   \   00007B   05..         INC     ?V2
   \                     ??zclParseInConfigReportRspCmd_1:
   \   00007D   8A82         MOV     DPL,R2
   \   00007F   8B83         MOV     DPH,R3
   \   000081   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   3851            }
   \                     ??CrossCallReturnLabel_445:
   \   000084   40BB         JC      ??zclParseInConfigReportRspCmd_2
   3852          
   3853            return ( (void *)cfgReportRspCmd );
   \                     ??zclParseInConfigReportRspCmd_0:
   \   000086   02....       LJMP    ?Subroutine1 & 0xFFFF
   3854          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine206_0
   \   000001                ; // Fall through to label ??Subroutine206_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine207_0
   \   000002                ; // Fall through to label ??Subroutine207_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   F5..         MOV     ?V0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   E5..         MOV     A,?V0
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_475:
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   22           RET
   3855          
   3856          /*********************************************************************
   3857           * @fn      zclParseInReadReportCfgCmd
   3858           *
   3859           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3860           *
   3861           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3862           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3863           *
   3864           * @param   pCmd - pointer to incoming data to parse
   3865           *
   3866           * @return  pointer to the parsed command structure
   3867           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3868          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   3869          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3870            zclReadReportCfgCmd_t *readReportCfgCmd;
   3871            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine86 & 0xFFFF
   3872            uint8 numAttr;
   3873          
   3874            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \                     ??CrossCallReturnLabel_133:
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   7A03         MOV     R2,#0x3
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   12....       LCALL   ?US_DIV_MOD
   \   000013   E8           MOV     A,R0
   \   000014   F5..         MOV     ?V0,A
   3875          
   3876            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3877                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   12....       LCALL   ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_530:
   \   000019   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3878            if ( readReportCfgCmd != NULL )
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   6025         JZ      ??zclParseInReadReportCfgCmd_0
   3879            {
   3880              uint8 i;
   3881              readReportCfgCmd->numAttr = numAttr;
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   E5..         MOV     A,?V0
   \   000026   F0           MOVX    @DPTR,A
   3882              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   \   000027   75..00       MOV     ?V2,#0x0
   \   00002A   8010         SJMP    ??zclParseInReadReportCfgCmd_1
   3883              {
   3884                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_2:
   \   00002C   E5..         MOV     A,?V2
   \   00002E   12....       LCALL   ?Subroutine18 & 0xFFFF
   3885                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3886                pBuf += 2;
   3887              }
   \                     ??CrossCallReturnLabel_418:
   \   000031   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   000034   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_437:
   \   000037   5001         JNC     ??zclParseInReadReportCfgCmd_3
   \   000039   0F           INC     R7
   \                     ??zclParseInReadReportCfgCmd_3:
   \   00003A   05..         INC     ?V2
   \                     ??zclParseInReadReportCfgCmd_1:
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   3888            }
   \                     ??CrossCallReturnLabel_446:
   \   000043   40E7         JC      ??zclParseInReadReportCfgCmd_2
   3889          
   3890            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   000045   02....       LJMP    ?Subroutine1 & 0xFFFF
   3891          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine166:
   \   000000   75F003       MOV     B,#0x3
   \   000003                REQUIRE ??Subroutine223_0
   \   000003                ; // Fall through to label ??Subroutine223_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine223_0:
   \   000000   A4           MUL     AB
   \   000001   A9F0         MOV     R1,B
   \   000003   2401         ADD     A,#0x1
   \   000005   FA           MOV     R2,A
   \   000006   E4           CLR     A
   \   000007   39           ADDC    A,R1
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3892          
   3893          /*********************************************************************
   3894           * @fn      zclParseInReadReportCfgRspCmd
   3895           *
   3896           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3897           *
   3898           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3899           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3900           *
   3901           * @param   pCmd - pointer to incoming data to parse
   3902           *
   3903           * @return  pointer to the parsed command structure
   3904           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3905          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgRspCmd:
   3906          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   3907            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3908            uint8 reportChangeLen;
   3909            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V3
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine107 & 0xFFFF
   3910            uint8 *dataPtr;
   3911            uint8 numAttr = 0;
   3912            uint8 hdrLen;
   3913            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_173:
   \   000019   75..00       MOV     ?V6,#0x0
   \   00001C   75..00       MOV     ?V7,#0x0
   \   00001F   8007         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3914          
   3915            // Calculate the length of the response command
   3916            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3917            {
   3918              uint8 status;
   3919              uint8 direction;
   3920          
   3921              numAttr++;
   3922              status = *pBuf++;
   3923              direction = *pBuf++;
   3924              pBuf += 2; // move pass the attribute ID
   3925          
   3926              if ( status == ZCL_STATUS_SUCCESS )
   3927              {
   3928                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3929                {
   3930                  uint8 dataType = *pBuf++;
   3931                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3932          
   3933                  // For attributes of 'discrete' data types this field is omitted
   3934                  if ( zclAnalogDataType( dataType ) )
   3935                  {
   3936                    reportChangeLen = zclGetDataTypeLength( dataType );
   3937                    pBuf += reportChangeLen;
   3938          
   3939                    // add padding if needed
   3940                    if ( PADDING_NEEDED( reportChangeLen ) )
   3941                    {
   3942                      reportChangeLen++;
   3943                    }
   3944          
   3945                    dataLen += reportChangeLen;
   3946                  }
   3947                }
   3948                else
   3949                {
   3950                  pBuf += 2; // move pass the Timeout field
   \                     ??zclParseInReadReportCfgRspCmd_1:
   \   000021   EE           MOV     A,R6
   \   000022   2402         ADD     A,#0x2
   \   000024   FE           MOV     R6,A
   \   000025   5001         JNC     ??zclParseInReadReportCfgRspCmd_0
   \   000027   0F           INC     R7
   3951                }
   \                     ??zclParseInReadReportCfgRspCmd_0:
   \   000028   85..82       MOV     DPL,?V2
   \   00002B   85..83       MOV     DPH,?V3
   \   00002E   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_433:
   \   000031   503E         JNC     ??zclParseInReadReportCfgRspCmd_2
   \   000033   05..         INC     ?V4
   \   000035   8E82         MOV     DPL,R6
   \   000037   8F83         MOV     DPH,R7
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F9           MOV     R1,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   EE           MOV     A,R6
   \   00003F   2404         ADD     A,#0x4
   \   000041   FE           MOV     R6,A
   \   000042   5001         JNC     ??zclParseInReadReportCfgRspCmd_3
   \   000044   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_3:
   \   000045   E9           MOV     A,R1
   \   000046   70E0         JNZ     ??zclParseInReadReportCfgRspCmd_0
   \   000048   E8           MOV     A,R0
   \   000049   70D6         JNZ     ??zclParseInReadReportCfgRspCmd_1
   \   00004B   8E82         MOV     DPL,R6
   \   00004D   8F83         MOV     DPH,R7
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F5..         MOV     ?V5,A
   \   000052   EE           MOV     A,R6
   \   000053   2405         ADD     A,#0x5
   \   000055   FE           MOV     R6,A
   \   000056   5001         JNC     ??zclParseInReadReportCfgRspCmd_4
   \   000058   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_4:
   \   000059                ; Setup parameters for call to function zclAnalogDataType
   \   000059   A9..         MOV     R1,?V5
   \   00005B   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00005E   E9           MOV     A,R1
   \   00005F   60C7         JZ      ??zclParseInReadReportCfgRspCmd_0
   \   000061                ; Setup parameters for call to function zclGetDataTypeLength
   \   000061   A9..         MOV     R1,?V5
   \   000063   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000066   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000069   5001         JNC     ??zclParseInReadReportCfgRspCmd_5
   \   00006B   0A           INC     R2
   \                     ??zclParseInReadReportCfgRspCmd_5:
   \   00006C   12....       LCALL   ?Subroutine123 & 0xFFFF
   3952              }
   3953            } // while loop
   \                     ??CrossCallReturnLabel_208:
   \   00006F   80B7         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3954          
   3955            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??zclParseInReadReportCfgRspCmd_2:
   \   000071   75F00D       MOV     B,#0xd
   \   000074   E5..         MOV     A,?V4
   \   000076   A4           MUL     AB
   \   000077   04           INC     A
   \   000078   F5..         MOV     ?V2,A
   3956          
   3957            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   00007A                ; Setup parameters for call to function osal_mem_alloc
   \   00007A   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   00007D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000080   8A..         MOV     ?V6,R2
   \   000082   8B..         MOV     ?V7,R3
   3958            if ( readReportCfgRspCmd != NULL )
   \   000084   EA           MOV     A,R2
   \   000085   45..         ORL     A,?V7
   \   000087   7003         JNZ     $+5
   \   000089   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   3959            {
   3960              uint8 i;
   3961              pBuf = pCmd->pData;
   \   00008C   12....       LCALL   ?Subroutine108 & 0xFFFF
   3962              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_426:
   \   00008F   A8..         MOV     R0,?V2
   \   000091   EA           MOV     A,R2
   \   000092   28           ADD     A,R0
   \   000093   F5..         MOV     ?V2,A
   \   000095   E4           CLR     A
   \   000096   3B           ADDC    A,R3
   \   000097   F5..         MOV     ?V3,A
   3963          
   3964              readReportCfgRspCmd->numAttr = numAttr;
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V4
   \   00009F   F0           MOVX    @DPTR,A
   3965              for ( i = 0; i < numAttr; i++ )
   \   0000A0   75..00       MOV     ?V5,#0x0
   \   0000A3   8009         SJMP    ??zclParseInReadReportCfgRspCmd_7
   3966              {
   3967                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3968          
   3969                reportRspRec->status = *pBuf++;
   3970                reportRspRec->direction = *pBuf++;
   3971                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3972                pBuf += 2;
   3973          
   3974                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3975                {
   3976                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3977                  {
   3978                    reportRspRec->dataType = *pBuf++;
   3979                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3980                    pBuf += 2;
   3981                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3982                    pBuf += 2;
   3983          
   3984                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3985                    {
   3986                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3987                      reportRspRec->reportableChange = dataPtr;
   3988          
   3989                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3990                      pBuf += reportChangeLen;
   3991          
   3992                      // advance attribute data pointer
   3993                      if ( PADDING_NEEDED( reportChangeLen ) )
   3994                      {
   3995                        reportChangeLen++;
   3996                      }
   3997          
   3998                      dataPtr += reportChangeLen;
   3999                    }
   4000                  }
   4001                  else
   4002                  {
   4003                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadReportCfgRspCmd_8:
   \   0000A5   12....       LCALL   ?Subroutine74 & 0xFFFF
   4004                    pBuf += 2;
   4005                  }
   \                     ??CrossCallReturnLabel_429:
   \   0000A8   A3           INC     DPTR
   \   0000A9   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000AC   05..         INC     ?V5
   \                     ??zclParseInReadReportCfgRspCmd_7:
   \   0000AE   E5..         MOV     A,?V5
   \   0000B0   C3           CLR     C
   \   0000B1   95..         SUBB    A,?V4
   \   0000B3   4003         JC      $+5
   \   0000B5   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   \   0000B8   E5..         MOV     A,?V5
   \   0000BA   75F00D       MOV     B,#0xd
   \   0000BD   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   0000C0   8E82         MOV     DPL,R6
   \   0000C2   8F83         MOV     DPH,R7
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   FA           MOV     R2,A
   \   0000C6   85..82       MOV     DPL,?V0
   \   0000C9   85..83       MOV     DPH,?V1
   \   0000CC   12....       LCALL   ??Subroutine210_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_458:
   \   0000CF   FB           MOV     R3,A
   \   0000D0   85..82       MOV     DPL,?V0
   \   0000D3   85..83       MOV     DPH,?V1
   \   0000D6   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_442:
   \   0000D9   5001         JNC     ??zclParseInReadReportCfgRspCmd_9
   \   0000DB   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_9:
   \   0000DC   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_452:
   \   0000DF   12....       LCALL   ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_353:
   \   0000E2   5001         JNC     ??zclParseInReadReportCfgRspCmd_10
   \   0000E4   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_10:
   \   0000E5   EA           MOV     A,R2
   \   0000E6   70C4         JNZ     ??CrossCallReturnLabel_57
   \   0000E8   EE           MOV     A,R6
   \   0000E9   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   0000EC   70B7         JNZ     ??zclParseInReadReportCfgRspCmd_8
   \   0000EE   E5..         MOV     A,?V0
   \   0000F0   2404         ADD     A,#0x4
   \   0000F2   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   0000F5   E8           MOV     A,R0
   \   0000F6   FE           MOV     R6,A
   \   0000F7   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   0000FA   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   0000FD   5001         JNC     ??zclParseInReadReportCfgRspCmd_11
   \   0000FF   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_11:
   \   000100   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_453:
   \   000103   A3           INC     DPTR
   \   000104   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   000107   5001         JNC     ??zclParseInReadReportCfgRspCmd_12
   \   000109   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_12:
   \   00010A                ; Setup parameters for call to function zclAnalogDataType
   \   00010A   EA           MOV     A,R2
   \   00010B   F9           MOV     R1,A
   \   00010C   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00010F   E9           MOV     A,R1
   \   000110   609A         JZ      ??CrossCallReturnLabel_57
   \   000112                ; Setup parameters for call to function zcl_BuildAnalogData
   \   000112   EE           MOV     A,R6
   \   000113   FC           MOV     R4,A
   \   000114   EF           MOV     A,R7
   \   000115   FD           MOV     R5,A
   \   000116   AA..         MOV     R2,?V2
   \   000118   AB..         MOV     R3,?V3
   \   00011A   85..82       MOV     DPL,?V8
   \   00011D   85..83       MOV     DPH,?V9
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   12....       LCALL   `??zcl_BuildAnalogData::?relay`; Banked call to: zcl_BuildAnalogData
   \   000125   E5..         MOV     A,?V0
   \   000127   240B         ADD     A,#0xb
   \   000129   F582         MOV     DPL,A
   \   00012B   E4           CLR     A
   \   00012C   35..         ADDC    A,?V1
   \   00012E   F583         MOV     DPH,A
   \   000130   E5..         MOV     A,?V2
   \   000132   F0           MOVX    @DPTR,A
   \   000133   A3           INC     DPTR
   \   000134   E5..         MOV     A,?V3
   \   000136   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000139   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00013C   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   00013F   5001         JNC     ??zclParseInReadReportCfgRspCmd_13
   \   000141   0A           INC     R2
   \                     ??zclParseInReadReportCfgRspCmd_13:
   \   000142   E5..         MOV     A,?V2
   \   000144   2A           ADD     A,R2
   \   000145   F5..         MOV     ?V2,A
   \   000147   E4           CLR     A
   \   000148   35..         ADDC    A,?V3
   \   00014A   F5..         MOV     ?V3,A
   \   00014C   02....       LJMP    ??CrossCallReturnLabel_57 & 0xFFFF
   4006                }
   4007              }
   4008            }
   4009          
   4010            return ( (void *)readReportCfgRspCmd );
   \                     ??zclParseInReadReportCfgRspCmd_6:
   \   00014F   02....       LJMP    ?Subroutine6 & 0xFFFF
   4011          }
   4012          
   4013          /*********************************************************************
   4014           * @fn      zclParseInReportCmd
   4015           *
   4016           * @brief   Parse the "Profile" Report Command
   4017           *
   4018           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4019           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4020           *
   4021           * @param   pCmd - pointer to incoming data to parse
   4022           *
   4023           * @return  pointer to the parsed command structure
   4024           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4025          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReportCmd:
   4026          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine73 & 0xFFFF
   4027            zclReportCmd_t *reportCmd;
   4028            uint8 *pBuf = pCmd->pData;
   4029            uint16 attrDataLen;
   4030            uint8 *dataPtr;
   4031            uint8 numAttr = 0;
   4032            uint8 hdrLen;
   4033            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_115:
   \   000008   801A         SJMP    ??CrossCallReturnLabel_221
   4034          
   4035            // find out the number of attributes and the length of attribute data
   4036            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4037            {
   4038              uint8 dataType;
   4039          
   4040              numAttr++;
   \                     ??zclParseInReportCmd_0:
   \   00000A   12....       LCALL   ?Subroutine105 & 0xFFFF
   4041              pBuf += 2; // move pass attribute id
   4042          
   4043              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_169:
   \   00000D   5002         JNC     ??zclParseInReportCmd_1
   \   00000F   05..         INC     ?V1
   4044          
   4045              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??zclParseInReportCmd_1:
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011   FA           MOV     R2,A
   \   000012   AB..         MOV     R3,?V1
   \   000014   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000017   12....       LCALL   ?Subroutine122 & 0xFFFF
   4046              pBuf += attrDataLen; // move pass attribute data
   4047          
   4048              // add padding if needed
   4049              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_206:
   \   00001A   5005         JNC     ??zclParseInReportCmd_2
   4050              {
   4051                attrDataLen++;
   \   00001C   0E           INC     R6
   \   00001D   04           INC     A
   \   00001E   7001         JNZ     ??zclParseInReportCmd_2
   \   000020   0F           INC     R7
   4052              }
   4053          
   4054              dataLen += attrDataLen;
   \                     ??zclParseInReportCmd_2:
   \   000021   12....       LCALL   ?Subroutine129 & 0xFFFF
   4055            }
   \                     ??CrossCallReturnLabel_221:
   \   000024   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000027   40E1         JC      ??zclParseInReportCmd_0
   4056          
   4057            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   \   000029   75F005       MOV     B,#0x5
   \   00002C   E5..         MOV     A,?V7
   \   00002E   A4           MUL     AB
   \   00002F   04           INC     A
   \   000030   FE           MOV     R6,A
   4058          
   4059            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000031                ; Setup parameters for call to function osal_mem_alloc
   \   000031   25..         ADD     A,?V4
   \   000033   FA           MOV     R2,A
   \   000034   E4           CLR     A
   \   000035   35..         ADDC    A,?V5
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V10,R2
   \   00003D   8B..         MOV     ?V11,R3
   4060            if (reportCmd != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V11
   \   000042   604C         JZ      ??zclParseInReportCmd_3
   4061            {
   4062              uint8 i;
   4063              pBuf = pCmd->pData;
   \   000044   12....       LCALL   ?Subroutine59 & 0xFFFF
   4064              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   4065          
   4066              reportCmd->numAttr = numAttr;
   4067              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_96:
   \   000047   8040         SJMP    ??CrossCallReturnLabel_217
   4068              {
   4069                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zclParseInReportCmd_4:
   \   000049   12....       LCALL   ?Subroutine15 & 0xFFFF
   4070          
   4071                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4072                pBuf += 2;
   4073                reportRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_3:
   \   00004C   5002         JNC     ??zclParseInReportCmd_5
   \   00004E   05..         INC     ?V1
   4074          
   4075                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   \                     ??zclParseInReportCmd_5:
   \   000050                ; Setup parameters for call to function zclGetAttrDataLength
   \   000050   FA           MOV     R2,A
   \   000051   AB..         MOV     R3,?V1
   \   000053   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000056   8A..         MOV     ?V4,R2
   \   000058   8B..         MOV     ?V5,R3
   \   00005A   AE..         MOV     R6,?V4
   \   00005C   AF..         MOV     R7,?V5
   4076                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   \   00005E                ; Setup parameters for call to function osal_memcpy
   \   00005E   85....       MOV     ?V4,?V0
   \   000061   85....       MOV     ?V5,?V1
   \   000064   75..00       MOV     ?V6,#0x0
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V2
   \   000072   AB..         MOV     R3,?V3
   \   000074   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000077   7403         MOV     A,#0x3
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   4077                reportRec->attrData = dataPtr;
   \   00007C   12....       LCALL   ?Subroutine21 & 0xFFFF
   4078          
   4079                pBuf += attrDataLen; // move pass attribute data
   4080          
   4081                // advance attribute data pointer
   4082                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_11:
   \   00007F   5005         JNC     ??zclParseInReportCmd_6
   4083                {
   4084                  attrDataLen++;
   \   000081   0E           INC     R6
   \   000082   04           INC     A
   \   000083   7001         JNZ     ??zclParseInReportCmd_6
   \   000085   0F           INC     R7
   4085                }
   4086          
   4087                dataPtr += attrDataLen;
   \                     ??zclParseInReportCmd_6:
   \   000086   12....       LCALL   ?Subroutine127 & 0xFFFF
   4088              }
   \                     ??CrossCallReturnLabel_217:
   \   000089   E5..         MOV     A,?V8
   \   00008B   C3           CLR     C
   \   00008C   95..         SUBB    A,?V7
   \   00008E   40B9         JC      ??zclParseInReportCmd_4
   4089            }
   4090          
   4091            return ( (void *)reportCmd );
   \                     ??zclParseInReportCmd_3:
   \   000090   02....       LJMP    ?Subroutine7 & 0xFFFF
   4092          }
   4093          #endif // ZCL_REPORT
   4094          
   4095          /*********************************************************************
   4096           * @fn      zclParseInDefaultRspCmd
   4097           *
   4098           * @brief   Parse the "Profile" Default Response Command
   4099           *
   4100           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4101           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4102           *
   4103           * @param   pCmd - pointer to incoming data to parse
   4104           *
   4105           * @return  pointer to the parsed command structure
   4106           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4107          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   4108          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4109            zclDefaultRspCmd_t *defaultRspCmd;
   4110            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine97 & 0xFFFF
   4111          
   4112            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_154:
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A02         MOV     R2,#0x2
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4113            if ( defaultRspCmd != NULL )
   \   00000F   EA           MOV     A,R2
   \   000010   4B           ORL     A,R3
   \   000011   6009         JZ      ??zclParseInDefaultRspCmd_0
   4114            {
   4115              defaultRspCmd->commandID = *pBuf++;
   \   000013   12....       LCALL   ?Subroutine19 & 0xFFFF
   4116              defaultRspCmd->statusCode = *pBuf;
   4117            }
   \                     ??CrossCallReturnLabel_455:
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   4118          
   4119            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   00001C   02....       LJMP    ?Subroutine3 & 0xFFFF
   4120          }
   4121          
   4122          #ifdef ZCL_DISCOVER
   4123          /*********************************************************************
   4124           * @fn      zclParseInDiscAttrsCmd
   4125           *
   4126           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   4127           *
   4128           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4129           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4130           *
   4131           * @param   pCmd - pointer to incoming data to parse
   4132           *
   4133           * @return  pointer to the parsed command structure
   4134           */
   4135          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   4136          {
   4137            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4138            uint8 *pBuf = pCmd->pData;
   4139          
   4140            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   4141            if ( pDiscoverCmd != NULL )
   4142            {
   4143              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   4144              pBuf += 2;
   4145              pDiscoverCmd->maxAttrIDs = *pBuf;
   4146            }
   4147          
   4148            return ( (void *)pDiscoverCmd );
   4149          }
   4150          
   4151          /*********************************************************************
   4152           * @fn      zclParseInDiscAttrsRspCmd
   4153           *
   4154           * @brief   Parse the "Profile" Discovery Response Commands
   4155           *
   4156           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4157           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4158           *
   4159           * @param   pCmd - pointer to incoming data to parse
   4160           *
   4161           * @return  pointer to the parsed command structure
   4162           */
   4163          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4164          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   4165          {
   4166            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   4167            uint8 *pBuf = pCmd->pData;
   4168            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   4169          
   4170            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   4171                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   4172          
   4173            if ( pDiscoverRspCmd != NULL )
   4174            {
   4175              uint8 i;
   4176          
   4177              pDiscoverRspCmd->discComplete = *pBuf++;
   4178              pDiscoverRspCmd->numAttr = numAttr;
   4179          
   4180              for ( i = 0; i < numAttr; i++ )
   4181              {
   4182                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4183                pBuf += 2;
   4184                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   4185              }
   4186            }
   4187          
   4188            return ( (void *)pDiscoverRspCmd );
   4189          }
   4190          
   4191          /*********************************************************************
   4192           * @fn      zclParseInDiscCmdsCmd
   4193           *
   4194           * @brief   Parse the "Profile" Discovery Commands
   4195           *
   4196           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4197           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4198           *
   4199           * @param   pCmd - pointer to incoming data to parse
   4200           *
   4201           * @return  pointer to the parsed command structure
   4202           */
   4203          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   4204          {
   4205            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4206            uint8 *pBuf = pCmd->pData;
   4207          
   4208            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   4209            if ( pDiscoverCmd != NULL )
   4210            {
   4211              pDiscoverCmd->startCmdID = *pBuf++;
   4212              pDiscoverCmd->maxCmdID = *pBuf++;
   4213            }
   4214          
   4215            return ( (void *)pDiscoverCmd );
   4216          }
   4217          
   4218          /*********************************************************************
   4219           * @fn      zclParseInDiscCmdsRspCmd
   4220           *
   4221           * @brief   Parse the Discover Commands Response Command
   4222           *
   4223           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4224           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4225           *
   4226           * @param   pCmd - pointer to incoming data to parse
   4227           *
   4228           * @return  pointer to the parsed command structure
   4229           */
   4230          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4231          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   4232          {
   4233            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4234            uint8 *pBuf = pCmd->pData;
   4235            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   4236          
   4237              // allocate memory for size of structure plus variable array
   4238            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4239                              ( numCmds * sizeof(uint8) ) );
   4240            if ( pDiscoverRspCmd != NULL )
   4241            {
   4242              uint8 i;
   4243              pDiscoverRspCmd->discComplete = *pBuf++;
   4244              pDiscoverRspCmd->numCmd = numCmds;
   4245          
   4246              for ( i = 0; i < numCmds; i++ )
   4247              {
   4248                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4249              }
   4250            }
   4251          
   4252            return ( (void *)pDiscoverRspCmd );
   4253          }
   4254          
   4255          /*********************************************************************
   4256           * @fn      zclParseInDiscAttrsExtRspCmd
   4257           *
   4258           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4259           *
   4260           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4261           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4262           *
   4263           * @param   pCmd - pointer to incoming data to parse
   4264           *
   4265           * @return  pointer to the parsed command structure
   4266           */
   4267          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4268          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4269          {
   4270            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4271            uint8 i;
   4272            uint8 *pBuf = pCmd->pData;
   4273            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4274          
   4275            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4276                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   4277          
   4278            if ( pDiscoverRspCmd != NULL )
   4279            {
   4280              pDiscoverRspCmd->discComplete = *pBuf++;
   4281              pDiscoverRspCmd->numAttr = numAttrs;
   4282          
   4283              for ( i = 0; i < numAttrs; i++ )
   4284              {
   4285                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4286                pBuf += 2;
   4287                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4288                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4289              }
   4290            }
   4291          
   4292            return ( (void *)pDiscoverRspCmd );
   4293          }
   4294          #endif // ZCL_DISCOVER
   4295          
   4296          #ifdef ZCL_READ
   4297          /*********************************************************************
   4298           * @fn      zclProcessInReadCmd
   4299           *
   4300           * @brief   Process the "Profile" Read Command
   4301           *
   4302           * @param   pInMsg - incoming message to process
   4303           *
   4304           * @return  TRUE if command processed. FALSE, otherwise.
   4305           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine183_0
   \   000004                ; // Fall through to label ??Subroutine183_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine152:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine199_0
   \   000004                ; // Fall through to label ??Subroutine199_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4306          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4307          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   4308            zclReadCmd_t *readCmd;
   4309            zclReadRspCmd_t *readRspCmd;
   4310            zclAttrRec_t attrRec;
   4311            uint16 len;
   4312            uint8 i;
   4313          
   4314            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F583         MOV     DPH,A
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V10,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V11,A
   4315          
   4316            // calculate the length of the response status record
   4317            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4318          
   4319            readRspCmd = zcl_mem_alloc( len );
   \   00001E                ; Setup parameters for call to function osal_mem_alloc
   \   00001E   85..82       MOV     DPL,?V10
   \   000021   F583         MOV     DPH,A
   \   000023   E0           MOVX    A,@DPTR
   \   000024   75F006       MOV     B,#0x6
   \   000027   12....       LCALL   ??Subroutine223_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_529:
   \   00002A   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002D   8A..         MOV     ?V0,R2
   \   00002F   8B..         MOV     ?V1,R3
   4320            if ( readRspCmd == NULL )
   \   000031   EA           MOV     A,R2
   \   000032   45..         ORL     A,?V1
   \   000034   7005         JNZ     ??zclProcessInReadCmd_0
   4321            {
   4322              return FALSE; // EMBEDDED RETURN
   \   000036   7900         MOV     R1,#0x0
   \   000038   02....       LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
   4323            }
   4324          
   4325            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   00003B   85..82       MOV     DPL,?V10
   \   00003E   85..83       MOV     DPH,?V11
   \   000041   12....       LCALL   ?Subroutine100 & 0xFFFF
   4326            for ( i = 0; i < readCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_160:
   \   000044   75..00       MOV     ?V2,#0x0
   \   000047   800B         SJMP    ??zclProcessInReadCmd_2
   4327            {
   4328              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4329          
   4330              statusRec->attrID = readCmd->attrID[i];
   4331          
   4332              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4333                                   readCmd->attrID[i], &attrRec ) )
   4334              {
   4335                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4336                {
   4337                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4338                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4339                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4340                  {
   4341                    statusRec->data = attrRec.attr.dataPtr;
   4342                    statusRec->dataType = attrRec.attr.dataType;
   4343                  }
   4344                }
   4345                else
   4346                {
   4347                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4348                }
   4349              }
   4350              else
   4351              {
   4352                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_3:
   \   000049   85..82       MOV     DPL,?V6
   \   00004C   85..83       MOV     DPH,?V7
   \   00004F   7486         MOV     A,#-0x7a
   \                     ??zclProcessInReadCmd_4:
   \   000051   F0           MOVX    @DPTR,A
   4353              }
   \                     ??zclProcessInReadCmd_5:
   \   000052   05..         INC     ?V2
   \                     ??zclProcessInReadCmd_2:
   \   000054   85..82       MOV     DPL,?V10
   \   000057   85..83       MOV     DPH,?V11
   \   00005A   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_447:
   \   00005D   4003         JC      $+5
   \   00005F   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   000062   A8..         MOV     R0,?V2
   \   000064   E8           MOV     A,R0
   \   000065   75F006       MOV     B,#0x6
   \   000068   A4           MUL     AB
   \   000069   FA           MOV     R2,A
   \   00006A   ABF0         MOV     R3,B
   \   00006C   E5..         MOV     A,?V0
   \   00006E   2A           ADD     A,R2
   \   00006F   F582         MOV     DPL,A
   \   000071   E5..         MOV     A,?V1
   \   000073   3B           ADDC    A,R3
   \   000074   F583         MOV     DPH,A
   \   000076   A3           INC     DPTR
   \   000077   8582..       MOV     ?V4,DPL
   \   00007A   8583..       MOV     ?V5,DPH
   \   00007D   E8           MOV     A,R0
   \   00007E   28           ADD     A,R0
   \   00007F   F8           MOV     R0,A
   \   000080   E4           CLR     A
   \   000081   33           RLC     A
   \   000082   F9           MOV     R1,A
   \   000083   E5..         MOV     A,?V10
   \   000085   28           ADD     A,R0
   \   000086   F582         MOV     DPL,A
   \   000088   E5..         MOV     A,?V11
   \   00008A   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   00008D   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000090   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_483:
   \   000093   E5..         MOV     A,?V4
   \   000095   2402         ADD     A,#0x2
   \   000097   F5..         MOV     ?V6,A
   \   000099   E4           CLR     A
   \   00009A   35..         ADDC    A,?V5
   \   00009C   F5..         MOV     ?V7,A
   \   00009E   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   0000A1                ; Setup parameters for call to function zclFindAttrRec
   \   0000A1   A8..         MOV     R0,?XSP + 0
   \   0000A3   A9..         MOV     R1,?XSP + 1
   \   0000A5   88..         MOV     ?V12,R0
   \   0000A7   89..         MOV     ?V13,R1
   \   0000A9   78..         MOV     R0,#?V12
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AE   8A82         MOV     DPL,R2
   \   0000B0   8B83         MOV     DPH,R3
   \   0000B2   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0000B5   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000B8   7402         MOV     A,#0x2
   \   0000BA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BD   E9           MOV     A,R1
   \   0000BE   6089         JZ      ??zclProcessInReadCmd_3
   \   0000C0   7405         MOV     A,#0x5
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000C8   5066         JNC     ??zclProcessInReadCmd_7
   \   0000CA   8E82         MOV     DPL,R6
   \   0000CC   8F83         MOV     DPH,R7
   \   0000CE   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   0000D1   2406         ADD     A,#0x6
   \   0000D3   F5..         MOV     ?V8,A
   \   0000D5   E4           CLR     A
   \   0000D6   39           ADDC    A,R1
   \   0000D7   F5..         MOV     ?V9,A
   \   0000D9   7405         MOV     A,#0x5
   \   0000DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000E1   5020         JNC     ??zclProcessInReadCmd_8
   \   0000E3                ; Setup parameters for call to function zclGetAuthorizeCB
   \   0000E3   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   0000E6   12....       LCALL   `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   0000E9   8A82         MOV     DPL,R2
   \   0000EB   8B83         MOV     DPH,R3
   \   0000ED   E582         MOV     A,DPL
   \   0000EF   4583         ORL     A,DPH
   \   0000F1   6010         JZ      ??zclProcessInReadCmd_8
   \   0000F3                ; Setup parameters for indirect call
   \   0000F3   7901         MOV     R1,#0x1
   \   0000F5   AC..         MOV     R4,?XSP + 0
   \   0000F7   AD..         MOV     R5,?XSP + 1
   \   0000F9   AA..         MOV     R2,?V8
   \   0000FB   AB..         MOV     R3,?V9
   \   0000FD   12....       LCALL   ?CALL_IND
   \   000100   E9           MOV     A,R1
   \   000101   8002         SJMP    ??zclProcessInReadCmd_9
   \                     ??zclProcessInReadCmd_8:
   \   000103   7400         MOV     A,#0x0
   4354            }
   \                     ??zclProcessInReadCmd_9:
   \   000105   85..82       MOV     DPL,?V6
   \   000108   85..83       MOV     DPH,?V7
   \   00010B   F0           MOVX    @DPTR,A
   \   00010C   6003         JZ      $+5
   \   00010E   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   \   000111   7406         MOV     A,#0x6
   \   000113   12....       LCALL   ?XSTACK_DISP0_8
   \   000116   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000119   A3           INC     DPTR
   \   00011A   A3           INC     DPTR
   \   00011B   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_486:
   \   00011E   7404         MOV     A,#0x4
   \   000120   12....       LCALL   ?XSTACK_DISP0_8
   \   000123   E0           MOVX    A,@DPTR
   \   000124   85..82       MOV     DPL,?V4
   \   000127   85..83       MOV     DPH,?V5
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   \                     ??zclProcessInReadCmd_7:
   \   000130   85..82       MOV     DPL,?V6
   \   000133   85..83       MOV     DPH,?V7
   \   000136   748F         MOV     A,#-0x71
   \   000138   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   4355          
   4356            // Build and send Read Response command
   4357            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4358                             readRspCmd, !pInMsg->hdr.fc.direction,
   4359                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   00013B   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   00013E                ; Setup parameters for call to function zcl_SendReadRsp
   \   00013E   8E82         MOV     DPL,R6
   \   000140   8F83         MOV     DPH,R7
   \   000142   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_471:
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000148   75..01       MOV     ?V2,#0x1
   \   00014B   78..         MOV     R0,#?V2
   \   00014D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000150   8E82         MOV     DPL,R6
   \   000152   8F83         MOV     DPH,R7
   \   000154   12....       LCALL   ??Subroutine215_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_489:
   \   000157   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015A   78..         MOV     R0,#?V0
   \   00015C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015F   85..82       MOV     DPL,?V8
   \   000162   85..83       MOV     DPH,?V9
   \   000165   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_522:
   \   000168   E5..         MOV     A,?V8
   \   00016A   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_492:
   \   00016D   35..         ADDC    A,?V9
   \   00016F   FB           MOV     R3,A
   \   000170   E5..         MOV     A,?V8
   \   000172   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   000175   35..         ADDC    A,?V9
   \   000177   F583         MOV     DPH,A
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   F9           MOV     R1,A
   \   00017B   12....       LCALL   `??zcl_SendReadRsp::?relay`; Banked call to: zcl_SendReadRsp
   \   00017E   7405         MOV     A,#0x5
   \   000180   12....       LCALL   ?DEALLOC_XSTACK8
   4360            zcl_mem_free( readRspCmd );
   \   000183                ; Setup parameters for call to function osal_mem_free
   \   000183   AA..         MOV     R2,?V0
   \   000185   AB..         MOV     R3,?V1
   \   000187   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4361          
   4362            return TRUE;
   \   00018A   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   00018C   7408         MOV     A,#0x8
   \   00018E   02....       LJMP    ?Subroutine11 & 0xFFFF
   4363          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine211_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine212_0
   \   000006                ; // Fall through to label ??Subroutine212_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine214_0
   \   000002                ; // Fall through to label ??Subroutine214_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL   ??Subroutine224_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_533:
   \   000003   85..82       MOV     DPL,?V8
   \   000006   85..83       MOV     DPH,?V9
   \   000009   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_401:
   \   00000C   E5..         MOV     A,?V8
   \   00000E   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000011   35..         ADDC    A,?V9
   \   000013   F583         MOV     DPH,A
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine215_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine216_0
   \   000002                ; // Fall through to label ??Subroutine216_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine217_0:
   \   000000   2406         ADD     A,#0x6
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   22           RET
   4364          #endif // ZCL_READ
   4365          
   4366          #ifdef ZCL_WRITE
   4367          /*********************************************************************
   4368           * @fn      processInWriteCmd
   4369           *
   4370           * @brief   Process the "Profile" Write and Write No Response Commands
   4371           *
   4372           * @param   pInMsg - incoming message to process
   4373           *
   4374           * @return  TRUE if command processed. FALSE, otherwise.
   4375           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_474:
   \   000009                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000009                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000009   85..82       MOV     DPL,?V4
   \   00000C   85..83       MOV     DPH,?V5
   \   00000F                REQUIRE ??Subroutine211_0
   \   00000F                ; // Fall through to label ??Subroutine211_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4376          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4377          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4378            zclWriteCmd_t *writeCmd;
   4379            zclWriteRspCmd_t *writeRspCmd;
   4380            uint8 sendRsp = FALSE;
   \   00000E   7F00         MOV     R7,#0x0
   4381            uint8 j = 0;
   \   000010   12....       LCALL   ?Subroutine99 & 0xFFFF
   4382            uint8 i;
   4383          
   4384            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_498:
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   E8           MOV     A,R0
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   E9           MOV     A,R1
   \   00001D   12....       LCALL   ?Subroutine35 & 0xFFFF
   4385            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_37:
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6402         XRL     A,#0x2
   \   000025   701C         JNZ     ??zclProcessInWriteCmd_0
   4386            {
   4387              // We need to send a response back - allocate space for it
   4388              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4389                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000027                ; Setup parameters for call to function osal_mem_alloc
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000030   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000033   8A..         MOV     ?V0,R2
   \   000035   8B..         MOV     ?V1,R3
   4390              if ( writeRspCmd == NULL )
   \   000037   EA           MOV     A,R2
   \   000038   45..         ORL     A,?V1
   \   00003A   7005         JNZ     ??zclProcessInWriteCmd_1
   4391              {
   4392                return FALSE; // EMBEDDED RETURN
   \   00003C   7900         MOV     R1,#0x0
   \   00003E   02....       LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
   4393              }
   4394          
   4395              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   000041   7F01         MOV     R7,#0x1
   4396            }
   4397          
   4398            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   000043   75..00       MOV     ?V6,#0x0
   \   000046   801C         SJMP    ??zclProcessInWriteCmd_3
   4399            {
   4400              zclAttrRec_t attrRec;
   4401              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4402          
   4403              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4404                                   statusRec->attrID, &attrRec ) )
   4405              {
   4406                if ( statusRec->dataType == attrRec.attr.dataType )
   4407                {
   4408                  uint8 status;
   4409          
   4410                  // Write the new attribute value
   4411                  if ( attrRec.attr.dataPtr != NULL )
   4412                  {
   4413                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4414                                               &attrRec, statusRec );
   4415                  }
   4416                  else // Use CB
   4417                  {
   4418                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4419                                                      &attrRec, statusRec->attrData );
   4420                  }
   4421          
   4422                  // If successful, a write attribute status record shall NOT be generated
   4423                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4424                  {
   4425                    // Attribute is read only - move on to the next write attribute record
   4426                    writeRspCmd->attrList[j].status = status;
   4427                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4428                  }
   4429                }
   4430                else
   4431                {
   4432                  // Attribute data type is incorrect - move on to the next write attribute record
   4433                  if ( sendRsp )
   4434                  {
   4435                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4436                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4437                  }
   4438                }
   4439              }
   4440              else
   4441              {
   4442                // Attribute is not supported - move on to the next write attribute record
   4443                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   000048   EF           MOV     A,R7
   \   000049   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004B   5015         JNC     ??zclProcessInWriteCmd_5
   4444                {
   4445                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   00004D   85..82       MOV     DPL,?V14
   \   000050   85..83       MOV     DPH,?V15
   \   000053   7486         MOV     A,#-0x7a
   4446                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4447                }
   4448              }
   \                     ??zclProcessInWriteCmd_6:
   \   000055   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000058   85..82       MOV     DPL,?V12
   \   00005B   85..83       MOV     DPH,?V13
   \   00005E   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_484:
   \   000061   0E           INC     R6
   \                     ??zclProcessInWriteCmd_5:
   \   000062   05..         INC     ?V6
   \                     ??zclProcessInWriteCmd_3:
   \   000064   85..82       MOV     DPL,?XSP + 0
   \   000067   85..83       MOV     DPH,?XSP + 1
   \   00006A   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   00006D   E5..         MOV     A,?V6
   \   00006F   C3           CLR     C
   \   000070   98           SUBB    A,R0
   \   000071   4003         JC      $+5
   \   000073   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \   000076   E5..         MOV     A,?V6
   \   000078   75F005       MOV     B,#0x5
   \   00007B   A4           MUL     AB
   \   00007C   F8           MOV     R0,A
   \   00007D   A9F0         MOV     R1,B
   \   00007F   85..82       MOV     DPL,?XSP + 0
   \   000082   85..83       MOV     DPH,?XSP + 1
   \   000085   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000088   EE           MOV     A,R6
   \   000089   75F003       MOV     B,#0x3
   \   00008C   A4           MUL     AB
   \   00008D   F8           MOV     R0,A
   \   00008E   A9F0         MOV     R1,B
   \   000090   E5..         MOV     A,?V0
   \   000092   28           ADD     A,R0
   \   000093   F582         MOV     DPL,A
   \   000095   E5..         MOV     A,?V1
   \   000097   39           ADDC    A,R1
   \   000098   F583         MOV     DPH,A
   \   00009A   E582         MOV     A,DPL
   \   00009C   2402         ADD     A,#0x2
   \   00009E   F5..         MOV     ?V12,A
   \   0000A0   E4           CLR     A
   \   0000A1   3583         ADDC    A,DPH
   \   0000A3   F5..         MOV     ?V13,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   8582..       MOV     ?V14,DPL
   \   0000A9   8583..       MOV     ?V15,DPH
   \   0000AC   85..82       MOV     DPL,?V4
   \   0000AF   85..83       MOV     DPH,?V5
   \   0000B2   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   0000B5                ; Setup parameters for call to function zclFindAttrRec
   \   0000B5   7402         MOV     A,#0x2
   \   0000B7   12....       LCALL   ?XSTACK_DISP100_8
   \   0000BA   88..         MOV     ?V10,R0
   \   0000BC   89..         MOV     ?V11,R1
   \   0000BE   78..         MOV     R0,#?V10
   \   0000C0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C3   85..82       MOV     DPL,?V2
   \   0000C6   85..83       MOV     DPH,?V3
   \   0000C9   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   0000CC   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000CF   7402         MOV     A,#0x2
   \   0000D1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D4   E9           MOV     A,R1
   \   0000D5   7003         JNZ     $+5
   \   0000D7   02....       LJMP    ??zclProcessInWriteCmd_4 & 0xFFFF
   \   0000DA   85..82       MOV     DPL,?V2
   \   0000DD   85..83       MOV     DPH,?V3
   \   0000E0   A3           INC     DPTR
   \   0000E1   A3           INC     DPTR
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   F8           MOV     R0,A
   \   0000E4   7406         MOV     A,#0x6
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   68           XRL     A,R0
   \   0000EB   7071         JNZ     ??zclProcessInWriteCmd_8
   \   0000ED   85..82       MOV     DPL,?V4
   \   0000F0   85..83       MOV     DPH,?V5
   \   0000F3   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   0000F6   2414         ADD     A,#0x14
   \   0000F8   F5..         MOV     ?V8,A
   \   0000FA   E4           CLR     A
   \   0000FB   39           ADDC    A,R1
   \   0000FC   F5..         MOV     ?V9,A
   \   0000FE   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_496:
   \   000101   39           ADDC    A,R1
   \   000102   FB           MOV     R3,A
   \   000103   7408         MOV     A,#0x8
   \   000105   12....       LCALL   ?XSTACK_DISP0_8
   \   000108   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_373:
   \   00010B   6017         JZ      ??zclProcessInWriteCmd_9
   \   00010D                ; Setup parameters for call to function zclWriteAttrData
   \   00010D   78..         MOV     R0,#?V2
   \   00010F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000112   7404         MOV     A,#0x4
   \   000114   12....       LCALL   ?XSTACK_DISP102_8
   \   000117   85..82       MOV     DPL,?V8
   \   00011A   85..83       MOV     DPH,?V9
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   F9           MOV     R1,A
   \   00011F   12....       LCALL   `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   000122   801C         SJMP    ??zclProcessInWriteCmd_10
   \                     ??zclProcessInWriteCmd_9:
   \   000124                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000124   85..82       MOV     DPL,?V2
   \   000127   85..83       MOV     DPH,?V3
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000130   7404         MOV     A,#0x4
   \   000132   12....       LCALL   ?XSTACK_DISP102_8
   \   000135   85..82       MOV     DPL,?V8
   \   000138   85..83       MOV     DPH,?V9
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   F9           MOV     R1,A
   \   00013D   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteCmd_10:
   \   000140   7402         MOV     A,#0x2
   \   000142   12....       LCALL   ?DEALLOC_XSTACK8
   \   000145   E9           MOV     A,R1
   \   000146   F8           MOV     R0,A
   \   000147   EF           MOV     A,R7
   \   000148   A2E0         MOV     C,0xE0 /* A   */.0
   \   00014A   4003         JC      $+5
   \   00014C   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   00014F   E8           MOV     A,R0
   \   000150   7003         JNZ     $+5
   \   000152   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000155   85..82       MOV     DPL,?V14
   \   000158   85..83       MOV     DPH,?V15
   \   00015B   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \                     ??zclProcessInWriteCmd_8:
   \   00015E   EF           MOV     A,R7
   \   00015F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000161   4003         JC      $+5
   \   000163   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000166   85..82       MOV     DPL,?V14
   \   000169   85..83       MOV     DPH,?V15
   \   00016C   748D         MOV     A,#-0x73
   \   00016E   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   4449            } // for loop
   4450          
   4451            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_7:
   \   000171   EF           MOV     A,R7
   \   000172   A2E0         MOV     C,0xE0 /* A   */.0
   \   000174   5038         JNC     ??zclProcessInWriteCmd_11
   4452            {
   4453              writeRspCmd->numAttr = j;
   \   000176   EE           MOV     A,R6
   \   000177   85..82       MOV     DPL,?V0
   \   00017A   85..83       MOV     DPH,?V1
   \   00017D   F0           MOVX    @DPTR,A
   4454              if ( writeRspCmd->numAttr == 0 )
   \   00017E   7003         JNZ     ??CrossCallReturnLabel_50
   4455              {
   4456                // Since all records were written successful, include a single status record
   4457                // in the resonse command with the status field set to SUCCESS and the
   4458                // attribute ID field omitted.
   4459                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000180   12....       LCALL   ?Subroutine41 & 0xFFFF
   4460                writeRspCmd->numAttr = 1;
   4461              }
   4462          
   4463              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4464                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4465                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_50:
   \   000183   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_472:
   \   000186   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000189   75..01       MOV     ?V2,#0x1
   \   00018C   78..         MOV     R0,#?V2
   \   00018E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000191   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_490:
   \   000194   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000197   78..         MOV     R0,#?V0
   \   000199   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00019C   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   00019F   12....       LCALL   `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   0001A2   7405         MOV     A,#0x5
   \   0001A4   12....       LCALL   ?DEALLOC_XSTACK8
   4466              zcl_mem_free( writeRspCmd );
   \   0001A7                ; Setup parameters for call to function osal_mem_free
   \   0001A7   AA..         MOV     R2,?V0
   \   0001A9   AB..         MOV     R3,?V1
   \   0001AB   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4467            }
   4468          
   4469            return TRUE;
   \                     ??zclProcessInWriteCmd_11:
   \   0001AE   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   0001B0   740A         MOV     A,#0xa
   \   0001B2   02....       LJMP    ??Subroutine174_0 & 0xFFFF
   4470          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine215_0
   \   000006                ; // Fall through to label ??Subroutine215_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine165:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine217_0
   \   000001                ; // Fall through to label ??Subroutine217_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   7E00         MOV     R6,#0x0
   \   000002   EA           MOV     A,R2
   \   000003   240C         ADD     A,#0xc
   \   000005   F582         MOV     DPL,A
   \   000007   E4           CLR     A
   \   000008   35..         ADDC    A,?V5
   \   00000A   F583         MOV     DPH,A
   \   00000C                REQUIRE ??Subroutine218_0
   \   00000C                ; // Fall through to label ??Subroutine218_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine149:
   \   000000   12....       LCALL   ?Subroutine170 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   12....       LCALL   ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_531:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_535:
   \   000007   EE           MOV     A,R6
   \   000008   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_495:
   \   00000B   3F           ADDC    A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   EE           MOV     A,R6
   \   00000E   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   000011   3F           ADDC    A,R7
   \   000012   F583         MOV     DPH,A
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   8A82         MOV     DPL,R2
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   8582..       MOV     ?V2,DPL
   \   00000E   8583..       MOV     ?V3,DPH
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   A3           INC     DPTR
   \   000001   E4           CLR     A
   \   000002   F0           MOVX    @DPTR,A
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009   04           INC     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V2
   \   000004   85..83       MOV     DPH,?V3
   \   000007   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_504:
   \   00000A   22           RET
   4471          
   4472          /*********************************************************************
   4473           * @fn      zclRevertWriteUndividedCmd
   4474           *
   4475           * @brief   Revert the "Profile" Write Undevided Command
   4476           *
   4477           * @param   pInMsg - incoming message to process
   4478           * @param   curWriteRec - old data
   4479           * @param   numAttr - number of attributes to be reverted
   4480           *
   4481           * @return  none
   4482           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4483          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4484                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4485          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V10,R4
   \   000010   8D..         MOV     ?V11,R5
   4486            uint8 i;
   4487          
   4488            for ( i = 0; i < numAttr; i++ )
   \   000012   75..00       MOV     ?V0,#0x0
   \   000015   741C         MOV     A,#0x1c
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   00001D   8030         SJMP    ??zclRevertWriteUndividedCmd_0
   4489            {
   4490              zclAttrRec_t attrRec;
   4491              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4492          
   4493              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4494                                    statusRec->attrID, &attrRec ) )
   4495              {
   4496                break; // should never happen
   4497              }
   4498          
   4499              if ( attrRec.attr.dataPtr != NULL )
   4500              {
   4501                // Just copy the old data back - no need to validate the data
   4502                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4503                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4504              }
   4505              else // Use CB
   4506              {
   4507                // Write the old data back
   4508                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4509                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_1:
   \   00001F   85..82       MOV     DPL,?V2
   \   000022   85..83       MOV     DPH,?V3
   \   000025   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   4510              }
   \                     ??CrossCallReturnLabel_423:
   \   000028                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000028   8A..         MOV     ?V4,R2
   \   00002A   8B..         MOV     ?V5,R3
   \   00002C   78..         MOV     R0,#?V4
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP102_8
   \   000036   EE           MOV     A,R6
   \   000037   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_493:
   \   00003A   3F           ADDC    A,R7
   \   00003B   FB           MOV     R3,A
   \   00003C   EE           MOV     A,R6
   \   00003D   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000040   3F           ADDC    A,R7
   \   000041   F583         MOV     DPH,A
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclRevertWriteUndividedCmd_2:
   \   00004D   05..         INC     ?V0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00004F   C3           CLR     C
   \   000050   E5..         MOV     A,?V0
   \   000052   95..         SUBB    A,?V8
   \   000054   E4           CLR     A
   \   000055   95..         SUBB    A,?V9
   \   000057   4003         JC      $+5
   \   000059   02....       LJMP    ??zclRevertWriteUndividedCmd_3 & 0xFFFF
   \   00005C   E5..         MOV     A,?V0
   \   00005E   75F005       MOV     B,#0x5
   \   000061   A4           MUL     AB
   \   000062   F8           MOV     R0,A
   \   000063   A9F0         MOV     R1,B
   \   000065   E5..         MOV     A,?V10
   \   000067   28           ADD     A,R0
   \   000068   FE           MOV     R6,A
   \   000069   E5..         MOV     A,?V11
   \   00006B   39           ADDC    A,R1
   \   00006C   FF           MOV     R7,A
   \   00006D   85..82       MOV     DPL,?V2
   \   000070   85..83       MOV     DPH,?V3
   \   000073   12....       LCALL   ??Subroutine218_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_501:
   \   000076   88..         MOV     ?V4,R0
   \   000078   89..         MOV     ?V5,R1
   \   00007A                ; Setup parameters for call to function zclFindAttrRec
   \   00007A   A8..         MOV     R0,?XSP + 0
   \   00007C   A9..         MOV     R1,?XSP + 1
   \   00007E   88..         MOV     ?V6,R0
   \   000080   89..         MOV     ?V7,R1
   \   000082   78..         MOV     R0,#?V6
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   12....       LCALL   ??Subroutine220_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_517:
   \   00008E   85..82       MOV     DPL,?V4
   \   000091   85..83       MOV     DPH,?V5
   \   000094   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_395:
   \   000097   E5..         MOV     A,?V4
   \   000099   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00009C   35..         ADDC    A,?V5
   \   00009E   F583         MOV     DPH,A
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F9           MOV     R1,A
   \   0000A2   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000A5   7402         MOV     A,#0x2
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   6045         JZ      ??zclRevertWriteUndividedCmd_3
   \   0000AD   EE           MOV     A,R6
   \   0000AE   2403         ADD     A,#0x3
   \   0000B0   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   0000B3   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_393:
   \   0000B6   7406         MOV     A,#0x6
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_424:
   \   0000BE   EE           MOV     A,R6
   \   0000BF   4F           ORL     A,R7
   \   0000C0   7003         JNZ     $+5
   \   0000C2   02....       LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   \   0000C5                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000C5   7404         MOV     A,#0x4
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   F9           MOV     R1,A
   \   0000CC   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000CF   8A..         MOV     ?V6,R2
   \   0000D1   8B..         MOV     ?V7,R3
   \   0000D3   AC..         MOV     R4,?V6
   \   0000D5   AD..         MOV     R5,?V7
   \   0000D7                ; Setup parameters for call to function osal_memcpy
   \   0000D7   85..82       MOV     DPL,?V4
   \   0000DA   85..83       MOV     DPH,?V5
   \   0000DD   12....       LCALL   ?Subroutine67 & 0xFFFF
   4511            } // for loop
   \                     ??CrossCallReturnLabel_106:
   \   0000E0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E3   EE           MOV     A,R6
   \   0000E4   FA           MOV     R2,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   FB           MOV     R3,A
   \   0000E7   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000EA   7403         MOV     A,#0x3
   \   0000EC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EF   02....       LJMP    ??zclRevertWriteUndividedCmd_2 & 0xFFFF
   4512          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   0000F2   7408         MOV     A,#0x8
   \   0000F4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F7   02....       LJMP    ??Subroutine179_0 & 0xFFFF
   4513          
   4514          /*********************************************************************
   4515           * @fn      zclProcessInWriteUndividedCmd
   4516           *
   4517           * @brief   Process the "Profile" Write Undivided Command
   4518           *
   4519           * @param   pInMsg - incoming message to process
   4520           *
   4521           * @return  TRUE if command processed. FALSE, otherwise.
   4522           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine200_0
   \   000006                ; // Fall through to label ??Subroutine200_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4523          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4524          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4525            zclWriteCmd_t *writeCmd;
   4526            zclWriteRspCmd_t *writeRspCmd;
   4527            zclAttrRec_t attrRec;
   4528            uint16 dataLen;
   4529            uint16 curLen = 0;
   \   00000E   75..00       MOV     ?V8,#0x0
   \   000011   75..00       MOV     ?V9,#0x0
   4530            uint8 j = 0;
   \   000014   12....       LCALL   ?Subroutine99 & 0xFFFF
   4531            uint8 i;
   4532          
   4533            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_499:
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   4534          
   4535            // Allocate space for Write Response Command
   4536            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4537                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_485:
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000027   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   4538            if ( writeRspCmd == NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   4539            {
   4540              return FALSE; // EMBEDDED RETURN
   4541            }
   4542          
   4543            // If any attribute cannot be written, no attribute values are changed. Hence,
   4544            // make sure all the attributes are supported and writable
   4545            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000036   7F00         MOV     R7,#0x0
   \   000038   803C         SJMP    ??zclProcessInWriteUndividedCmd_1
   4546            {
   4547              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4548          
   4549              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4550                                    statusRec->attrID, &attrRec ) )
   4551              {
   4552                // Attribute is not supported - stop here
   4553                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4554                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4555                break;
   4556              }
   4557          
   4558              if ( statusRec->dataType != attrRec.attr.dataType )
   4559              {
   4560                // Attribute data type is incorrect - stope here
   4561                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4562                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4563                break;
   4564              }
   4565          
   4566              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4567              {
   4568                // Attribute is not writable - stop here
   4569                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4570                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4571                break;
   4572              }
   4573          
   4574              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4575              {
   4576                // Not authorized to write - stop here
   4577                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4578                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4579                break;
   4580              }
   4581          
   4582              // Attribute Data length
   4583              if ( attrRec.attr.dataPtr != NULL )
   4584              {
   4585                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4586              }
   4587              else // Use CB
   4588              {
   4589                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4590                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   00003A   12....       LCALL   ?Subroutine69 & 0xFFFF
   4591              }
   \                     ??CrossCallReturnLabel_524:
   \   00003D   12....       LCALL   ??Subroutine220_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_518:
   \   000040   8882         MOV     DPL,R0
   \   000042   8983         MOV     DPH,R1
   \   000044   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_396:
   \   000047   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   00004A   12....       LCALL   `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   00004D   85..82       MOV     DPL,?XSP + 0
   \   000050   85..83       MOV     DPH,?XSP + 1
   \   000053   12....       LCALL   ??Subroutine225_0 & 0xFFFF
   4592          
   4593              // add padding if needed
   4594              if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_541:
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005F   5003         JNC     ??CrossCallReturnLabel_218
   4595              {
   4596                dataLen++;
   \   000061   12....       LCALL   ?Subroutine128 & 0xFFFF
   4597              }
   4598          
   4599              curLen += dataLen;
   \                     ??CrossCallReturnLabel_218:
   \   000064   85..82       MOV     DPL,?XSP + 0
   \   000067   85..83       MOV     DPH,?XSP + 1
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   25..         ADD     A,?V8
   \   00006D   F5..         MOV     ?V8,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   35..         ADDC    A,?V9
   \   000073   F5..         MOV     ?V9,A
   \   000075   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000076   7402         MOV     A,#0x2
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   00007E   5044         JNC     ??zclProcessInWriteUndividedCmd_4
   \   000080   EF           MOV     A,R7
   \   000081   75F005       MOV     B,#0x5
   \   000084   A4           MUL     AB
   \   000085   F8           MOV     R0,A
   \   000086   A9F0         MOV     R1,B
   \   000088   7402         MOV     A,#0x2
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000090   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000093   12....       LCALL   ?XSTACK_DISP100_8
   \   000096   88..         MOV     ?V10,R0
   \   000098   89..         MOV     ?V11,R1
   \   00009A   78..         MOV     R0,#?V10
   \   00009C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009F   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0000A2   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000A5   7402         MOV     A,#0x2
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   7048         JNZ     ??zclProcessInWriteUndividedCmd_5
   \   0000AD   85..82       MOV     DPL,?V0
   \   0000B0   85..83       MOV     DPH,?V1
   \   0000B3   A3           INC     DPTR
   \   0000B4   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000B6   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000B9   85..82       MOV     DPL,?V0
   \   0000BC   85..83       MOV     DPH,?V1
   \   0000BF   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_487:
   \   0000C2   7E01         MOV     R6,#0x1
   4600            } // for loop
   4601          
   4602            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   0000C4   EE           MOV     A,R6
   \   0000C5   85..82       MOV     DPL,?V0
   \   0000C8   85..83       MOV     DPH,?V1
   \   0000CB   F0           MOVX    @DPTR,A
   4603            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000CC   6003         JZ      $+5
   \   0000CE   02....       LJMP    ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   4604            {
   4605              uint8 *curDataPtr;
   4606              zclWriteRec_t *curWriteRec;
   4607          
   4608              // calculate the length of the current data header
   4609              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   0000D1   75F005       MOV     B,#0x5
   \   0000D4   A4           MUL     AB
   \   0000D5   FF           MOV     R7,A
   4610          
   4611              // Allocate space to keep a copy of the current data
   4612              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   0000D6                ; Setup parameters for call to function osal_mem_alloc
   \   0000D6   25..         ADD     A,?V8
   \   0000D8   FA           MOV     R2,A
   \   0000D9   E4           CLR     A
   \   0000DA   35..         ADDC    A,?V9
   \   0000DC   FB           MOV     R3,A
   \   0000DD   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000E0   8A..         MOV     ?V14,R2
   \   0000E2   8B..         MOV     ?V15,R3
   4613              if ( curWriteRec == NULL )
   \   0000E4   EA           MOV     A,R2
   \   0000E5   45..         ORL     A,?V15
   \   0000E7   705C         JNZ     ??zclProcessInWriteUndividedCmd_8
   4614              {
   4615                zcl_mem_free(writeRspCmd );
   \   0000E9                ; Setup parameters for call to function osal_mem_free
   \   0000E9   AA..         MOV     R2,?V0
   \   0000EB   AB..         MOV     R3,?V1
   \   0000ED   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4616                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   0000F0   7900         MOV     R1,#0x0
   \   0000F2   02....       LJMP    ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   4617              }
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   0000F5   7408         MOV     A,#0x8
   \   0000F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FA   12....       LCALL   ??Subroutine222_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_526:
   \   0000FD   A3           INC     DPTR
   \   0000FE   A3           INC     DPTR
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   69           XRL     A,R1
   \   000101   600B         JZ      ??zclProcessInWriteUndividedCmd_10
   \   000103   85..82       MOV     DPL,?V0
   \   000106   85..83       MOV     DPH,?V1
   \   000109   A3           INC     DPTR
   \   00010A   748D         MOV     A,#-0x73
   \   00010C   80A8         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00010E   7409         MOV     A,#0x9
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   E0           MOVX    A,@DPTR
   \   000114   A2E1         MOV     C,0xE0 /* A   */.1
   \   000116   400B         JC      ??zclProcessInWriteUndividedCmd_11
   \   000118   85..82       MOV     DPL,?V0
   \   00011B   85..83       MOV     DPH,?V1
   \   00011E   A3           INC     DPTR
   \   00011F   7488         MOV     A,#-0x78
   \   000121   8093         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000123   A2E5         MOV     C,0xE0 /* A   */.5
   \   000125   500B         JNC     ??zclProcessInWriteUndividedCmd_12
   \   000127   85..82       MOV     DPL,?V0
   \   00012A   85..83       MOV     DPH,?V1
   \   00012D   A3           INC     DPTR
   \   00012E   747E         MOV     A,#0x7e
   \   000130   8084         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   000132   740A         MOV     A,#0xa
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   00013A   7003         JNZ     $+5
   \   00013C   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   00013F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00013F   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000142   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4618          
   4619              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   000145   EA           MOV     A,R2
   \   000146   2F           ADD     A,R7
   \   000147   F5..         MOV     ?V8,A
   \   000149   E4           CLR     A
   \   00014A   3B           ADDC    A,R3
   \   00014B   F5..         MOV     ?V9,A
   4620          
   4621              // Write the new data over
   4622              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00014D   7F00         MOV     R7,#0x0
   \   00014F   8022         SJMP    ??zclProcessInWriteUndividedCmd_13
   4623              {
   4624                uint8 status;
   4625                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4626                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4627          
   4628                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4629                                      statusRec->attrID, &attrRec ) )
   4630                {
   4631                  break; // should never happen
   4632                }
   4633          
   4634                // Keep a copy of the current data before before writing the new data over
   4635                curStatusRec->attrID = statusRec->attrID;
   4636                curStatusRec->attrData = curDataPtr;
   4637          
   4638                if ( attrRec.attr.dataPtr != NULL )
   4639                {
   4640                  // Read the current value
   4641                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4642          
   4643                  // Write the new attribute value
   4644                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4645                                             &attrRec, statusRec );
   4646                }
   4647                else // Use CBs
   4648                {
   4649                  // Read the current value
   4650                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4651                                          statusRec->attrID, curDataPtr, &dataLen );
   4652                  // Write the new attribute value
   4653                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4654                                                    &attrRec, statusRec->attrData );
   4655                }
   4656          
   4657                // If successful, a write attribute status record shall NOT be generated
   4658                if ( status != ZCL_STATUS_SUCCESS )
   4659                {
   4660                  writeRspCmd->attrList[j].status = status;
   4661                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4662          
   4663                  // Since this write failed, we need to revert all the pervious writes
   4664                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4665                  break;
   4666                }
   4667          
   4668                // add padding if needed
   4669                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000151   85..82       MOV     DPL,?XSP + 0
   \   000154   85..83       MOV     DPH,?XSP + 1
   \   000157   E0           MOVX    A,@DPTR
   \   000158   A2E0         MOV     C,0xE0 /* A   */.0
   \   00015A   5003         JNC     ??CrossCallReturnLabel_219
   4670                {
   4671                  dataLen++;
   \   00015C   12....       LCALL   ?Subroutine128 & 0xFFFF
   4672                }
   4673          
   4674                curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_219:
   \   00015F   85..82       MOV     DPL,?XSP + 0
   \   000162   85..83       MOV     DPH,?XSP + 1
   \   000165   12....       LCALL   ??Subroutine218_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_502:
   \   000168   E5..         MOV     A,?V8
   \   00016A   28           ADD     A,R0
   \   00016B   F5..         MOV     ?V8,A
   \   00016D   E5..         MOV     A,?V9
   \   00016F   39           ADDC    A,R1
   \   000170   F5..         MOV     ?V9,A
   \   000172   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   000173   7402         MOV     A,#0x2
   \   000175   12....       LCALL   ?XSTACK_DISP0_8
   \   000178   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   00017B   4003         JC      $+5
   \   00017D   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   000180   EF           MOV     A,R7
   \   000181   75F005       MOV     B,#0x5
   \   000184   A4           MUL     AB
   \   000185   F8           MOV     R0,A
   \   000186   A9F0         MOV     R1,B
   \   000188   7402         MOV     A,#0x2
   \   00018A   12....       LCALL   ?XSTACK_DISP0_8
   \   00018D   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000190   E5..         MOV     A,?V14
   \   000192   28           ADD     A,R0
   \   000193   F5..         MOV     ?V12,A
   \   000195   E5..         MOV     A,?V15
   \   000197   39           ADDC    A,R1
   \   000198   F5..         MOV     ?V13,A
   \   00019A   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   00019D   12....       LCALL   ?XSTACK_DISP100_8
   \   0001A0   88..         MOV     ?V10,R0
   \   0001A2   89..         MOV     ?V11,R1
   \   0001A4   78..         MOV     R0,#?V10
   \   0001A6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A9   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0001AC   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0001AF   7402         MOV     A,#0x2
   \   0001B1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B4   E9           MOV     A,R1
   \   0001B5   7003         JNZ     $+5
   \   0001B7   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001BA   85..82       MOV     DPL,?V2
   \   0001BD   85..83       MOV     DPH,?V3
   \   0001C0   12....       LCALL   ??Subroutine218_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_503:
   \   0001C3   85..82       MOV     DPL,?V12
   \   0001C6   85..83       MOV     DPH,?V13
   \   0001C9   E8           MOV     A,R0
   \   0001CA   F0           MOVX    @DPTR,A
   \   0001CB   A3           INC     DPTR
   \   0001CC   E9           MOV     A,R1
   \   0001CD   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0001D0   E5..         MOV     A,?V8
   \   0001D2   F0           MOVX    @DPTR,A
   \   0001D3   A3           INC     DPTR
   \   0001D4   E5..         MOV     A,?V9
   \   0001D6   F0           MOVX    @DPTR,A
   \   0001D7   740A         MOV     A,#0xa
   \   0001D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DC   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_374:
   \   0001DF   6043         JZ      ??zclProcessInWriteUndividedCmd_16
   \   0001E1                ; Setup parameters for call to function zclReadAttrData
   \   0001E1   A8..         MOV     R0,?XSP + 0
   \   0001E3   A9..         MOV     R1,?XSP + 1
   \   0001E5   88..         MOV     ?V6,R0
   \   0001E7   89..         MOV     ?V7,R1
   \   0001E9   78..         MOV     R0,#?V6
   \   0001EB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001EE   7406         MOV     A,#0x6
   \   0001F0   12....       LCALL   ?XSTACK_DISP102_8
   \   0001F3   AA..         MOV     R2,?V8
   \   0001F5   AB..         MOV     R3,?V9
   \   0001F7   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   0001FA   7402         MOV     A,#0x2
   \   0001FC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FF   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_407:
   \   000202                ; Setup parameters for call to function zclWriteAttrData
   \   000202   78..         MOV     R0,#?V2
   \   000204   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000207   7406         MOV     A,#0x6
   \   000209   12....       LCALL   ?XSTACK_DISP102_8
   \   00020C   E5..         MOV     A,?V6
   \   00020E   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_494:
   \   000211   35..         ADDC    A,?V7
   \   000213   FB           MOV     R3,A
   \   000214   E5..         MOV     A,?V6
   \   000216   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000219   35..         ADDC    A,?V7
   \   00021B   F583         MOV     DPH,A
   \   00021D   E0           MOVX    A,@DPTR
   \   00021E   F9           MOV     R1,A
   \   00021F   12....       LCALL   `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   000222   8039         SJMP    ??zclProcessInWriteUndividedCmd_17
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   000224   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_408:
   \   000227                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000227   A8..         MOV     R0,?XSP + 0
   \   000229   A9..         MOV     R1,?XSP + 1
   \   00022B   88..         MOV     ?V10,R0
   \   00022D   89..         MOV     ?V11,R1
   \   00022F   78..         MOV     R0,#?V10
   \   000231   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000234   78..         MOV     R0,#?V8
   \   000236   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000239   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00023C   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   00023F   7404         MOV     A,#0x4
   \   000241   12....       LCALL   ?DEALLOC_XSTACK8
   \   000244   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_525:
   \   000247   A3           INC     DPTR
   \   000248   A3           INC     DPTR
   \   000249   A3           INC     DPTR
   \   00024A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00024D   7406         MOV     A,#0x6
   \   00024F   12....       LCALL   ?XSTACK_DISP102_8
   \   000252   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_497:
   \   000255   39           ADDC    A,R1
   \   000256   FB           MOV     R3,A
   \   000257   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   00025A   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   00025D   7402         MOV     A,#0x2
   \   00025F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000262   E9           MOV     A,R1
   \   000263   FA           MOV     R2,A
   \   000264   EA           MOV     A,R2
   \   000265   7003         JNZ     $+5
   \   000267   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   00026A   EE           MOV     A,R6
   \   00026B   75F003       MOV     B,#0x3
   \   00026E   A4           MUL     AB
   \   00026F   F8           MOV     R0,A
   \   000270   A9F0         MOV     R1,B
   \   000272   E5..         MOV     A,?V0
   \   000274   28           ADD     A,R0
   \   000275   F8           MOV     R0,A
   \   000276   E5..         MOV     A,?V1
   \   000278   39           ADDC    A,R1
   \   000279   F9           MOV     R1,A
   \   00027A   EA           MOV     A,R2
   \   00027B   8882         MOV     DPL,R0
   \   00027D   8983         MOV     DPH,R1
   \   00027F   A3           INC     DPTR
   \   000280   F0           MOVX    @DPTR,A
   \   000281   85..82       MOV     DPL,?V2
   \   000284   85..83       MOV     DPH,?V3
   \   000287   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   00028A   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_543:
   \   00028D   0E           INC     R6
   \   00028E                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   00028E   8F..         MOV     ?V2,R7
   \   000290   75..00       MOV     ?V3,#0x0
   \   000293   78..         MOV     R0,#?V2
   \   000295   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000298   AC..         MOV     R4,?V14
   \   00029A   AD..         MOV     R5,?V15
   \   00029C   AA..         MOV     R2,?V4
   \   00029E   AB..         MOV     R3,?V5
   \   0002A0   12....       LCALL   `??zclRevertWriteUndividedCmd::?relay`; Banked call to: zclRevertWriteUndividedCmd
   \   0002A3   7402         MOV     A,#0x2
   \   0002A5   12....       LCALL   ?DEALLOC_XSTACK8
   4675              } // for loop
   4676          
   4677              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0002A8   EE           MOV     A,R6
   \   0002A9   85..82       MOV     DPL,?V0
   \   0002AC   85..83       MOV     DPH,?V1
   \   0002AF   F0           MOVX    @DPTR,A
   4678              if ( writeRspCmd->numAttr  == 0 )
   \   0002B0   7003         JNZ     ??CrossCallReturnLabel_51
   4679              {
   4680                // Since all records were written successful, include a single status record
   4681                // in the resonse command with the status field set to SUCCESS and the
   4682                // attribute ID field omitted.
   4683                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002B2   12....       LCALL   ?Subroutine41 & 0xFFFF
   4684                writeRspCmd->numAttr = 1;
   4685              }
   4686          
   4687              zcl_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_51:
   \   0002B5                ; Setup parameters for call to function osal_mem_free
   \   0002B5   AA..         MOV     R2,?V14
   \   0002B7   AB..         MOV     R3,?V15
   \   0002B9   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4688            }
   4689          
   4690            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4691                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4692                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002BC   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_473:
   \   0002BF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002C2   75..01       MOV     ?V2,#0x1
   \   0002C5   78..         MOV     R0,#?V2
   \   0002C7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002CA   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_491:
   \   0002CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002D0   78..         MOV     R0,#?V0
   \   0002D2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002D5   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   0002D8   12....       LCALL   `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   0002DB   7405         MOV     A,#0x5
   \   0002DD   12....       LCALL   ?DEALLOC_XSTACK8
   4693            zcl_mem_free( writeRspCmd );
   \   0002E0                ; Setup parameters for call to function osal_mem_free
   \   0002E0   AA..         MOV     R2,?V0
   \   0002E2   AB..         MOV     R3,?V1
   \   0002E4   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4694          
   4695            return TRUE;
   \   0002E7   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   0002E9   740C         MOV     A,#0xc
   \   0002EB   02....       LJMP    ??Subroutine174_0 & 0xFFFF
   4696          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   2401         ADD     A,#0x1
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3400         ADDC    A,#0x0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   E8           MOV     A,R0
   \   000001   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000004   39           ADDC    A,R1
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V6,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V7,A
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D   7404         MOV     A,#0x4
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000003   EF           MOV     A,R7
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine221_0
   \   000006                ; // Fall through to label ??Subroutine221_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ??Subroutine224_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_532:
   \   000009   85..82       MOV     DPL,?V6
   \   00000C   85..83       MOV     DPH,?V7
   \   00000F   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_400:
   \   000012   E5..         MOV     A,?V6
   \   000014   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000017   35..         ADDC    A,?V7
   \   000019   F583         MOV     DPH,A
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_event_loop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsgExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsgExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_addExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_addExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_HandleExternal::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getRawAFMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getParsedTransSeqNum::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerPlugin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerAttrList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerClusterOptionList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerValidateAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_DeviceOperational::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendCommand::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRequest::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendConfigReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendConfigReportRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadReportCfgCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadReportCfgRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ProcessMessageMSG::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclBuildHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRecsList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAuthorizeCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSetSecurityOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSerializeData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAnalogDataType::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_BuildAnalogData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_BuildAnalogData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetDataTypeLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLengthUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAuthorizeWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInConfigReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInConfigReportRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadReportCfgCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadReportCfgRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclRevertWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd
   4697          #endif // ZCL_WRITE
   4698          
   4699          #ifdef ZCL_DISCOVER
   4700          /*********************************************************************
   4701           * @fn      zclProcessInDiscAttrs
   4702           *
   4703           * @brief   Process the "Profile" Discover Attributes Commands
   4704           *
   4705           * @param   pInMsg - incoming message to process
   4706           *
   4707           * @return  TRUE if command processed. FALSE, otherwise.
   4708           */
   4709          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4710          {
   4711            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4712            zclAttrRec_t attrRec;
   4713            uint16 attrID;
   4714            uint8 numAttrs;
   4715            uint8 i;
   4716          
   4717            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4718          
   4719            // Find out the number of attributes supported within the specified range
   4720            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4721            {
   4722              // finds the next attribute on this endpoint/cluster after the range.
   4723              // attributes must be in numerical order in the list.
   4724              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4725              {
   4726                break;
   4727              }
   4728            }
   4729          
   4730            numAttrs = i;  // store range of attributes in buffer
   4731          
   4732              // Process message for either attributes or extended attributes
   4733            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4734            {
   4735              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4736            }
   4737            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4738            {
   4739              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4740            }
   4741          
   4742            return TRUE;
   4743          }
   4744          
   4745          /*********************************************************************
   4746           * @fn      zclProcessInDiscAttrsCmd
   4747           *
   4748           * @brief   Process the Discover Attributes Command
   4749           *
   4750           * @param   pInMsg - incoming message to process
   4751           *
   4752           * @param   pDiscoverCmd - structure from requesting command
   4753           *
   4754           * @param   attrLenBuf - describes the amount of attributes to be processed
   4755           *
   4756           * @return  none
   4757           */
   4758          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4759          {
   4760            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4761            uint8 discComplete = TRUE;
   4762            zclAttrRec_t attrRec;
   4763            uint16 attrID;
   4764            uint8 i;
   4765          
   4766            // Allocate space for the response command
   4767            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4768                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4769            if ( pDiscoverRsp == NULL )
   4770            {
   4771              return; // EMBEDDED RETURN
   4772            }
   4773          
   4774            if ( numAttrs != 0 )
   4775            {
   4776              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4777              {
   4778                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4779                {
   4780                  break; // should not happen, as numAttrs already calculated
   4781                }
   4782          
   4783                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4784                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4785              }
   4786          
   4787              // Are there more attributes to be discovered?
   4788              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4789              {
   4790                discComplete = FALSE;
   4791              }
   4792            }
   4793          
   4794            pDiscoverRsp->discComplete = discComplete;
   4795            pDiscoverRsp->numAttr = numAttrs;
   4796          
   4797            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4798                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4799                                         true, pInMsg->hdr.transSeqNum );
   4800            zcl_mem_free( pDiscoverRsp );
   4801          
   4802            return;
   4803          }
   4804          
   4805          /*********************************************************************
   4806           * @fn      zclProcessInDiscAttrsExtCmd
   4807           *
   4808           * @brief   Process the Discover Attributes Extended Command
   4809           *
   4810           * @param   pInMsg - incoming message to process
   4811           *
   4812           * @param   pDiscoverCmd - structure from requesting command
   4813           *
   4814           * @param   attrLenBuf - describes the amount of attributes to be processed
   4815           *
   4816           * @return  none
   4817           */
   4818          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4819          {
   4820            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4821            uint8 discComplete = TRUE;
   4822            zclAttrRec_t attrRec;
   4823            uint16 attrID;
   4824            uint8 i;
   4825          
   4826              // Allocate space for the response command
   4827            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4828                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4829            if ( pDiscoverExtRsp == NULL )
   4830            {
   4831              return; // EMBEDDED RETURN
   4832            }
   4833          
   4834          
   4835            if ( numAttrs != 0 )
   4836            {
   4837              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4838              {
   4839                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4840                {
   4841                  break; // Should not happen, as numAttrs already calculated
   4842                }
   4843          
   4844                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4845                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4846                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4847              }
   4848          
   4849              // Are there more attributes to be discovered?
   4850              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4851              {
   4852                discComplete = FALSE;
   4853              }
   4854            }
   4855          
   4856            pDiscoverExtRsp->discComplete = discComplete;
   4857            pDiscoverExtRsp->numAttr = numAttrs;
   4858          
   4859            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4860                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4861                                         true, pInMsg->hdr.transSeqNum );
   4862          
   4863            zcl_mem_free( pDiscoverExtRsp );
   4864          
   4865            return;
   4866          }
   4867          
   4868          /*********************************************************************
   4869           * @fn      zclProcessInDiscCmd
   4870           *
   4871           * @brief   Process the "Profile" Discover Command
   4872           *
   4873           * @param   pInMsg - incoming message to process
   4874           *
   4875           * @return  TRUE if command processed. FALSE, otherwise.
   4876           */
   4877          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4878          {
   4879            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4880            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4881            ZStatus_t status;
   4882            zclCommandRec_t cmdRec;
   4883            uint8 cmdID;
   4884            uint8 i;
   4885            uint8 j;
   4886          
   4887            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4888          
   4889            // Find out the number of commands supported within the specified range
   4890            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4891            {
   4892              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4893              {
   4894                break;  // Command not supported
   4895              }
   4896            }
   4897          
   4898            // Allocate space for the response command
   4899            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4900          
   4901            if ( cmdRsp.pCmdID == NULL )
   4902            {
   4903              return FALSE; // EMBEDDED RETURN
   4904            }
   4905          
   4906            if ( i != 0 )
   4907            {
   4908              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4909              {
   4910                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4911                {
   4912                  break; // Attribute not supported
   4913                }
   4914          
   4915                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4916              }
   4917            }
   4918          
   4919            // Are there more commands to be discovered?
   4920            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4921            {
   4922              cmdRsp.discComplete = FALSE;
   4923            }
   4924            else
   4925            {
   4926              cmdRsp.discComplete = TRUE;
   4927            }
   4928          
   4929            // pass the command requested
   4930            cmdRsp.cmdType = pInMsg->hdr.commandID;
   4931          
   4932            // store number of commands returned
   4933            cmdRsp.numCmd = j;
   4934          
   4935            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4936                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   4937                                                true, pInMsg->hdr.transSeqNum );
   4938          
   4939            zcl_mem_free( cmdRsp.pCmdID );
   4940          
   4941            if ( status == ZSuccess )
   4942            {
   4943              return TRUE;
   4944            }
   4945            else
   4946            {
   4947              return FALSE;
   4948            }
   4949          }
   4950          
   4951          #endif // ZCL_DISCOVER
   4952          
   4953          
   4954          /*********************************************************************
   4955          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     26   zclAnalogDataType
      0     29   zclAuthorizeWrite
        0     14   -> zclGetAuthorizeCB
      1     39   zclBuildHdr
      2     54   zclFindAttrRec
        0     16   -> zclFindAttrRecsList
      2     16   zclFindAttrRecsList
      0     20   zclFindClusterOption
      0     45   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     58   zclGetAttrDataLengthUsingCB
        0     18   -> zclGetReadWriteCB
      0     40   zclGetAuthorizeCB
        0     10   -> zclFindAttrRecsList
      0     47   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0     26   zclGetDataTypeLength
      0     28   zclGetReadWriteCB
        0     10   -> zclFindAttrRecsList
      1     49   zclParseHdr
        0     12   -> osal_memset
      1     20   zclParseInConfigReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_memset
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     12   zclParseInConfigReportRspCmd
        0     12   -> osal_mem_alloc
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     12   zclParseInReadCmd
        0     12   -> osal_mem_alloc
      1     12   zclParseInReadReportCfgCmd
        0     12   -> osal_mem_alloc
      1     20   zclParseInReadReportCfgRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     25   zclParseInReadRspCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInReportCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInWriteCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      1     35   zclProcessInReadCmd
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     32   -> zclFindAttrRec
        0     30   -> zclGetAuthorizeCB
        0     35   -> zcl_SendReadRsp
      1     39   zclProcessInWriteCmd
        0     34   -> osal_mem_alloc
        0     34   -> osal_mem_free
        0     36   -> zclFindAttrRec
        0     36   -> zclWriteAttrData
        0     36   -> zclWriteAttrDataUsingCB
        0     39   -> zcl_SendWriteRsp
      1     41   zclProcessInWriteUndividedCmd
        0     36   -> osal_mem_alloc
        0     36   -> osal_mem_free
        0     38   -> zclFindAttrRec
        0     36   -> zclGetAttrDataLength
        0     36   -> zclGetAttrDataLengthUsingCB
        0     38   -> zclReadAttrData
        0     40   -> zclReadAttrDataUsingCB
        0     38   -> zclRevertWriteUndividedCmd
        0     38   -> zclWriteAttrData
        0     38   -> zclWriteAttrDataUsingCB
        0     41   -> zcl_SendWriteRsp
      0     56   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      0     60   zclReadAttrDataUsingCB
        0     16   -> zclGetReadWriteCB
      0     69   zclRevertWriteUndividedCmd
        0     31   -> osal_memcpy
        0     30   -> zclFindAttrRec
        0     28   -> zclGetAttrDataLength
        0     30   -> zclWriteAttrDataUsingCB
      1     45   zclSerializeData
        0     19   -> osal_buffer_uint32
        0     18   -> osal_memcpy
      0     47   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      0     56   zclWriteAttrData
        0     18   -> osal_memcpy
        0     15   -> zclAuthorizeWrite
        0     15   -> zclGetAttrDataLength
      0     56   zclWriteAttrDataUsingCB
        0     14   -> zclAuthorizeWrite
        0     14   -> zclGetReadWriteCB
      1     36   zcl_BuildAnalogData
        0     16   -> zclGetAttrDataLength
      0     62   zcl_DeviceOperational
        0     23   -> zclFindAttrRec
        0     23   -> zclReadAttrData
      1     12   zcl_HandleExternal
        0     12   -> osal_msg_allocate
        0     12   -> osal_msg_send
        0     12   -> zcl_getExternalFoundationHandler
      2      0   zcl_Init
      1     56   zcl_ProcessMessageMSG
        0     37   -> afFindEndPointDesc
        0     37   -> osal_mem_free
        0     37   -> zclGetClusterOption
        0     37   -> zclParseHdr
        0     37   -> zclSetSecurityOption
        0     39   -> zcl_DeviceOperational
        0     44   -> zcl_SendDefaultRspCmd
      0     32   zcl_ReadAttrData
        0     26   -> zclFindAttrRec
        0     26   -> zclReadAttrData
        0     28   -> zclReadAttrDataUsingCB
      1     76   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     30   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     42   zcl_SendConfigReportCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     26   -> zclAnalogDataType
        0     26   -> zclGetDataTypeLength
        0     26   -> zclSerializeData
        0     37   -> zcl_SendCommand
      1     36   zcl_SendConfigReportRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     67   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      1     36   zcl_SendRead
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     36   zcl_SendReadReportCfgCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     42   zcl_SendReadReportCfgRspCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     26   -> zclAnalogDataType
        0     26   -> zclGetDataTypeLength
        0     26   -> zclSerializeData
        0     37   -> zcl_SendCommand
      1     70   zcl_SendReadRsp
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetAttrDataLengthUsingCB
        0     28   -> zclReadAttrDataUsingCB
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     38   zcl_SendReportCmd
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     39   zcl_SendWriteRequest
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     72   zcl_SendWriteRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     19   zcl_addExternalFoundationHandler
        0     10   -> osal_mem_alloc
      0     12   zcl_event_loop
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_msg_send
        0     12   -> zcl_ProcessMessageMSG
        0     12   -> zcl_getExternalFoundationHandler
      2     12   zcl_getExternalFoundationHandler
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerAttrList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      0      9   zcl_registerForMsg
        0      9   -> zcl_addExternalFoundationHandler
      0      9   zcl_registerForMsgExt
        0      9   -> zcl_addExternalFoundationHandler
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine174_0
       8  ??Subroutine175_0
       6  ??Subroutine176_0
       5  ??Subroutine177_0
       6  ??Subroutine178_0
       5  ??Subroutine179_0
       5  ??Subroutine180_0
       7  ??Subroutine181_0
       6  ??Subroutine182_0
       8  ??Subroutine183_0
       9  ??Subroutine184_0
       8  ??Subroutine185_0
       1  ??Subroutine186_0
       2  ??Subroutine187_0
       1  ??Subroutine188_0
       8  ??Subroutine189_0
       8  ??Subroutine190_0
       6  ??Subroutine191_0
       7  ??Subroutine192_0
       5  ??Subroutine193_0
       5  ??Subroutine194_0
       5  ??Subroutine195_0
       1  ??Subroutine196_0
       3  ??Subroutine197_0
       4  ??Subroutine198_0
       6  ??Subroutine199_0
       8  ??Subroutine200_0
       6  ??Subroutine201_0
       5  ??Subroutine202_0
       4  ??Subroutine203_0
      10  ??Subroutine204_0
       8  ??Subroutine205_0
       6  ??Subroutine206_0
       7  ??Subroutine207_0
       7  ??Subroutine208_0
      12  ??Subroutine209_0
       6  ??Subroutine210_0
       6  ??Subroutine211_0
       6  ??Subroutine212_0
       6  ??Subroutine213_0
       6  ??Subroutine214_0
       2  ??Subroutine215_0
      15  ??Subroutine216_0
       5  ??Subroutine217_0
       4  ??Subroutine218_0
       2  ??Subroutine219_0
       4  ??Subroutine220_0
       4  ??Subroutine221_0
       9  ??Subroutine222_0
      10  ??Subroutine223_0
       6  ??Subroutine224_0
       6  ??Subroutine225_0
       7  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine10
       5  ?Subroutine100
       5  ?Subroutine101
       5  ?Subroutine102
      16  ?Subroutine103
       6  ?Subroutine104
      19  ?Subroutine105
       8  ?Subroutine106
       7  ?Subroutine107
       6  ?Subroutine108
       9  ?Subroutine109
       5  ?Subroutine11
       5  ?Subroutine110
      12  ?Subroutine111
      10  ?Subroutine112
       4  ?Subroutine113
       4  ?Subroutine114
      23  ?Subroutine115
      12  ?Subroutine116
      12  ?Subroutine117
      12  ?Subroutine118
      21  ?Subroutine119
       5  ?Subroutine12
      16  ?Subroutine120
       8  ?Subroutine121
      22  ?Subroutine122
      11  ?Subroutine123
      19  ?Subroutine124
      16  ?Subroutine125
       8  ?Subroutine126
      13  ?Subroutine127
       9  ?Subroutine128
      11  ?Subroutine129
      80  ?Subroutine13
      14  ?Subroutine130
      10  ?Subroutine131
       6  ?Subroutine132
       9  ?Subroutine133
       1  ?Subroutine134
       4  ?Subroutine135
       6  ?Subroutine136
       9  ?Subroutine137
       9  ?Subroutine138
       8  ?Subroutine139
       1  ?Subroutine14
       6  ?Subroutine140
      16  ?Subroutine141
       3  ?Subroutine142
      14  ?Subroutine143
       4  ?Subroutine144
      10  ?Subroutine145
       2  ?Subroutine146
       8  ?Subroutine147
      11  ?Subroutine148
       6  ?Subroutine149
      32  ?Subroutine15
       4  ?Subroutine150
      10  ?Subroutine151
       4  ?Subroutine152
       9  ?Subroutine153
       6  ?Subroutine154
       5  ?Subroutine155
       7  ?Subroutine156
       1  ?Subroutine157
       5  ?Subroutine158
       9  ?Subroutine159
      18  ?Subroutine16
       9  ?Subroutine160
       7  ?Subroutine161
      21  ?Subroutine162
      15  ?Subroutine163
       6  ?Subroutine164
       1  ?Subroutine165
       3  ?Subroutine166
       6  ?Subroutine167
       6  ?Subroutine168
       8  ?Subroutine169
      27  ?Subroutine17
       9  ?Subroutine170
       5  ?Subroutine171
       5  ?Subroutine172
       7  ?Subroutine173
      20  ?Subroutine18
       7  ?Subroutine19
       3  ?Subroutine2
      18  ?Subroutine20
      30  ?Subroutine21
       8  ?Subroutine22
      14  ?Subroutine23
       4  ?Subroutine24
      12  ?Subroutine25
       2  ?Subroutine26
      12  ?Subroutine27
       6  ?Subroutine28
       4  ?Subroutine29
       5  ?Subroutine3
      11  ?Subroutine30
       4  ?Subroutine31
       5  ?Subroutine32
       4  ?Subroutine33
       6  ?Subroutine34
      11  ?Subroutine35
       8  ?Subroutine36
       8  ?Subroutine37
       5  ?Subroutine38
       4  ?Subroutine39
       5  ?Subroutine4
       7  ?Subroutine40
      12  ?Subroutine41
      10  ?Subroutine42
       8  ?Subroutine43
      17  ?Subroutine44
       2  ?Subroutine45
       2  ?Subroutine46
      30  ?Subroutine47
       5  ?Subroutine48
       5  ?Subroutine49
       4  ?Subroutine5
       6  ?Subroutine50
      24  ?Subroutine51
       4  ?Subroutine52
      18  ?Subroutine53
      10  ?Subroutine54
       6  ?Subroutine55
      17  ?Subroutine56
      20  ?Subroutine57
       6  ?Subroutine58
      28  ?Subroutine59
       4  ?Subroutine6
      18  ?Subroutine60
       3  ?Subroutine61
      23  ?Subroutine62
      15  ?Subroutine63
       5  ?Subroutine64
       8  ?Subroutine65
       6  ?Subroutine66
       9  ?Subroutine67
      10  ?Subroutine68
       6  ?Subroutine69
       4  ?Subroutine7
       9  ?Subroutine70
       6  ?Subroutine71
      24  ?Subroutine72
      32  ?Subroutine73
       4  ?Subroutine74
      14  ?Subroutine75
      13  ?Subroutine76
      23  ?Subroutine77
       4  ?Subroutine78
       7  ?Subroutine79
       3  ?Subroutine8
       4  ?Subroutine80
       9  ?Subroutine81
      12  ?Subroutine82
       6  ?Subroutine83
      10  ?Subroutine84
       2  ?Subroutine85
      17  ?Subroutine86
       4  ?Subroutine87
       2  ?Subroutine88
      12  ?Subroutine89
       5  ?Subroutine9
      11  ?Subroutine90
       8  ?Subroutine91
      24  ?Subroutine92
       9  ?Subroutine93
       4  ?Subroutine94
       1  ?Subroutine95
       4  ?Subroutine96
      14  ?Subroutine97
       4  ?Subroutine98
      12  ?Subroutine99
       2  attrList
       2  clusterOptionList
       2  externalEndPointHandlerList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      33  zclAnalogDataType
       6  zclAnalogDataType::?relay
      59  zclAuthorizeWrite
       6  zclAuthorizeWrite::?relay
      91  zclBuildHdr
       6  zclBuildHdr::?relay
      92  zclCmdTable
     146  zclFindAttrRec
       6  zclFindAttrRec::?relay
      37  zclFindAttrRecsList
       6  zclFindAttrRecsList::?relay
     106  zclFindClusterOption
       6  zclFindClusterOption::?relay
      63  zclGetAttrDataLength
       6  zclGetAttrDataLength::?relay
     101  zclGetAttrDataLengthUsingCB
       6  zclGetAttrDataLengthUsingCB::?relay
      29  zclGetAuthorizeCB
       6  zclGetAuthorizeCB::?relay
      28  zclGetClusterOption
       6  zclGetClusterOption::?relay
     166  zclGetDataTypeLength
       6  zclGetDataTypeLength::?relay
      30  zclGetReadWriteCB
       6  zclGetReadWriteCB::?relay
     223  zclParseHdr
       6  zclParseHdr::?relay
     325  zclParseInConfigReportCmd
       6  zclParseInConfigReportCmd::?relay
     137  zclParseInConfigReportRspCmd
       6  zclParseInConfigReportRspCmd::?relay
      31  zclParseInDefaultRspCmd
       6  zclParseInDefaultRspCmd::?relay
     111  zclParseInReadCmd
       6  zclParseInReadCmd::?relay
      72  zclParseInReadReportCfgCmd
       6  zclParseInReadReportCfgCmd::?relay
     338  zclParseInReadReportCfgRspCmd
       6  zclParseInReadReportCfgRspCmd::?relay
     330  zclParseInReadRspCmd
       6  zclParseInReadRspCmd::?relay
     147  zclParseInReportCmd
       6  zclParseInReportCmd::?relay
     147  zclParseInWriteCmd
       6  zclParseInWriteCmd::?relay
     130  zclParseInWriteRspCmd
       6  zclParseInWriteRspCmd::?relay
     401  zclProcessInReadCmd
       6  zclProcessInReadCmd::?relay
     437  zclProcessInWriteCmd
       6  zclProcessInWriteCmd::?relay
     750  zclProcessInWriteUndividedCmd
       6  zclProcessInWriteUndividedCmd::?relay
     112  zclReadAttrData
       6  zclReadAttrData::?relay
      93  zclReadAttrDataUsingCB
       6  zclReadAttrDataUsingCB::?relay
     250  zclRevertWriteUndividedCmd
       6  zclRevertWriteUndividedCmd::?relay
     365  zclSerializeData
       6  zclSerializeData::?relay
      45  zclSetSecurityOption
       6  zclSetSecurityOption::?relay
     150  zclWriteAttrData
       6  zclWriteAttrData::?relay
     104  zclWriteAttrDataUsingCB
       6  zclWriteAttrDataUsingCB::?relay
     129  zcl_BuildAnalogData
       6  zcl_BuildAnalogData::?relay
     123  zcl_DeviceOperational
       6  zcl_DeviceOperational::?relay
     179  zcl_HandleExternal
       6  zcl_HandleExternal::?relay
      12  zcl_Init
       6  zcl_Init::?relay
    1076  zcl_ProcessMessageMSG
       6  zcl_ProcessMessageMSG::?relay
     131  zcl_ReadAttrData
       6  zcl_ReadAttrData::?relay
     417  zcl_SendCommand
       6  zcl_SendCommand::?relay
     445  zcl_SendConfigReportCmd
       6  zcl_SendConfigReportCmd::?relay
     245  zcl_SendConfigReportRspCmd
       6  zcl_SendConfigReportRspCmd::?relay
     136  zcl_SendDefaultRspCmd
       6  zcl_SendDefaultRspCmd::?relay
     186  zcl_SendRead
       6  zcl_SendRead::?relay
     160  zcl_SendReadReportCfgCmd
       6  zcl_SendReadReportCfgCmd::?relay
     464  zcl_SendReadReportCfgRspCmd
       6  zcl_SendReadReportCfgRspCmd::?relay
     420  zcl_SendReadRsp
       6  zcl_SendReadRsp::?relay
     217  zcl_SendReportCmd
       6  zcl_SendReportCmd::?relay
     217  zcl_SendWriteRequest
       6  zcl_SendWriteRequest::?relay
     178  zcl_SendWriteRsp
       6  zcl_SendWriteRsp::?relay
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
     133  zcl_addExternalFoundationHandler
       6  zcl_addExternalFoundationHandler::?relay
      98  zcl_event_loop
       6  zcl_event_loop::?relay
      60  zcl_getExternalFoundationHandler
       6  zcl_getExternalFoundationHandler::?relay
       9  zcl_getParsedTransSeqNum
       6  zcl_getParsedTransSeqNum::?relay
      12  zcl_getRawAFMsg
       6  zcl_getRawAFMsg::?relay
      90  zcl_registerAttrList
       6  zcl_registerAttrList::?relay
      76  zcl_registerClusterOptionList
       6  zcl_registerClusterOptionList::?relay
      10  zcl_registerForMsg
       6  zcl_registerForMsg::?relay
       8  zcl_registerForMsgExt
       6  zcl_registerForMsgExt::?relay
     103  zcl_registerPlugin
       6  zcl_registerPlugin::?relay
      58  zcl_registerReadWriteCB
       6  zcl_registerReadWriteCB::?relay
      15  zcl_registerValidateAttrData
       6  zcl_registerValidateAttrData::?relay

 
 13 031 bytes in segment BANKED_CODE
    372 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
     16 bytes in segment XDATA_Z
 
 13 495 bytes of CODE  memory
     16 bytes of XDATA memory

Errors: none
Warnings: none
